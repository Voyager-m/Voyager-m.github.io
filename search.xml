<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode-排序-选择排序</title>
      <link href="posts/35af54d9/"/>
      <url>posts/35af54d9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用通俗的语言来讲，选择排序，就是将数列中最大（小）的数找出来，放到合适的位置，然后在剩下的集合里面继续找最大（小）的数放在合适的位置，如此往复，直到整个数列变为有序位置。与冒泡排序不一样的是，它不是比较相邻的两个数，而是比较某个数与数列中剩下所有数的大小。</p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>原始数列为：</p><pre><code>7 3 5 1 9 4</code></pre><p>第一轮排序首先以第一个数为基数，与剩下的所有数进行比较，找到整个数列中最小的数，然后交换最小数与第一个数的位置。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[j] &lt;=iLIST[minIndex]:</span><br><span class="line">            minIdex = j</span><br></pre></td></tr></table></figure><p>以上排序过程会将第i+1（i从0开始）大的数放在数列下标为i的位置，那么第一次排序的结果为：</p><pre><code>1 3 5 7 9 4</code></pre><h2 id="2-第二轮排序："><a href="#2-第二轮排序：" class="headerlink" title="2.第二轮排序："></a>2.第二轮排序：</h2><pre><code>1 3 5 7 9 4</code></pre><h2 id="3-第三轮排序："><a href="#3-第三轮排序：" class="headerlink" title="3.第三轮排序："></a>3.第三轮排序：</h2><pre><code>1 3 4 7 9 5</code></pre><h2 id="4-第四轮排序："><a href="#4-第四轮排序：" class="headerlink" title="4.第四轮排序："></a>4.第四轮排序：</h2><pre><code>1 3 4 5 9 7</code></pre><h2 id="5-第五轮排序："><a href="#5-第五轮排序：" class="headerlink" title="5.第五轮排序："></a>5.第五轮排序：</h2><pre><code>1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList  <span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[i] != min(iList[i:]):  <span class="comment"># 判断当前元素是不是从当前元素开始的剩下所有元素中最小的</span></span><br><span class="line">            minIndex = iList.index(min(iList[i:]))  <span class="comment"># 将从当前元素开始的剩下所有元素中最小的元素索引复制给minIndex</span></span><br><span class="line">            iList[i], iList[minIndex] = iList[minIndex], iList[i]<span class="comment">#交换当前元素和最小元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(selectionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;selectionSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import selectionSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用此算法排序100次所花时间</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月14</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-冒泡排序</title>
      <link href="posts/6299afab/"/>
      <url>posts/6299afab/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>冒泡排序（Bubble Sort）是一种很原始的排序方法，就是通过不断交换“大数”的位置达到排序的目的。因为不断出现“大数”类似于水泡不断出现，因此被形象地称为冒泡算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从一组数列（列表）中挑选一个最大的数，如果这个数列比较小，有可能我们一眼就看出谁最大，但是如果数列比较大，那么就不好确定了，冒泡排序不需要直接找出数列中最大的那个数，只需要在两个数中找出最大的就可以了。</p><p>冒泡算法的原理是比较两个相邻数字的大小，将两个数中比较大的那个数交换到靠后的位置。这样不断交换下去就可以将最大的那个数放到最后的位置，然后从头开始将第二大的数放到倒数第二的位置上，如此反复，知道将数列变成有序数列。</p><p>举例：</p><pre><code>7 3 5 1 9 4</code></pre><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>第1次排序，按照冒泡排序的原理，比较相邻两个数的大小，从数列头开始第一次比较7和3的大小，7比3大，交换7和3的位置，把7放在靠后的位置。交换的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> iList[i]&gt;=iList[i+<span class="number">1</span>]</span><br><span class="line">     iList[i],iList[i+<span class="number">1</span>]=iList[i+<span class="number">1</span>],iList[i]</span><br><span class="line"> <span class="comment">#这里你可能会疑惑为什么iList[1]被覆盖了，还能给iList[i+1]赋值，这里为python的序列解包，相关语法可查python官方文档。</span></span><br></pre></td></tr></table></figure><p>交换后如图所示</p><pre><code>3 7 5 1 9 4</code></pre><p>第2次比较7和5的大小，发现7比5大，交换7和5的位置，结果如图：</p><pre><code>3 5 7 1 9 4</code></pre><p>第3次比较7和1的大小，7比1大，交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第4次比较7和9的大小，7比9小，不交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第5次比较9和4的位置，9比4大，交换位置，结果如下：</p><pre><code>3 5 1 7 4 9</code></pre><p>到此，第一轮排序已经结束，成功序列中最大的值9放入最后的位置。然后再进行下一轮排序。</p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><pre><code>第一次  3 5 1 7 4 9第二次  3 1 5 7 4 9第三次  3 1 5 7 4 9第四次  3 1 5 4 7 9</code></pre><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><pre><code>第一次  1 3 5 4 7 9第二次  1 3 5 4 7 9第三次  1 3 4 5 7 9</code></pre><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><pre><code>第一次  1 3 4 5 7 9第二次  1 3 4 5 7 9</code></pre><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><pre><code>第一次  1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>建立无序序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#实现创建一个无序的数组,名字为randomList</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomList</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回一个长度为n的整数列表，数据范围[0,1000]&#x27;&#x27;&#x27;</span></span><br><span class="line">    iList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        iList.append(random.randrange(<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    iList=randomList(<span class="number">10</span>)</span><br><span class="line">    print(iList)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对无序序列进行冒泡排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> iList[j] &gt;= iList[j + <span class="number">1</span>]:  <span class="comment"># 比较相邻两数的大小</span></span><br><span class="line">                iList[j], iList[j + <span class="number">1</span>] = iList[j + <span class="number">1</span>], iList[j]  <span class="comment"># 将较大的数交换到靠后的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(bubbleSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;bubbleSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import bubbleSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用bubbleSort函数排序100遍用的时长</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月13日早</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-归并排序</title>
      <link href="posts/63e6e1be/"/>
      <url>posts/63e6e1be/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>给大家讲个故事：“从前有座山，山里有座庙，庙里有个老和尚在给小和尚讲故事，讲的是从前有座山，山里有座庙，庙里有个老和尚在给小和尚……”，这个故事大家可能都听过，这个故事实际上就体现了递归的思想，每个故事都在调用故事本身。本算法也用了递归思想，首先我们把数列分为left和right两个子数列，然后将left和right两个子数列都变成有序数列，再把他们合并到一起就变成了一个有序数列，那么left和right两子数列如何变成有序的呢，我们将left和right两个子数列分别再分成两部分得到子子数列，然后再将子子数列排序后合并得到有序的子书数列，那么子子数列如何变成有序数列呢，我们……这样的做法是不是很想前面将的那个故事呢。当然，他们还是有区别的，故事可以无限制讲下去，数列不会无限制分下去，当分到最小的子数列只有一个元素的时候，就不能再分了，这时候就要开始合并数列了。</p><p>将数列分为子数列的核心代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">middle = len(iList)//<span class="number">2</span> <span class="comment">#求分割点下标</span></span><br><span class="line">left , right = iList[<span class="number">0</span>:middle] , iList[middle:]   <span class="comment">#得到数列的切片 </span></span><br></pre></td></tr></table></figure><p>我们还是举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101801.png"></p><h3 id="1-第一次分组"><a href="#1-第一次分组" class="headerlink" title="1.第一次分组"></a>1.第一次分组</h3><p>长度为7，得到middle=6/2=3，两部分为[0:3]和[3:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101802.png"></p><h3 id="2-第二次分组"><a href="#2-第二次分组" class="headerlink" title="2.第二次分组"></a>2.第二次分组</h3><p>第一次分组得到的left和right长度为3，我们仍然无法知道这个长度为3的数列是否有序。那么继续分组<br>长度都为3，得到middle=3/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101803.png"></p><h3 id="3-第三次分组"><a href="#3-第三次分组" class="headerlink" title="3.第三次分组"></a>3.第三次分组</h3><p>第二次分组得到的left和right长度为1和2，我们仍然无法知道这个长度为2的数列是否有序。那么继续分组<br>长度都为2，得到middle=2/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101804.png"></p><p>至此，一个数列长度为6的数列，经过三次分组，被我们分成了六个长度为1的子数列，现在每个子数列已经为有序了，我们可以开始合并了。</p><p>将两个子数列合并的核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  left  <span class="keyword">and</span> right :  <span class="comment">#遍历两个子数列</span></span><br><span class="line">    <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]: <span class="comment">#将两子数列中较小的元素添加到mList中</span></span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="1-第一次合并"><a href="#1-第一次合并" class="headerlink" title="1.第一次合并"></a>1.第一次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101805.png"></p><h3 id="2-第二次合并"><a href="#2-第二次合并" class="headerlink" title="2.第二次合并"></a>2.第二次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101806.png"></p><h3 id="3-第三次合并"><a href="#3-第三次合并" class="headerlink" title="3.第三次合并"></a>3.第三次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101807.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:  <span class="comment"># 若只有一个元素，那就返回iList</span></span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    middle = len(iList) // <span class="number">2</span>  <span class="comment"># 求分割点下标</span></span><br><span class="line">    left, right = iList[<span class="number">0</span>:middle], iList[middle:]  <span class="comment"># 得到数列的切片</span></span><br><span class="line">    <span class="keyword">return</span> mergeList(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    mList = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:  <span class="comment"># 遍历两个子数列</span></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]:  <span class="comment"># 将两子数列中较小的元素添加到mList中</span></span><br><span class="line">            mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> mList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        print(iList)</span><br><span class="line">        print(mergeSort(iList))</span><br><span class="line">        print(timeit.timeit(<span class="string">&quot;mergeSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import mergeSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用归并排序算法排序100次花费的时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单解释下，代码中mergeSort实际上是在分组，mergeList实际上是在合并，注意mergeSort中的return语句给mergeList传的是两个函数参数，而mergeList接受的应该是两个列表，所以mergeSort分组语句将会不断进栈，一直到列表分成很多个长度为1的子列表后，开始出栈，执行mergeList函数进行合并，最后将最后一个有序的mList列表返回给mergeSort函数。</p><p>整理于2020年10月18日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-插入排序</title>
      <link href="posts/e02a01f2/"/>
      <url>posts/e02a01f2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>插入排序实际上跟我们打牌一样，斗地主应该大部分人都会玩的，我们在抓牌的时候，每当从下面抓起一张牌，我们就会将这张牌放到合适的位置，使手上的牌始终是一个有序的状态（有些人打牌也习惯乱放，前提是自己看得懂）。那么插入排序的过程，和以上的过程就很相似。</p><p>插入排序，首先将数列分成两部分，将数列的第一个数划分为left部分，剩下的数为right部分，我们依次将right部分的数一个一个取出，然后将该数放入left部分合适的位置，这样，left部分数越来越多，right部分的数越来越少，最后right部分为空，这时候left部分就为有序数列了。</p><p>核心实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>:len(iList))<span class="comment">#从第二个元素开始遍历right部分</span></span><br><span class="line">   target=iList[right]<span class="comment">#将每一个遍历的元素赋值为target</span></span><br><span class="line">   <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>:right)<span class="comment">#遍历left部分（left部分有序）</span></span><br><span class="line">       <span class="keyword">if</span> target&lt;=iList[left]:<span class="comment">#找到target该插入的位置</span></span><br><span class="line">           iList[left+<span class="number">1</span>:right+<span class="number">1</span>]=iList[left:right]<span class="comment">#插入位置后元素整体后移一位</span></span><br><span class="line">           iList[left]=target<span class="comment">#将target放在合适位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们还是那个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101601.png"></p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>我们将数列分为left和right两部分。开始的时候left部分为第一个数7（有序部分），剩下的为right部分（待排序部分）。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101602.png"></p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><p>从right中取出第一个数字3，然后将它放入left中合适的位置。从前往后遍历left部分的数，发现7比3大，然后将7以及后面的数（当前情况7后面没有数字）往后移一位，将3放在原本7所在的位置。（这里因为left只有一个7，比较简单，但是不了left部分多长都是一样的思想）</p><p><img src="https://voyager-m.gitee.io/picgo/test/101603.png"></p><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><p>我们从right部分继续选出元素5，然后从头遍历left部分的数，发现数字7比5大，这时候将7以及7后面的元素（当前情况7后面没有数字）往后移一位，将3放在原本7在的位置。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101604.png"></p><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101605.png"></p><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101606.png"></p><h3 id="6-第六轮排序"><a href="#6-第六轮排序" class="headerlink" title="6.第六轮排序"></a>6.第六轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101607.png"></p><p>自此，left部分为原数列排序后的有序数列。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        target = iList[right]</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>, right):</span><br><span class="line">            <span class="keyword">if</span> target &lt;= iList[left]:</span><br><span class="line">                iList[left + <span class="number">1</span>:right + <span class="number">1</span>] = iList[left:right]</span><br><span class="line">                iList[left] = target</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(insertionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;insertionSort(iList)&quot;</span>, <span class="string">&quot;from __main__ import  insertionSort,iList&quot;</span>, number=<span class="number">100</span>) ) <span class="comment"># 用这个算法排序100次所花时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整理于2020年10月16日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台-数据中台初识</title>
      <link href="posts/18280cf2/"/>
      <url>posts/18280cf2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、数据中台现象"><a href="#一、数据中台现象" class="headerlink" title="一、数据中台现象"></a>一、数据中台现象</h2><p>数据中台近两年非常火热，数据中台的热度已经拆超越了数字化转型的热度并且一直在上升。数据中台发起于2018年，崛起于2019年3月，目前已经远远超越了数据仓库，商业智能。 </p><p><strong>企业对数据中台的期望：</strong>与业务更精密，提供数据服务，提供业务价值，快速开发数据服务，围绕业务场景，提供统一数据，为业务赋能，构建统一的数据资产，打通数据的孤岛。</p><p>以上是企业的现实需求，那么为什么现有的数据仓库，数据平台（数据湖），商业智不能很好的满足这些需求呢。要弄清楚这个问题，我们就要弄清楚数据中台和前面这些东西的区别在哪里。</p><p><strong>商业智能和数据仓库：</strong>已分析报表为核心，把数据加工成分析报表提供给决策层去看，从而实现辅助决策的功能。商业智能的底层，是数据仓库。主要使用者是决策者。<br>数据湖：结构化数据和非结构化数据快速为业务产生数据服务，以数据存储和大数据为核心。主要的使用对象是开发者。</p><p><strong>数据中台：</strong>希望是直接服务于业务的平台，距离业务更近，用多种方式直接为业务提供数据产品。</p><p><strong>从出发点来说。</strong>数据中台优先考虑的是业务需要什么导向，是以业务需求为出发点。数据平台是存储加工数据的平台，所实现的功能取决于拥有的数据情况。是以技术和数据为导向的。</p><p><strong>从度量来看。</strong>数据中台做的好不好是以数据服务客户的满意度。数据平台的度量是看数据质量。</p><p>数据中台要核心解决的问题是过去企业应用开发团队和数据开发团队的协同问题，其中包括效率问题（应用开发一个报表都需要十几天时间），协作问题（获取数据错误，同样的数据逻辑却要开发两遍），能力问题（应用开发的人员很多，懂数据开发的人员很少）。数据中台能让应用开发专注于应用开发，让数据开发团队专注于数据开发。</p><p>数据中台是加速源数据产生业务价值的服务工厂，按照Gartner的分层架构理念，上面的是前端的创新型系统，下面是后端的记录型系统，中间的是链接前端创新想系统和后端的记录型系统的系统。上面的前台叫做敏态，下面的后台叫稳态。比如现在企业的erp等系统，这些系统偏企业后端的系统一般变化比较小，所以我们叫做稳态系统。比如h5广告，用户画像，这些系统是随着外界的变化而不断在变化，所以我们把它们叫叫做敏态系统。所以需要一个链接这两种系统的平台，于是中台产生了，中台的作用是使两种系统的速度一致，让后台提供服务给前台更快更敏捷。即数据中台是为了协调敏态前台业务和稳态的后台的速度，让他们之间的协作更加流畅，从而加速从元数据到业务价值的产生过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/1.png"></p><h2 id="二、现在业界常见的数据中台架构"><a href="#二、现在业界常见的数据中台架构" class="headerlink" title="二、现在业界常见的数据中台架构"></a>二、现在业界常见的数据中台架构</h2><h3 id="阿里数据中台"><a href="#阿里数据中台" class="headerlink" title="阿里数据中台"></a>阿里数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/2.png"><br><img src="https://voyager-m.gitee.io/picgo/test/3.png"></p><p>阿里数据中台是由Service，Entity，Data为核心组成。主要是三个方面的内容：OneData(业务数据化)，OneEntity(数据业务化)，OneService(业务服务化)。</p><h3 id="菜鸟数据中台"><a href="#菜鸟数据中台" class="headerlink" title="菜鸟数据中台"></a>菜鸟数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/4.png"></p><h3 id="苏宁数据中台"><a href="#苏宁数据中台" class="headerlink" title="苏宁数据中台"></a>苏宁数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/5.png"></p><p>数据中台对企业的意义就是，让传统企业向科技企业升级，让IT系统集成向大数据集成升级，让工具/流程/管理向驱动业务运营升级。</p><p><strong>数据平台：</strong></p><p>1.有完整的数据模型设计，但偏重设计和技术，在执行过程中，很难保证数据的全，数据应用一般不考虑跨过数据中心。</p><p>2.初期数据发展快，效率高，快速体现业务价值，但是随着数据仓库的建设，数据量急速叠加，整体成本居高不下。导致数据混乱，灾难。</p><p><strong>数据中台:</strong></p><p>1.数据中台的基本理念是：将所有数据汇聚到数据中台，每个数据应用都以数据中台为唯一数据来源。</p><p>2.苏宁数据中台的目标是为苏宁的数据战略提供有力的支撑，从企业全进行统一规划，统一建设，强调数据“全”。从设计、组织、建设、流程角度保障了模式的落地。</p><p>3.数据中台的建设减低了数据使用门槛。</p><h3 id="滴滴数据中台"><a href="#滴滴数据中台" class="headerlink" title="滴滴数据中台"></a>滴滴数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/6.png"><br><img src="https://voyager-m.gitee.io/picgo/test/7.png"></p><p>数据中台不是简单的把数据相应的模块系统放在公司里面搭建起来就ok。</p><p>数据可能今后发挥价值最大的地方是赋能AI。通过建立好数据中台服务层，再把它演变成对应的特征层，来驱动出这样强化学习的营销体系，目前滴滴的数据中台更多的产生价值在生产侧。</p><p><strong>目前存在的一些困难问题:</strong></p><p>1.在数据生产价值线（数据-&gt;生产-&gt;价值）中质量，效率，成本的问题.</p><p>2.数据实际上是现实物理世界在数据世界中的投影，那么不同的场景就会产生不同的投影，同样的业务行为在不同的场景下会有不同的分析角度。在业务角度，当然希望这种场景和维度越多越好，但是这会给数据管理带来很大的难度。</p><h3 id="Oppo数据中台"><a href="#Oppo数据中台" class="headerlink" title="Oppo数据中台"></a>Oppo数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/8.png"></p><p>Oppo日活跃用户超过2亿，在运营这些互联网应用的过程中，oppo积累了大量数据，已超过100PB，日增数据量超过20TB，oppo的数据中台以数据仓库为核心，构建了实时的数据服务能力。</p><p><strong>Oppo把数据中台分成了4个层次，:</strong></p><p>1.最下面的是统一工具体系，涵盖了“接入-&gt;治理-&gt;开发-&gt;消费”全数据链路。</p><p>2.基于工具体系之上构建了数据仓库，划分为“原始层-明细层-汇总层-应用层”，这也是经典的数据仓库架构，数据仓库在整个架构中处于非常基础和核心的位置。</p><p>3.再往上就是全域的数据体系，全域就是把公司所有的业务数据都打通，形成统一的数据资产，如ID-mapping，用户标签等。</p><p>4.最终，数据要能被业务用起来，需要场景驱动的数据产品与服务。</p><h3 id="浙江移动数据中台"><a href="#浙江移动数据中台" class="headerlink" title="浙江移动数据中台"></a>浙江移动数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/9.png"></p><p>打造数据中台，实现跨域数据整合并沉淀公共的数据能力，同时提供丰富的数据模型，标准化的数据服务，个性化的开发平台与工具，满足一线数据开放和智慧运营要求。</p><h3 id="从业务数据化到数据业务化"><a href="#从业务数据化到数据业务化" class="headerlink" title="从业务数据化到数据业务化"></a>从业务数据化到数据业务化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/10.png"></p><h2 id="三、数据中台的愿景和使命"><a href="#三、数据中台的愿景和使命" class="headerlink" title="三、数据中台的愿景和使命"></a>三、数据中台的愿景和使命</h2><p><strong>数据中台的愿景：</strong>打造数据驱动的智能企业</p><p><strong>数据中台的使命：</strong>赋能业务以数据智能能力，让业务更智慧</p><h2 id="四、数据中台的本质和六大能力模型"><a href="#四、数据中台的本质和六大能力模型" class="headerlink" title="四、数据中台的本质和六大能力模型"></a>四、数据中台的本质和六大能力模型</h2><p>**数据中台的本质:**数据中台是数据服务工厂为企业提供可复用的数据智能服务</p><p>数据中台的六大能力模型：</p><p><strong>数据资产的规划和治理：</strong></p><p>数据资产的规划和治理，是数据中台的基础功能，它的目的是为了在构建数据服务，数据产品，数据应用之前，先画出企业的数据资产蓝图，尽可能的涵盖企业所有的可能产生和使用的数据，不论是企业内部数据还是外部数据。</p><p>数据资产的规划和治理体系，是企业数据战略的体现，承载系统是企业级数据资产目录(Data Asset Catalog)。</p><p>数据资产的规划和治理，是从根本上最大限度解决数据孤岛(Data Silo)问题的方案，也就是在应用构建，数据产生之前就规划好数据的产生和消费的数据流体系，从而所有的应用都按照这个规范来执行。</p><p><strong>数据自元的获取和存储：</strong></p><p>在企业梳理了构建了自己的数据资产蓝图后，就需要将这些数据资产对应的数据资源进行存储和存储，也就是很多企业常说的，“数据入湖”。</p><p>数据资源的获取和存储，在广义数据中台体系里是数据平台的一部分，不同的企业在不同的阶段，可以采用的技术手段是不一样的，关系型数据库，大数据平台，数据湖，乃至最简单的文件存储都可以作为数据资源存储获取的方式，并不一定要拘泥于一种形式。</p><p>这个模块的核心是数据资源是能够被按需获取到的，这也就意味着，哪怕我们不构建独立的数据存储，让数据留在源系统中，只要能够在需要的时候获取到，也是可以的。</p><p><strong>数据资产的共享和协作：</strong></p><p>如何能够让企业的业务更智慧，这里最重要的事情就是跨域数据的组合和分析，不同领域的数据的挖掘，整合才能产生人的经验所不能够具备的洞察。</p><p>数据中台区别于传统数据仓库的一个重要的特点，就是数据中台是企业的数据服务的协作生产平台，他是一个能够让业务需求人员，数据分析人员这样的数据使用方和数据工程师，数据管理员这样的数据提供方在一个平台上去共同使用同一套企业的数据资产的协作平台。这里很重要的功能就是企业数据门户，企业数据目录和数据版本管理，数据沙箱（Sandbox)，数据分级权限体系。</p><p><strong>业务价值的探索和分析：</strong></p><p>数据中台是一个数据服务工厂，那么这个工厂应该生产什么服务呢？</p><p>就像传统的工厂都会有一个研发中心一样，数据中台需要一个数据实验室平台，能够让业务人员，数据分析人员，数据科学家们在数据协作平台上，利用同一套数据进行业务价值的探索和分析，从而识别有价值的数据集，然后在批量生产，形成数据产品和服务。</p><p>这部分重要的功能是数据挖掘，数据科学平台，算法平台，机器学习平台等。</p><p><strong>数据服务的构建和治理：</strong></p><p>当有价值的数据服务在实验室（研发中心）中被识别出来，并且通过协作平台被验证，那么这个过程就要被工业化，形成一个数据服务的生产线（Data Pipeline），从而能够被自动，批量的生产出来，为业务提供按需的服务，这就是数据服务的构建部分。</p><p>数据中台会生产非常多的数据服务，所以，数据中台同时要提供这么多数据服务的治理功能，从而保证数据服务的全生命周期体系化管理，优化有价值的数据服务，下线过时的数据服务。</p><p><strong>数据服务的度量和运营：</strong></p><p>传统的数据仓库系统往往只关注系统的稳定性，但是并不关注提供的数据报表的使用情况，被应用的如何，是否为业务产生了价值。而数据中台作为企业的数据服务工厂，是一个运营数据服务的业务单元。</p><p>整理于2020年10月14日</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据中台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力大数据技术框架整理</title>
      <link href="posts/8a1e23b3/"/>
      <url>posts/8a1e23b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> 随着社会现代化不断推进，出先了很多例如大数据和人工智能等新型技术，这些技术正在为越来越多的行业赋能。电力在我们生活中可以说是处处不在，为了提供更加便捷智能的服务，电力行业也出现了许多需要解决的问题。那么互联网技术如何为电网赋能呢？电网这个庞大的体系中的各个分支都可以和哪些技术呢结合呢？作为一项研究课题，我们可以从哪些切入点开始呢？下面是我通过几天的学习给出的自己的答案。</p><p><img src="https://voyager-m.gitee.io/picgo/powerBigDataPic/electricBigData.png" alt="电力技术框架"></p><p> 这份框架图已经总结的很详细，这里就不再赘述。个人认为从研究切入点来说可以分为以下几点。</p><h2 id="一．研究现有方法，从技术层面为研究切入点"><a href="#一．研究现有方法，从技术层面为研究切入点" class="headerlink" title="一．研究现有方法，从技术层面为研究切入点"></a>一．研究现有方法，从技术层面为研究切入点</h2><h3 id="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"><a href="#以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。" class="headerlink" title="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"></a>以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。</h3><h2 id="二、寻找新的方法，从数据问题为研究切入点"><a href="#二、寻找新的方法，从数据问题为研究切入点" class="headerlink" title="二、寻找新的方法，从数据问题为研究切入点"></a>二、寻找新的方法，从数据问题为研究切入点</h2><h3 id="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"><a href="#现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。" class="headerlink" title="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"></a>现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。</h3><h3 id="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"><a href="#伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。" class="headerlink" title="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"></a>伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。</h3><h3 id="面临的一些问题："><a href="#面临的一些问题：" class="headerlink" title="面临的一些问题："></a>面临的一些问题：</h3><h3 id="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"><a href="#（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。" class="headerlink" title="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"></a>（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。</h3><h3 id="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"><a href="#（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。" class="headerlink" title="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"></a>（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。</h3><h3 id="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"><a href="#（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高" class="headerlink" title="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"></a>（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高</h3><h3 id="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"><a href="#（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。" class="headerlink" title="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"></a>（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。</h3><h2 id="三、探索新方案，从具体问题为研究切入点"><a href="#三、探索新方案，从具体问题为研究切入点" class="headerlink" title="三、探索新方案，从具体问题为研究切入点"></a>三、探索新方案，从具体问题为研究切入点</h2><h3 id="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"><a href="#电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。" class="headerlink" title="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"></a>电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。</h3><div class="note success simple"><p>以上为仅为作者个人观点。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧电网 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-汽车品牌知识图谱实战复现记录</title>
      <link href="posts/45c0910/"/>
      <url>posts/45c0910/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>写在前面</strong>：本人也是知识图谱“小白”，正在努力变“怪兽”，写文只为记录成长点滴，若有理解不合理亦或不到位的地方，敬请谅解。</p><h2 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102701.png"></p><p>这里环境配置还是有一些点需要注意的：</p><p>（1）若python版本是3.8以及以上的话是不支持time.clock()这个函数的，需要把这个函数换成time.perf_counter().若不想麻烦，可以考虑将电脑装两个版本的python。</p><p>（2）py2neo的版本不能低于4.0.0，因为4.0.0版本是个分界线，3.x和4.x接口的区别有点大，所以版本必须对应，不然后续会出现一系列问题。</p><p>（3）Neo4j-driver接口为了和前面版本对应应该安装1.6.1版本。</p><h2 id="2、业务需求分析"><a href="#2、业务需求分析" class="headerlink" title="2、业务需求分析"></a>2、业务需求分析</h2><p>基于搜索引擎的商业数据分析：</p><p>（1）行业分析：整体市场趋势、细分市场趋势</p><p>用户会不断搜索关于汽车某方面的信息，可能是通过品牌搜索，可能是通过车型等等，通过用户的这些行为找出整体的市场趋势，以及细分市场的分析。</p><p>（2）品牌分析：品牌市场份额、品牌粘性、品牌游离度</p><p>用户都在搜什么品牌，搜A品牌的用户又去搜了B品牌（为什么？），用户在搜索这个品牌的时候有没有什么持续性。。</p><p>（3）车系分析：车系市场份额、车系粘性、车系游离度</p><p>（4）车型分析：车型市场份额、车型粘性、车型游离度</p><p>（5）话题分析：热点排行、话题排行</p><p>（6）用户画像：自然属性分析、兴趣属性分布</p><p>我们来看几个例子咯：<br><img src="https://voyager-m.gitee.io/picgo/test/102702.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102703.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102704.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102705.png"></p><h2 id="3、项目总体框架设计"><a href="#3、项目总体框架设计" class="headerlink" title="3、项目总体框架设计"></a>3、项目总体框架设计</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102706.png"></p><p>项目分为应用层，业务层，数据层，ETL，数据源。</p><p><strong>数据源：</strong>一般获取渠道可以是汽车资讯网站、汽车电商平台、百科问答汽车频道、汽车投书平台。可以使用爬虫技术进行爬取，但要注意的是只能爬取网页公开的数据，遵守法律法规，做良好市民。（否者：爬虫写的好，牢饭吃的早）。</p><p><strong>ETL：</strong>这部分先通过爬虫框架scrapyEx爬取数据，然后经过页面目录管理、页面元素解析、动态页面渲染、页面内容解析、数据清洗转换、批量任务调度，使结点数据结构化和关系数据结构化。</p><p><strong>数据层：</strong>这一层我们首先要将数据导入到neo4j数据库，有两种方式，一种是Neo4j-import,另一种是Neo4j-Web控制台指令导入。这里我比较推荐第二种，因为指令可以让你非常清晰数据源的属性与生成结点或者关系之间的映射关系。</p><p><strong>业务层：</strong>通过py2neo开发框架将数据库与后台联系。然后pythonWeb实现实体识别，节点查询，关系查询，路径计算，上层用Django框架与前端连接，为用户提供交互窗口。</p><p><strong>应用层：</strong>这里主要是该框架的一些应用，比如只能搜索，智能问答，智能推荐等。</p><h2 id="4、知识图谱设计方法论"><a href="#4、知识图谱设计方法论" class="headerlink" title="4、知识图谱设计方法论"></a>4、知识图谱设计方法论</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102707.png"></p><p>专家法要求参与的人员经验很多，对业务非常熟悉。从上到下，总体规划。</p><p>参照法是以行业标准为参照来进行设计，在设计过程中不断修补裁剪。</p><p>归纳法是由技术过硬的专家来进行的，一般是自下向上，从一个点切入来设计的。</p><p>混合发是从上自下，从下自上同时进行，在中电处进行调整。</p><h2 id="5、数据导入："><a href="#5、数据导入：" class="headerlink" title="5、数据导入："></a>5、数据导入：</h2><div class="note success simple"><p>数据源必须为utf-8编码，不然结果会乱码。</p><p>修改为utf-8编码办法：笔记本打开csv文件，保存为UTF-8格式</p></div><p>&emsp;&emsp;</p><p>打开%NEO4J_HOME%\conf\neo4j.conf</p><p>将#dbms.connectors.default_listen_address=0.0.0.0的#去掉</p><p>&emsp;</p><p>进入 cmd控制台输入指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现下图：<br><img src="https://voyager-m.gitee.io/picgo/test/102708.png"></p><p>打开浏览器访问<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>然后输入数据库用户名和密码（初始密码都是neo4j），登录后也可以自己修改密码，出现如下界面：<br><img src="https://voyager-m.gitee.io/picgo/test/102709.png"></p><p>&emsp;&emsp;</p><p>打开cmd窗扣进入neo4j文件的bin目录下执行以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j-admin import --mode=csv --database=graph.db --nodes ..\import\bank01.csv </span><br></pre></td></tr></table></figure><p>我们就完成了数据的导入，下面我们就可以开始创建结点了。</p><h2 id="6、结点与关系创建"><a href="#6、结点与关系创建" class="headerlink" title="6、结点与关系创建"></a>6、结点与关系创建</h2><p>创建汽车品牌结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;bank01.csv&quot; AS line</span><br><span class="line">CREATE(:Car&#123;name:line.bank,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102710.png"></p><p>&emsp;&emsp;</p><p>创建汽车车系结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">CREATE(p:Serise&#123;name:line.serise,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102711.png"></p><p>&emsp;&emsp;</p><p>创建关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">MATCH (entity1:Car&#123;name:line.bank&#125;),(entity2:Serise&#123;name:line.serise&#125;)</span><br><span class="line">CREATE(entity1)-[:Subtype&#123;type:line.relation&#125;]-&gt;(entity2)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102712.png"></p><p>&emsp;&emsp;</p><p>指定唯一键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE  CONSTRAINT ON (b:Car)</span><br><span class="line">ASSERT b.name IS UNIQUE</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102713.png"></p><p>&emsp;&emsp;</p><p>至此，我们完成了206个品牌结点，1921个车系结点，1937个关系的导入</p><p>来看看界面吧：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102714.png"><br>汽车品牌结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102715.png"><br>汽车车系结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102716.png"><br>2127个车系，206个汽车品牌，1921个关系都展现出来了，是不是很壮观呢，哈哈哈哈<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102717.png"><br>来个清晰的</p><h2 id="7、前端界面展示"><a href="#7、前端界面展示" class="headerlink" title="7、前端界面展示"></a>7、前端界面展示</h2><div class="note success simple"><p>先关闭酷狗，因为酷狗会占用“<a href="http://127.0.0.1:8000/%E2%80%9D%E8%BF%99%E4%B8%AA%E7%AB%AF%E5%8F%A3">http://127.0.0.1:8000/”这个端口</a></p></div><p>&emsp;&emsp;</p><p>修改neo4j_models.py中的密码，name和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def connectDB(self):</span><br><span class="line">self.graph &#x3D; Graph(&quot;bolt: &#x2F;&#x2F; localhost:7687&quot;, username&#x3D;&quot;neo4j&quot;, password&#x3D;&quot;admin&quot;)</span><br><span class="line">self.matcher &#x3D; NodeMatcher(self.graph)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口执行如下指令保证数据库服务是开着的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口进入kgcar项目目录下运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>功能界面如下：<br><img src="https://voyager-m.gitee.io/picgo/test/102718.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102719.png"></p><p>&emsp;&emsp;</p><p>对不起，这个例子我举的有点飘了，哈哈哈哈</p><p>特别感谢：张子良老师的知识图谱教程</p><p>整理于2020年10月27日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱初识-知识图谱与语义技术简介</title>
      <link href="posts/ac2a99b3/"/>
      <url>posts/ac2a99b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习知识图谱相关知识和技术，所以会在博客做一个记录，首先对学习过程中所读资料的作者表示衷心的感谢，其次，在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。</p><p>本文主要是对整个知识图谱体系进行一个大体上的认识，明白知识图谱是个什么东西，大致包涵那几块内容，每一块大致用到了哪些技术，而对于其中的技术，后面我会慢慢整理。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102401.png"></p><h2 id="知识图谱技术概览"><a href="#知识图谱技术概览" class="headerlink" title="知识图谱技术概览"></a>知识图谱技术概览</h2><h3 id="知识图谱概念演化"><a href="#知识图谱概念演化" class="headerlink" title="知识图谱概念演化"></a>知识图谱概念演化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/102402.png"></p><p>1960年，语义网络作为知识表示的一种方法被题出。<br>1980s，哲学理念“本体”被引入到人工智能领域被用来刻画知识。<br>1989年，Tim Berners-Lee发明了万维网（Linked Information System）。<br>1998年，从超文本链接到语义链接。<br>2006年，Tim突出强调了语义网络的本质是要建立开放数据之间的链接。<br>2012年，谷歌发布了基于知识图谱的搜索引擎产品。</p><p>从以上历程我们可以看出，知识图谱其实是得益于Web的发展，其中有着KR,NLP,Web,AI等多方面的影子。</p><h3 id="知识图谱的本质"><a href="#知识图谱的本质" class="headerlink" title="知识图谱的本质"></a>知识图谱的本质</h3><p>知识图谱整个体系还是比较大的，目前没有一个标准的定义，其中“Exploiting Linked Data and Knowledge Graphs in Large Organisations”这本书对知识图谱的定义为：</p><p>A knowledge graph consists of a set of interconnected typed entities and their attributes.</p><p>翻译过来就是：知识图谱是由一些相互连接的实体和它们的属性构成的。</p><p>其中最经典的就是三元组：<br><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>其实就一主，一谓，一宾。比如上图的人工智能，之父是，图灵。实际上就是我们所说的“人工智能之父是图灵”</p><p>我们也可以从不同方面来看知识图谱：</p><p><strong>从Web角度</strong> 像建立文本之间的超链接一样，建立数据之间的语义链接，并支持语义搜索。<br><strong>从NLP角度</strong> 怎样从文本中抽取语义和结构化数据。<br><strong>从KR角度</strong>  怎样利用计算机符号来表示和处理知识。<br><strong>从AI角度</strong>  怎样利用知识库来辅助计算机理解人的语言。<br><strong>从DB角度</strong>  用图的方式去存储知识。</p><p>所以啊，其实做好KG要利用好KR，NLP，Web，ML，DB多方面的方法和技术。</p><p>我们再举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102404.png"></p><p>“聪明的Ai”其实是从学习的角度进行感知，识别，判断，依靠深度学习。<br>“有学识的Ai”其实是从推理的角度进行思考，语言，推理，依靠知识图谱。</p><h2 id="知识图谱技术简介"><a href="#知识图谱技术简介" class="headerlink" title="知识图谱技术简介"></a>知识图谱技术简介</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102405.png"></p><p>技术体系其实可以概括为：知识表示，知识抽取，知识问答，知识推理，知识融合，知识众包。<br>途中下面表示的是数据部分的主要来源：KBP,D2R,Linked MEDIA/Visual Genome,OneM2M,WikiData。</p><h3 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h3><p>知识表示是研究怎么样用计算机符号来表示人脑中的知识，以及怎么样通过符号之间的运算来模拟人脑的推理课程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102406.png"></p><p>图上是整个知识图谱的演进过程（知识演进也是一个很有意思的方向，有机会后面整理哦），其实说白了就是一个基于数理逻辑的知识表示到基于向量空间学习分布式知识表的过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102407.png"></p><p>以上这个图是官方给出的语义知识网表示框架，由于本篇文章是知识图谱概览，所以我们大概来看一下这个框架。最底层的URI/IRI是网络连接，上面一层是XML和RDF是资源表示框架，而SPARQL是一种知识查询语言。而蓝色部分（知识推理框架）包含了RDFS和OWL框架。下面我们对其中的几个框架做进一步解释：</p><p><strong>RDF</strong>：资源描述框架（Resource Description Framework）,它是由W3C制定的，是用来描述实体/资源的标准数据模型。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>还是以上面这个图为例，在知识图谱中我们一般用RDF形式化的来表示三元关系（Subject，predicate，object）。</p><p>RDFS在RDF的基础上定义了一些固定的关键词：Class，subClassOf,type,Property,subPropertyOf,Domain,Range以及多了Schema层。如下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102408.png"></p><p><strong>OWL</strong>：网络本体语言（Web Ontology Language）这个本体实际上是从哲学里面来的，OWL在RDF语言上扩充了Schema层，使之支持推理等操作。</p><pre><code>Ontology in Philosophy：Ontology is the philosophical study of the nature of being, becoming, existence or reality, as well asthe basic categories of being and their relations.                                  Tom Gruber，Founder of Siri哲学本体论：本体论是对存在，成为，存在或存在的本质以及存在及其关系的基本类别的哲学研究。                                                韦伯斯特Ontology in Computer Science and Artificial Intelligence：An ontology is a description (like a formal specification of a program) of the concepts andrelationships that can formally exist for an agent or a community of agents.                                Tom Gruber，Founder of Siri计算机科学与人工智能中的本体论：本体是对代理或代理社区可以正式存在的概念和关系的描述（如程序的正式说明）。                                Siri创始人汤姆·格鲁伯Web OntologiesOntologies based on web standards such as RDFS/OWL.OWL is based on Description Logic, avery very long history of research in Artificial Intelligence.基于Web标准的本体(如RDFS/OWL.OWL)是基于描述逻辑(DescriptionLogic)的，人工智能研究历史悠久。</code></pre><p><img src="https://voyager-m.gitee.io/picgo/test/102409.png"></p><p><strong>SPARQL</strong>：SPARQL是RDF的查询语言，它基于RDF数据模型，可以对不同的数据集撰写复杂的连接，由所有主流的图数据库支持。其操作如：<br><img src="https://voyager-m.gitee.io/picgo/test/102410.png"></p><p><strong>JSON-LD</strong>：（JSON for Linking Data） 适用于作为程序之间做数据交换,在网页中嵌入语义数据和Restful Web Service。存储格式如:<br><img src="https://voyager-m.gitee.io/picgo/test/102411.png"></p><p><strong>知识图谱的分布式表示–KG Embedding</strong>：在保留语义的同时，将知识图谱中的实体和关系映射到连续的稠密的低维向量空间。<br><img src="https://voyager-m.gitee.io/picgo/test/102412.png"></p><h3 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h3><p>知识抽取大多是结合NLP和KG进行的。<br><img src="https://voyager-m.gitee.io/picgo/test/102413.png"></p><p>先是从网络获取大量的非结构化的文本数据，经过文本预处理后得到干净的文本数据，然后借助分词，词性标注，语法解析，依存分析等技术对文本进行处理，我们得到词法和句法的分层，接下来我们对文本进行NER命名实体识别和实体链接，最后通过关系抽取和事件抽取最终得到KR用的三元组，多元关系，模态知识等。</p><p><strong>知识抽取的主要方法</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102414.png"></p><h3 id="知识存储"><a href="#知识存储" class="headerlink" title="知识存储"></a>知识存储</h3><p>知识比数据的结构更加复杂，知识存储需要综合考虑图的特点，复炸的知识存储结构，索引和查询（支持推理）的优化等问题。<br>典型的知识存储引擎分为基于关系数据库的存储和基于原生图的存储。<br>在实践过程中，多为混合存储结构，图存储并非必须<br><img src="https://voyager-m.gitee.io/picgo/test/102415.png"></p><h3 id="知识问答"><a href="#知识问答" class="headerlink" title="知识问答"></a>知识问答</h3><p>KBQA（Knowledge-Based Question Answer，基于知识库的问题回答）<br>以直接而准确的方式回答用户自然语言提问的自动问答系统将构成下一代搜索引擎的基本形态。<br><img src="https://voyager-m.gitee.io/picgo/test/102416.png"></p><p>我们来举几个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102417.png"></p><p>传统的搜索引擎，只会将匹配的资源列在页面，我们需要自己去筛选理解其中的信息，以获取自己真正想得到的问题的答案。而嵌入了知识图谱的搜索引擎似乎更“智能”了，它能直接很直观的返回我们想要的真正的问题的答案。是不是很方便呢！</p><p>我们以一个例子来看看KBQA的实现流程:<br><img src="https://voyager-m.gitee.io/picgo/test/102418.png"></p><p>当你问“姚明的老婆多大了？”这个问题的时候，首先会对这个问题进行语义解析得到问题的语义表示，然后再KB中查找答案，最终将答案返回，其中KB知识库的数据数量和质量直接决定了该系统的质量。</p><h3 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h3><p>简单的来说，推理就是指基于已知事实推出来未知的事实的过程。<br>目前大部分搜索引擎都已经有了一定的推理能力。比如：<br><img src="https://voyager-m.gitee.io/picgo/test/102419.png"></p><p><img src="https://voyager-m.gitee.io/picgo/test/102420.png"></p><p><strong>基于描述逻辑的推理：本体推理</strong>：</p><p>描述逻辑：描述逻辑（decription logic）是一种用只是表示的逻辑语言和以其为对象的推理方法，主要用于描述概念分类及其概念之间的关系。描述逻辑是当前语义网发展中本体的理论基础。</p><p>主要方法：</p><p>（1）基于表运算（Tableaux）及改进的方法：FaCT++，Racer，Pellet Hermit等</p><p>（2）基于一阶查询重写的方法（Ontology based data acess，基于本体的数据访问）</p><p>（3）基于产生式规则的算法（如KAON、RDFox等）。</p><p>（4）回答集程序 Answer set programming</p><p><strong>基于统计规则挖掘的推理</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102421.png"></p><p><strong>基于表示学习的推理-Representational Learning</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102422.png"></p><h3 id="知识融合"><a href="#知识融合" class="headerlink" title="知识融合"></a>知识融合</h3><p>知识融合有一些其它叫法: Record Linkage，Entity Resolution，DataLinking，Knowledge Fusion，Entity Alignment.. . . . .<br>都是指在不同数据集中找出同一个实体的描述记录，主要目的是对不同数据源中的实体信息进行整合，形成更加全面的实体信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102423.png"></p><p>我们来用上图这个例子通俗一点来说一说什么叫知识融合，上图中下面一层的头像有7个，但是上面一层的头像只有2个，是因为下面一层的头像都是由上面两个头像戴上眼镜，假发等而来，所以我们只需要抓住上面两个头像进行处理就行了。<br>这就好比说，“洋芋、荷兰薯、地蛋、薯仔、土豆、荷兰薯、番仔薯、马铃薯”都指的是一个东西，知识融合要做的就是将这8个别名融合成一个名称。</p><h3 id="知识众包"><a href="#知识众包" class="headerlink" title="知识众包"></a>知识众包</h3><p>这个概念通俗的讲就是允许网站基于一定的方式，比如RDFa，JASON-LD等方式在网页和邮件等数据中嵌入语义化的数据，让个人和企业定制自己需要的知识图谱信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102424.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102425.png"></p><p>特别感谢：<br>上海交大的王昊奋博士的教程和东南大学漆桂林教授的文章以及其他资源的作者。</p><p>在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。<br>个人qq:1518887260</p><p>整理于2020年10月24日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-neo4j入门</title>
      <link href="posts/3b57b49b/"/>
      <url>posts/3b57b49b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>什么是知识图谱？</strong></p><p><strong>有人的地方就会有江湖</strong></p><p><strong>江湖不是打打杀杀</strong></p><p><strong>而是人情世故</strong></p><p><strong>人情世故就是各种关系嘛</strong></p><p><strong>人情世故通常都是文本数据</strong></p><p><strong>在海量数据中将各种各样的关系抽出来</strong></p><p><strong>那我，我们怎么存储这些关系</strong></p><p><strong>普通的数据库，当然不行了</strong></p><p><strong>因为不够直观嘛</strong></p><p><strong>所以我们就有了神器——neo4j</strong></p><p><strong>neo4j是一种图形化数据库，能让人很直观看出各实体之间的关系。</strong></p><h2 id="1、JDK环境配置"><a href="#1、JDK环境配置" class="headerlink" title="1、JDK环境配置"></a>1、JDK环境配置</h2><p>很多人电脑上本来就有jdk，但是很抱歉，neo4j很矫情，它对JDK版本有要求，所以最好卸载原有的JDk，安装最新版本的JDk。</p><p>JDK安装：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p>直接无脑下载后点下一步就ok了。</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建  </p><p>变量名：JAVA_HOME</p><p>变量值：C:\Program Files\Java\jdk1.8.0_152（以安装路径为主）</p><hr><p>系统变量-&gt;新建</p><p>变量名：CLASSPATH</p><p>变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;  （注意符号，建议直接复制粘贴）</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %JAVA_HOME%\bin 填进去（注意符号，建议直接复制粘贴）<br>变量值：点击新建，将  %JAVA_HOME%\jre\bin 填进去（注意符号，建议直接复制粘贴）</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入java -version</p><p><img src="https://voyager-m.gitee.io/picgo/test/102801.png"></p><p>若出现这个图就表明成功啦！</p><h2 id="2、neo4j环境配置"><a href="#2、neo4j环境配置" class="headerlink" title="2、neo4j环境配置"></a>2、neo4j环境配置</h2><p>Neo4j安装：<a href="https://neo4j.com/download-center/">https://neo4j.com/download-center/</a></p><p>官网下载，然后无脑下一步安装</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建</p><p>变量名：NEO4J_HOME</p><p>变量值： C:\neo4j-community-4.1.3</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %NEO4J_HOME%\bin  填进去</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入neo4j</p><p><img src="https://voyager-m.gitee.io/picgo/test/102802.png"></p><p>若出现这个图就表明成功啦！</p><p>本人已与百度合作，若以上配置过程看不懂或者有问题，可尝试百度搜索“xxx安装配置教程”即可。</p><h2 id="3-启动neo4j看看"><a href="#3-启动neo4j看看" class="headerlink" title="3.启动neo4j看看"></a>3.启动neo4j看看</h2><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现如下界面表示成功启动</p><p><img src="https://voyager-m.gitee.io/picgo/test/102803.png"></p><p>图中红方框就就是访问地址</p><p>打开浏览器输入：<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>第一次登录的<strong>用户名</strong>和<strong>密码</strong>都是neo4j，登录成功后可以修改密码。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102804.png"></p><p>请看上面这张图：点开1位置的小星星，然后点击下面的Movie Graph（这是neo4j自带的演示知识图谱），然后我们会看到3位置自动出现了一行指令，然后点击4位置的小三角板，我们会得到5位置的界面，然后我们可以点击6位置的翻页，下面的每一页都会介绍neo4j的Cypher Query Language语句。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102805.png"></p><p>将页面翻到第2页，点击1位置的任意地方，我们能看到2位置的方框内自动出现了一堆指令，然后点击3位置的小三角，我们可以得到下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102806.png"></p><p>来解释下这个图哈，这个图中有9个person标签，8个movie标签，8个acted_in关系和10个directed关系。比如Tom Hanks演了8个电影。</p><p>至此，演示例子都看完啦，我只演示了第2页的指令，其他页的指令会简单的把Cypher Query Language都做一遍介绍，可自行琢磨，想系统学习Cypher Query Language可以去w3cschool看neo4j教程。</p><h2 id="3、Cypher-Query-Language简单操作"><a href="#3、Cypher-Query-Language简单操作" class="headerlink" title="3、Cypher Query Language简单操作"></a>3、Cypher Query Language简单操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">增加一个节点</span><br><span class="line">create(n:Person&#123;name:&#39;毛同学&#39;,age:5&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102807.png"></p><p>解释一下：n相当于一个别名，Person是我们定义的标签名字，大括号里面是属性，这里我们创建了名字name和年龄age两个属性，值分别为‘毛同学’和5。</p><p>图中点击毛同学这个圆圈，可以看到左下角显示这个实体的id号和属性以及属性值。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带有关系属性</span><br><span class="line">create (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[:是一个&#123;负债:10000&#125;]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102808.png"></p><p>解释一下：这个语句的前面和后面一部分其实就是创建实体的语句，主要是中间的，”：”后面的代表这个关系的名称，大括号里面的表示这个关系的属性。</p><p>图中点击1位置的关系，我们可以看到2位置的关系属性。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个穷人！（负债10000）</font>（这是个悲伤的故事）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删：</span><br><span class="line">create (n:Person &#123;name:&#39;MWY&#39;,age:20&#125;)</span><br><span class="line">match (n:Person&#123;name:&quot;MWY&quot;&#125;) delete n</span><br></pre></td></tr></table></figure><p>解释一下：这两句话是先创建了一个结点又删除了一个结点。其中删除语句中的n代表一个别名，相当于一个返回值，意思是在Person标签中查找name为”MWY”的返回给n，后面”delete n”代表删除n（就是查到的结点）这个结点。（注意：要删除点，必须先删除关系，不然不能删除）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除关系</span><br><span class="line">match (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[f:是一个]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;) delete f</span><br></pre></td></tr></table></figure><p>解释一下：删除关系语句中的前面部分和后面部分应该都能懂了，中间这部分，是把f当成一个返回值，查找到”是一个”这个关系后返回给f，后面的”delete f”代表把这个关系删除了，当然也可以变成”delete p,f,n”，这表示把两个结点和它们的关系都删掉了。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上标签：</span><br><span class="line">match (t:Person) where id(t)&#x3D;0 set t:好人 return t</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102809.png"></p><p>解释一下：首先match是查找的意思，t接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为person的结点增加一个”好人”标签。</p><p>图中点击1位置的关系，我们可以看到2位置的标签变成了两个。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！</font>（挺不好意思的）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;200  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102810.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为”好人”的结点增加一个”颜值”属性，值为200。</p><p>这个图的意思就是说：<font color=#008000>同学是一个人！且是个好人！他的颜值为200</font>（不接受反驳）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">修改属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;500  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102811.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示修改的意思，意思是把id为0的标签为”好人”的结点的”颜值”属性改为500。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！200都已经不能够表示他的颜值，500才能勉强表示</font>（我有点飘）</p><hr><p>如果你想清空数据库那么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速清空数据库：</span><br><span class="line">MATCH (n)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure><p>解释一下：n，表示的是一个别名，后面一句表示清空n，也就是清空数据库。</p><p>这就是我们常说的<font color=#008000>“删库跑路”</font>一句中的删库指令。（温馨提示：慎用）</p><p>若想交流，加qq：1518887260</p><p>整理于2020年10月28日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地项目上传gitee/github</title>
      <link href="posts/c37fef3/"/>
      <url>posts/c37fef3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="在gitee-github上创建一个空的仓库（假如为demo）"><a href="#在gitee-github上创建一个空的仓库（假如为demo）" class="headerlink" title="在gitee/github上创建一个空的仓库（假如为demo）"></a>在gitee/github上创建一个空的仓库（假如为demo）</h3><h3 id="在本地新建一个空文件夹（假如叫gitee）"><a href="#在本地新建一个空文件夹（假如叫gitee）" class="headerlink" title="在本地新建一个空文件夹（假如叫gitee）"></a>在本地新建一个空文件夹（假如叫gitee）</h3><h3 id="在demo文件夹下执行指令"><a href="#在demo文件夹下执行指令" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 你的https仓库地址</span><br></pre></td></tr></table></figure><h3 id="在gitee文件夹下面执行指令"><a href="#在gitee文件夹下面执行指令" class="headerlink" title="在gitee文件夹下面执行指令"></a>在gitee文件夹下面执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h3 id="将需要上传的项目复制到仓库demo文件夹下"><a href="#将需要上传的项目复制到仓库demo文件夹下" class="headerlink" title="将需要上传的项目复制到仓库demo文件夹下"></a>将需要上传的项目复制到仓库demo文件夹下</h3><h3 id="在demo文件夹下执行指令-1"><a href="#在demo文件夹下执行指令-1" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commt -m &#x27;这里随便写&#x27;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure><h3 id="这里的add-中的-的意思是本文件夹下面的全部文件"><a href="#这里的add-中的-的意思是本文件夹下面的全部文件" class="headerlink" title="这里的add .中的.的意思是本文件夹下面的全部文件"></a>这里的add .中的.的意思是本文件夹下面的全部文件</h3>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo从一台电脑转移至另一台电脑</title>
      <link href="posts/a17e1e97/"/>
      <url>posts/a17e1e97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"><a href="#前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！" class="headerlink" title="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"></a>前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！</h3><h3 id="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："><a href="#既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：" class="headerlink" title="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："></a>既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：</h3><h2 id="第一步：将旧电脑的文件拷贝在新电脑上"><a href="#第一步：将旧电脑的文件拷贝在新电脑上" class="headerlink" title="第一步：将旧电脑的文件拷贝在新电脑上"></a>第一步：将旧电脑的文件拷贝在新电脑上</h2><h3 id="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"><a href="#比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统" class="headerlink" title="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"></a>比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EyqtU.png" alt="创建文件夹"></p><h3 id="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"><a href="#将原来电脑上的blog和globle拷贝到Hexo文件夹下面" class="headerlink" title="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"></a>将原来电脑上的blog和globle拷贝到Hexo文件夹下面</h3><h3 id="建立Git和node两个空文件夹用来安装Gitbash和Node"><a href="#建立Git和node两个空文件夹用来安装Gitbash和Node" class="headerlink" title="建立Git和node两个空文件夹用来安装Gitbash和Node"></a>建立Git和node两个空文件夹用来安装Gitbash和Node</h3><h2 id="第二步：在新电脑上安装Git-Bash和Node"><a href="#第二步：在新电脑上安装Git-Bash和Node" class="headerlink" title="第二步：在新电脑上安装Git Bash和Node"></a>第二步：在新电脑上安装Git Bash和Node</h2><h3 id="Git-Bash-的下载地址"><a href="#Git-Bash-的下载地址" class="headerlink" title="Git Bash 的下载地址"></a><a href="https://www.git-scm.com/download/win">Git Bash 的下载地址</a></h3><h3 id="Node-的下载地址"><a href="#Node-的下载地址" class="headerlink" title="Node 的下载地址"></a><a href="https://nodejs.org/en/">Node 的下载地址</a></h3><h3 id="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"><a href="#这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹" class="headerlink" title="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"></a>这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹</h3><h3 id="然后全程无脑下一步安装就行了"><a href="#然后全程无脑下一步安装就行了" class="headerlink" title="然后全程无脑下一步安装就行了"></a>然后全程无脑下一步安装就行了</h3><div class="note danger simple"><p>这里特别要注意，Node安装的版本要和你原本电脑上安装的Node版本要一样，不然就会出问题的</p></div><h3 id="安装完成后我们打开按win-R-输入cmd打开控制台"><a href="#安装完成后我们打开按win-R-输入cmd打开控制台" class="headerlink" title="安装完成后我们打开按win+R 输入cmd打开控制台"></a>安装完成后我们打开按win+R 输入cmd打开控制台</h3><p><img src="https://s1.ax1x.com/2020/09/28/0E0JjP.png" alt="打开cmd"></p><h3 id="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"><a href="#输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）" class="headerlink" title="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"></a>输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EsOsI.png" alt="查看gitbash和node版本"></p><h2 id="第三步：环境配置"><a href="#第三步：环境配置" class="headerlink" title="第三步：环境配置"></a>第三步：环境配置</h2><h3 id="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）"><a href="#首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）" class="headerlink" title="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）"></a>首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）</h3><h3 id="启动cmd命令输入下下面的指令："><a href="#启动cmd命令输入下下面的指令：" class="headerlink" title="启动cmd命令输入下下面的指令："></a>启动cmd命令输入下下面的指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;C:\Hexo\globle&quot;</span><br><span class="line">npm config set cache &quot;C:\Hexo\globle&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开系统环境变量配置："><a href="#然后打开系统环境变量配置：" class="headerlink" title="然后打开系统环境变量配置："></a>然后打开系统环境变量配置：</h3><h3 id="此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量"><a href="#此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量" class="headerlink" title="此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量"></a>此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量</h3><h3 id="进入如下界面："><a href="#进入如下界面：" class="headerlink" title="进入如下界面："></a>进入如下界面：</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EgB6J.png" alt="环境变量"></p><h3 id="双击path进入如下界面"><a href="#双击path进入如下界面" class="headerlink" title="双击path进入如下界面"></a>双击path进入如下界面</h3><p><img src="https://s1.ax1x.com/2020/09/28/0Eg0l4.png" alt="新建环境变量"></p><h3 id="点击新建然后填写globle的地址，点击确定，完成环境配置"><a href="#点击新建然后填写globle的地址，点击确定，完成环境配置" class="headerlink" title="点击新建然后填写globle的地址，点击确定，完成环境配置"></a>点击新建然后填写globle的地址，点击确定，完成环境配置</h3><h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><h3 id="打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令："><a href="#打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令：" class="headerlink" title="打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令："></a>打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure><h3 id="用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功"><a href="#用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功" class="headerlink" title="用浏览器打开http://localhost:4000 得到如下自己的博客首页就说明本地能测试成功"></a>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a> 得到如下自己的博客首页就说明本地能测试成功</h3><p><img src="https://s1.ax1x.com/2020/09/28/0ERLQg.png" alt="页面"></p><h3 id="执行以下指令（自己的邮箱）"><a href="#执行以下指令（自己的邮箱）" class="headerlink" title="执行以下指令（自己的邮箱）"></a>执行以下指令（自己的邮箱）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"><a href="#然后打开这个文件复制里面内容添加到gitee和github上的ssh上去" class="headerlink" title="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"></a>然后打开这个文件复制里面内容添加到gitee和github上的ssh上去</h3><p><img src="https://voyager-m.gitee.io/picgo/test/hexo1.png"></p><h3 id="其中gitee和github的用户名和密码放在下图中的位置"><a href="#其中gitee和github的用户名和密码放在下图中的位置" class="headerlink" title="其中gitee和github的用户名和密码放在下图中的位置"></a>其中gitee和github的用户名和密码放在下图中的位置</h3><p><img src="https://s1.ax1x.com/2020/09/28/0VpTkq.png"></p><h3 id="在cmd中执行如下指令"><a href="#在cmd中执行如下指令" class="headerlink" title="在cmd中执行如下指令"></a>在cmd中执行如下指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure><h3 id="在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。"><a href="#在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。" class="headerlink" title="在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。"></a>在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。</h3><h4 id="特别感谢："><a href="#特别感谢：" class="headerlink" title="特别感谢："></a>特别感谢：</h4><p><a href="https://space.bilibili.com/393128277/video">博客搭建</a><br><a href="https://dreamer-liuyang.github.io/posts/4c70a442/">搭建文章版</a><br><a href="https://dreamer-liuyang.github.io/posts/d579f5f8/">美化文章版</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛维杨的第一篇文章</title>
      <link href="posts/fbf6b9c0/"/>
      <url>posts/fbf6b9c0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="你好呀！在下毛同学"><a href="#你好呀！在下毛同学" class="headerlink" title="你好呀！在下毛同学"></a>你好呀！在下毛同学</h1><h1 id="家穷人丑，一米四九"><a href="#家穷人丑，一米四九" class="headerlink" title="家穷人丑，一米四九"></a>家穷人丑，一米四九</h1><h1 id="小学文化，农村户口"><a href="#小学文化，农村户口" class="headerlink" title="小学文化，农村户口"></a>小学文化，农村户口</h1><h1 id="破屋三间，薄田一亩"><a href="#破屋三间，薄田一亩" class="headerlink" title="破屋三间，薄田一亩"></a>破屋三间，薄田一亩</h1><h1 id="冷锅热灶，钱财没有"><a href="#冷锅热灶，钱财没有" class="headerlink" title="冷锅热灶，钱财没有"></a>冷锅热灶，钱财没有</h1><h1 id="一年四季，苦学编程"><a href="#一年四季，苦学编程" class="headerlink" title="一年四季，苦学编程"></a>一年四季，苦学编程</h1><h1 id="今创博客，写下此篇"><a href="#今创博客，写下此篇" class="headerlink" title="今创博客，写下此篇"></a>今创博客，写下此篇</h1><h1 id="学习路上，伴你身边"><a href="#学习路上，伴你身边" class="headerlink" title="学习路上，伴你身边"></a>学习路上，伴你身边</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;既来不留良言三句？&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note success simple"><p>文献提示：评论需要填写昵称和邮箱哦！</p></div>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
