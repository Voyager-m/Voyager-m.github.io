<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode-排序-选择排序</title>
      <link href="posts/35af54d9/"/>
      <url>posts/35af54d9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用通俗的语言来讲，选择排序，就是将数列中最大（小）的数找出来，放到合适的位置，然后在剩下的集合里面继续找最大（小）的数放在合适的位置，如此往复，直到整个数列变为有序位置。与冒泡排序不一样的是，它不是比较相邻的两个数，而是比较某个数与数列中剩下所有数的大小。</p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>原始数列为：</p><pre><code>7 3 5 1 9 4</code></pre><p>第一轮排序首先以第一个数为基数，与剩下的所有数进行比较，找到整个数列中最小的数，然后交换最小数与第一个数的位置。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[j] &lt;=iLIST[minIndex]:</span><br><span class="line">            minIdex = j</span><br></pre></td></tr></table></figure><p>以上排序过程会将第i+1（i从0开始）大的数放在数列下标为i的位置，那么第一次排序的结果为：</p><pre><code>1 3 5 7 9 4</code></pre><h2 id="2-第二轮排序："><a href="#2-第二轮排序：" class="headerlink" title="2.第二轮排序："></a>2.第二轮排序：</h2><pre><code>1 3 5 7 9 4</code></pre><h2 id="3-第三轮排序："><a href="#3-第三轮排序：" class="headerlink" title="3.第三轮排序："></a>3.第三轮排序：</h2><pre><code>1 3 4 7 9 5</code></pre><h2 id="4-第四轮排序："><a href="#4-第四轮排序：" class="headerlink" title="4.第四轮排序："></a>4.第四轮排序：</h2><pre><code>1 3 4 5 9 7</code></pre><h2 id="5-第五轮排序："><a href="#5-第五轮排序：" class="headerlink" title="5.第五轮排序："></a>5.第五轮排序：</h2><pre><code>1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList  <span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[i] != min(iList[i:]):  <span class="comment"># 判断当前元素是不是从当前元素开始的剩下所有元素中最小的</span></span><br><span class="line">            minIndex = iList.index(min(iList[i:]))  <span class="comment"># 将从当前元素开始的剩下所有元素中最小的元素索引复制给minIndex</span></span><br><span class="line">            iList[i], iList[minIndex] = iList[minIndex], iList[i]<span class="comment">#交换当前元素和最小元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(selectionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;selectionSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import selectionSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用此算法排序100次所花时间</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月14</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-1-知名编程语言或系统的发展简史</title>
      <link href="posts/a7360fd9/"/>
      <url>posts/a7360fd9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="知名编程语言或系统的发展简史"><a href="#知名编程语言或系统的发展简史" class="headerlink" title="知名编程语言或系统的发展简史"></a>知名编程语言或系统的发展简史</h1><h2 id="一、B语言"><a href="#一、B语言" class="headerlink" title="一、B语言"></a>一、B语言</h2><p>B语言之父：Ken Thompson（肯.汤普森）。B语言是贝尔实验室开发的一种通用的程序设计语言，它是于1969年前后Ken Thompson（肯.汤普森）在Dennis Ritchie丹尼斯.里奇（Dennis Ritchie）的支持下设计出来。该语言得名于汤姆森的妻子Bonnie，它是一门开发于60年代中期的语言，现在使用者已经很少了。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/KenThompson.jpg" alt="Ken Thompson"></p><h2 id="二、C语言"><a href="#二、C语言" class="headerlink" title="二、C语言"></a>二、C语言</h2><p>C语言之父：Dennis Ritchie（丹尼斯·里奇）。美国著名计算机专家、C语言发明人、UNIX之父。在1969-1973年期间发明了C语言和Unix操作系统。</p><p>到了70年代，诞生了一门非常重要的语言，这就是今天的大名鼎鼎的C语言。而C语言之父是美国著名的计算机专家。丹尼斯.利奇。<br>在开发C语言的时候其实是以B语言为基础。之所以发明C语言，实际上是因为这两个人，刚刚的B语言之父肯.汤普森和丹尼斯.里奇，一块写了一个操作系统，就是Unix系统。在写Unix系统的过程中，需要一种便利的语言，而B语言又达不到这个要求，所以丹尼斯.里奇就在B语言上进行改造，发明了C语言。目前 C语言是世界上最常用的程序语言之一。自从被C语言取代之后，B语言几乎已遭弃置。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/dannis.jpg" alt="dannis"></p><h2 id="三、Unix系统"><a href="#三、Unix系统" class="headerlink" title="三、Unix系统"></a>三、Unix系统</h2><p>Unix之父：Dennis Ritchie（丹尼斯·里奇）及Ken Thompson（肯.汤普森）</p><p>提到C语言就不得不说一下Unix系统。而Unix之父，自然就是这两个人，左侧这个是B语言之父肯汤姆森。右侧这个是C语言之父丹尼斯.里奇。有意思的是，肯.汤普森当年开发 Unix的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，Unix 诞生了。英文中的前缀 Uni 是小的意思，小而且巧。这是 Unix 的设计初衷，这个理念也一直影响至今。<br>因为他们俩在1973年左右的时候发明了Unix操作系统，也因此获得了1983年的图灵大奖。这个奖项就相当于IT行业的诺贝尔奖。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/WX20190322-173439.png" alt="WX20190322-173439"></p><h2 id="四、C-语言"><a href="#四、C-语言" class="headerlink" title="四、C++语言"></a>四、C++语言</h2><p>C++之父：Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）。1982年，美国贝尔实验室的Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言。为了表达该语言与c语言的渊源关系，它被命名为C++。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/BjarneStroustrup.jpg" alt="Bjarne Stroustrup"></p><h2 id="五、Python语言"><a href="#五、Python语言" class="headerlink" title="五、Python语言"></a>五、Python语言</h2><p>Python之父：Guido van Rossum（吉多.范.罗苏姆）。1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。1994年发布1.0版本。1995年9月发布了Python3.5版。</p><p>python语言的理念就是：人生苦短，我用python。吉多推崇的是简洁，大方，美观，精致。吉多一直认为python是一门很优秀的语言，实际上python也确实是可以做各个行业，无论是web开发，还是服务器端维护，还有爬虫等等，但是在每个方向上都没有做到最精，所以在某些地方没有得到很大的体现。但是吉多一直认为酒香不怕巷子深，所以也没有大力的宣传。但是近几年随着人工智能也被大众所熟知。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/GuidovanRossum.png" alt="Guido van Rossum"></p><h2 id="六、Java语言"><a href="#六、Java语言" class="headerlink" title="六、Java语言"></a>六、Java语言</h2><p>Java之父是James Gosling（詹姆斯.高斯林）。1991年开发Oak，1994年更名为Java。1995年5月正式发布。</p><p>实际上python比java的产生还要更早一点。java的出现，正是互联网大力兴起的时候，而java因为语言的特性，在互联网上有很大的优势，发布最初就异常火爆，掩盖住了python的势头。java最初的模型是在1991年的时候开发出，他的创始人詹姆斯高斯林。那个时候还叫做Oak橡树，后来詹姆斯希望使用java语言可以像喝咖啡一样轻松，愉悦。改名为java。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/JamesGosling.jpg" alt="James Gosling"></p><h2 id="七、JavaScript语言"><a href="#七、JavaScript语言" class="headerlink" title="七、JavaScript语言"></a>七、JavaScript语言</h2><p>Javascript之父是Brendan Eich（布兰登.艾奇)。JavaScript，是一门运行在浏览器端的脚本语言。这门语言是由网景公司在1995年发布的。当时网景公司主要是做浏览器方面，他们想把java语言应用在浏览器端，能够实现一些比如用户登录并验证的工作。招聘了一个新员工，叫做布兰登.艾奇，布兰登对java没有兴趣，为了应付公司的任务，只用了10天时间就设计出了JavaScript这门语言。但是JavaScript发展至今，随着前端开发异常的火爆，它已经是浏览器端的龙头语言了。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/BrendanEich.jpg" alt="Brendan Eich"></p><p>8、Golang：Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默）</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/aa.jpg" alt="aa"></p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-2-go语言的前世今生</title>
      <link href="posts/13ea5c5d/"/>
      <url>posts/13ea5c5d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言的前世今生"><a href="#Go语言的前世今生" class="headerlink" title="Go语言的前世今生"></a>Go语言的前世今生</h1><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/go_logo.jpg" alt="go_logo"></p><h2 id="一、-为什么需要一个新的语言"><a href="#一、-为什么需要一个新的语言" class="headerlink" title="一、 为什么需要一个新的语言"></a>一、 为什么需要一个新的语言</h2><p>最近十年来，C/C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了。</p><blockquote><p>传统的语言比如c++，大家花费太多时间来学习如何使用这门语言，而不是如何更好的表达写作者的思想，同时编译花费的时间实在太长，对于编写-编译-运行这个链条来说周期太长。动态语言如Python，由于没有强类型的约束，很多问题需要在运行时发现，这种低级错误更应该交给编译器来发现。</p></blockquote><ul><li><p>人力成本越来越高</p></li><li><p>机器越来越便宜</p></li><li><p>机器的性能越来越厉害</p></li><li><p>在开发效率和运行速度上达到平衡</p></li></ul><p>go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。</p><blockquote><p>执行效率 execution speed：  C/C++    &gt;  Java   &gt;  PHP<br>开发效率 developing efficiency：  PHP   &gt;  Java  &gt;  C/C++</p></blockquote><h2 id="二、-谷歌工程师的20-时间"><a href="#二、-谷歌工程师的20-时间" class="headerlink" title="二、 谷歌工程师的20%时间"></a>二、 谷歌工程师的20%时间</h2><p>谷歌的“20%时间”工作方式，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务Google Now、谷歌新闻Google News、谷歌地图Google Map上的交通信息等，全都是20%时间的产物。</p><p>Go语言最开始也是20%时间的产物。</p><h2 id="三、-创始人"><a href="#三、-创始人" class="headerlink" title="三、 创始人"></a>三、 创始人</h2><p>Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默） 。</p><ul><li><p>Rob Pike：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。他与Thompson共事多年，并共创出广泛使用的UTF-8 字元编码。</p></li><li><p>Ken Thompson：主要是B语言、C语言的作者、Unix之父。1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言。</p></li><li><p>Robert Griesemer：在开发Go之前是Google V8、Chubby和HotSpot JVM的主要贡献者。</p></li></ul><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/aa.jpg" alt="aa"></p><blockquote><p>此外还有Plan 9开发者Russ Cox、和曾改善目前广泛使用之开原码编译器GCC的Ian Taylor。</p></blockquote><h2 id="四、-Go的缔造与发展"><a href="#四、-Go的缔造与发展" class="headerlink" title="四、 Go的缔造与发展"></a>四、 Go的缔造与发展</h2><h3 id="4-1-Go的命名"><a href="#4-1-Go的命名" class="headerlink" title="4.1 Go的命名"></a>4.1 Go的命名</h3><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/mail1.jpg" alt="mail1"></p><p>这是一封由 Rob Pike 在 2007 年 9 月 25 号，星期二，下午 3：12 回复给 Robert Griesemer、Ken Thompson 的有关编程语言讨论主题的邮件，邮件正文大意为：在开车回家的路上我得到了些灵感。1.给这门编程语言取名为“go”，它很简短，易书写。工具类可以命名为：goc、 gol、goa。交互式的调试工具也可以直接命名为“go”。语言文件后缀名为 .go 等等</p><p>这就是 Go 语言名字的来源，自此之后 Robert、Rob 和 Ken 三个人开始在 Google 内部进行了研发，一直到了 2009 年，Go 正式开源了，Go 项目团队将 2009 年 11 月 10 日，即该语言正式对外开源的日字作为其官方生日。源代码最初托管在 <a href="http://link.zhihu.com/?target=http://code.google.com">http://code.google.com</a> 上，之后几年才逐步的迁移到 GitHub 上。</p><h3 id="4-2-Go的发展过程中的记事"><a href="#4-2-Go的发展过程中的记事" class="headerlink" title="4.2 Go的发展过程中的记事"></a>4.2 Go的发展过程中的记事</h3><p><strong>第一个事情是在开发设计 Go 语言过程中的第一个重大惊喜是收到了以下这封邮件：</strong></p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/mail2.jpg" alt="mail2"></p><p>这是一封由 Ian Lance Taylor 在 2008 年 6月 7 日（星期六）的晚上 7：06 写给 Robert Griesemer、Rob Pike、 Ken Thompson 的关于 Go gcc 编译器前端的邮件。邮件正文大意如下：我的同事向我推荐了这个网站 http://…/go_lang.html 。这似乎是一门很有趣的编程语言。我为它写了一个 gcc 编译器前端。虽然这个工具仍缺少很多的功能，但它确实可以编译网站上展示的那个素数筛选程序了。</p><p>Ian Lance Taylor 的加入以及第二个编译器 (gcc go) 的实现 在带来震惊的同时，也伴随着喜悦。这对 Go 项目来说不仅仅是鼓励，更是一种对可行性的证明。语言的第二次实现对制定语言规范和确定标准库的过程至关重要，同时也有助于保证其高可移植性，这也是 Go 语言承诺的一部分。自此之后 Ian Lance Taylor 成为了设计和实现 Go 语言及其工具的核心人物。</p><p><strong>第二件事情是 Russ Cox 在2008年带着他的语言设计天赋和编程技巧加入了刚成立不久的 Go 团队。</strong>Russ 发现 Go 方法的通用性意味着函数也能拥有自己的方法，这直接促成了 <strong>http.HandlerFunc</strong> 的实现，这是一个让 Go 一下子变得无限可能的特性。Russ 还提出了更多的泛化性的想法，比如 io.Reader 和 io.Writer 接口，奠定了所有 I/O 库的整体结构。</p><p><strong>第三件事情是聘请了安全专家 Adam Langley 帮助 Go 走向 Google 外面的世界。</strong>Adam 为 Go 团队做了许多不为外人知晓的工作，包括创建最初的 <strong><a href="http://golang.org/">http://golang.org</a></strong> 网站以及 <strong>build dashboard</strong>。不过他最大的贡献当属创建了 cryptographic 库。起先，在我们中的部分人看来，这个库无论在规模还是复杂度上都不成气候。但是就是这个库在后期成为了很多重要的网络和安全软件的基础，并且成为了 Go 语言开发历史的关键组成部分。许多网络基础设施公司，比如 <strong>Cloudflare</strong>，均重度依赖 Adam 在 Go 项目上的工作，互联网也因它变得更好。我记得当初 beego 设计的时候，session 模块设计的时候也得到了 Adam 的很多建议，因此，就 Go 而言，我们由衷地感谢 Adam。</p><p><strong>第四个事情就是一家叫做 Docker 的公司。</strong>就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/1641730da1fe6861.jpg" alt="1641730da1fe6861"></p><p>除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目，如etcd/consul/flannel，七牛云存储等等<br>均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。</p><p>除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p><h2 id="五、Go语言logo和版本"><a href="#五、Go语言logo和版本" class="headerlink" title="五、Go语言logo和版本"></a>五、Go语言logo和版本</h2><h2 id="1、-Go的logo"><a href="#1、-Go的logo" class="headerlink" title="1、 Go的logo"></a>1、 Go的logo</h2><h3 id="1-1-Go语言的logo"><a href="#1-1-Go语言的logo" class="headerlink" title="1.1 Go语言的logo"></a>1.1 Go语言的logo</h3><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/go_logo_meitu_1.jpg" alt="go_logo_meitu_1"></p><p>Go语言的logo就是很简洁的GO两个字母。</p><h3 id="1-2-Go的吉祥物"><a href="#1-2-Go的吉祥物" class="headerlink" title="1.2 Go的吉祥物"></a>1.2 Go的吉祥物</h3><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/go_logo2.jpeg" alt="go_logo2"></p><p>Go之所以叫Go，是想表达这门语言的运行速度、开发速度、学习速度（develop）都像gopher一样快。</p><p>gopher是一种生活在加拿大的小动物，go的吉祥物就是这个小动物， 它的中文名叫做囊地鼠，他们最大的特点就是挖洞速度特别快，当然可能不止是挖洞啦。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/tuboshu.jpeg" alt="tuboshu"></p><h2 id="2、Go的官网"><a href="#2、Go的官网" class="headerlink" title="2、Go的官网"></a>2、<a href="https://golang.google.cn/">Go的官网</a></h2><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/goguanwang.png" alt="goguanwang"></p><h2 id="3、-Go语言主要发展过程"><a href="#3、-Go语言主要发展过程" class="headerlink" title="3、 Go语言主要发展过程"></a>3、 Go语言主要发展过程</h2><ul><li><p>2007年9月，雏形设计 ，Rob Pike（罗伯.派克） 正式命名为Go；</p></li><li><p>2008年5月，Google全力支持该项目；</p></li><li><p>2009年11月10日，首次公开发布，Go将代码全部开源，它获得了当年的年度语言；</p></li><li><p>2011年3月16日，Go语言的第一个稳定(stable)版本r56发布。</p></li><li><p>2012年3月28日，Go语言的第一个正式版本Go1发布。</p></li><li><p>2013年4月04日，Go语言的第一个Go 1.1beta1测试版发布。</p></li><li><p>2013年4月08日，Go语言的第二个Go 1.1beta2测试版发布。</p></li><li><p>2013年5月02日，Go语言Go 1.1RC1版发布。</p></li><li><p>2013年5月07日，Go语言Go 1.1RC2版发布。</p></li><li><p>2013年5月09日，Go语言Go 1.1RC3版发布。</p></li><li><p>2013年5月13日，Go语言Go 1.1正式版发布。</p></li><li><p>2013年9月20日，Go语言Go 1.2RC1版发布。</p></li><li><p>2013年12月1日，Go语言Go 1.2正式版发布。</p></li><li><p>2014年6月18日，Go语言Go 1.3版发布。</p></li><li><p>2014年12月10日，Go语言Go 1.4版发布。</p></li><li><p>2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”。</p></li><li><p>2016年2月17日，Go语言Go 1.6版发布。</p></li><li><p>2016年8月15日，Go语言Go 1.7版发布。</p></li><li><p>2017年2月17日，Go语言Go 1.8版发布。</p></li><li><p>2017年8月24日，Go语言Go 1.9版发布。</p></li><li><p>2018年2月16日，Go语言Go 1.10版发布。</p></li><li><p>2018年8月24日，Go语言Go 1.11版发布。</p></li><li><p>2019年2月25日，GO语言Go1.12版发布。</p></li></ul><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。</p><p>其实可以看到，Go语言的历史不算很短。</p><p>2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。</p><p>2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。</p><p>直到今年的2月25日，Go语言发布最新的版本是Go 1.12。</p><p>在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。</p><blockquote><p>Go稳定版发布时，Go Team承诺后续的版本都会兼容之前的版本。这对于开发者来说非常重要，Go后续的版本也一直在提升内功，从而可以让用户无缝的升级Go版本。</p></blockquote><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/image.png" alt="image"></p><h2 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h2><p>Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。<br>Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C / C++代码的速度，而且更加安全、支持并行进程。作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。<br>很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。<br>如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。</p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-3-go语言的核心特性</title>
      <link href="posts/fc72cfdc/"/>
      <url>posts/fc72cfdc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言的核心特性"><a href="#Go语言的核心特性" class="headerlink" title="Go语言的核心特性"></a>Go语言的核心特性</h1><p>Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。</p><p>Go 编程语言是一个开源项目，它使程序员更具生产力。Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。(摘取自官网)</p><h2 id="一、思想"><a href="#一、思想" class="headerlink" title="一、思想"></a>一、思想</h2><p>Less can be more</p><p>大道至简,小而蕴真</p><p>让事情变得复杂很容易，让事情变得简单才难</p><p>深刻的工程文化</p><h2 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h2><p>Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。</p><h3 id="2-1-并发编程"><a href="#2-1-并发编程" class="headerlink" title="2.1 并发编程"></a>2.1 并发编程</h3><p>Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。</p><p><img src="http://7xtcwd.com1.z0.glb.clouddn.com/bingfa1.jpg" alt="bingfa1"></p><p>不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。</p><p>由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，golang的并发编程简单比并发性能更具卖点。</p><p>在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，而golang中实现协程间通讯有两种：1）共享内存型，即使用全局变量+mutex锁来实现数据共享；2）消息传递型，即使用一种独有的channel机制进行异步通讯。</p><p>对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。</p><p><strong>高并发是Golang语言最大的亮点</strong></p><h3 id="2-2-内存回收-GC"><a href="#2-2-内存回收-GC" class="headerlink" title="2.2 内存回收(GC)"></a>2.2 内存回收(GC)</h3><p>从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。 </p><p>GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。</p><p>GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象，而slice或数组是一个对象，因此slice或数组有利于GC。</p><p>GC性能可能随着版本不断更新会不断优化，这块没仔细调研，团队中有HotSpot开发者，应该会借鉴jvm gc的设计思想，比如分代回收、safepoint等。</p><ul><li>内存自动回收，再也不需要开发人员管理内存</li><li>开发人员专注业务实现，降低了心智负担</li><li>只需要new分配内存，不需要释放</li></ul><h3 id="2-3-内存分配"><a href="#2-3-内存分配" class="headerlink" title="2.3 内存分配"></a>2.3 内存分配</h3><p>初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。空闲内存会按照一定策略合并，以减少碎片。</p><h3 id="2-4-编译"><a href="#2-4-编译" class="headerlink" title="2.4 编译"></a>2.4 编译</h3><p>编译涉及到两个问题：编译速度和依赖管理</p><p>目前Golang具有两种编译器，一种是建立在GCC基础上的Gccgo，另外一种是分别针对64位x64和32位x86计算机的一套编译器(6g和8g)。</p><p>依赖管理方面，由于golang绝大多数第三方开源库都在github上，在代码的import中加上对应的github路径就可以使用了，库会默认下载到工程的pkg目录下。</p><p>另外，编译时会默认检查代码中所有实体的使用情况，凡是没使用到的package或变量，都会编译不通过。这是golang挺严谨的一面。</p><h3 id="2-5-网络编程"><a href="#2-5-网络编程" class="headerlink" title="2.5 网络编程"></a>2.5 网络编程</h3><p>由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、rpc用client.Call(‘class_name.method_name’, args, &amp;reply)，等等。</p><blockquote><p>高性能HTTP Server</p></blockquote><h3 id="2-6-函数多返回值"><a href="#2-6-函数多返回值" class="headerlink" title="2.6 函数多返回值"></a>2.6 函数多返回值</h3><p>在C，C++中，包括其他的一些高级语言是不支持多个函数返回值的。但是这项功能又确实是需要的，所以在C语言中一般通过将返回值定义成一个结构体，或者通过函数的参数引用的形式进行返回。而在Go语言中，作为一种新型的语言，目标定位为强大的语言当然不能放弃对这一需求的满足，所以支持函数多返回值是必须的。</p><p>函数定义时可以在入参后面再加(a,b,c)，表示将有3个返回值a、b、c。这个特性在很多语言都有，比如python。</p><p>这个语法糖特性是有现实意义的，比如我们经常会要求接口返回一个三元组（errno,errmsg,data），在大多数只允许一个返回值的语言中，我们只能将三元组放入一个map或数组中返回，接收方还要写代码来检查返回值中包含了三元组，如果允许多返回值，则直接在函数定义层面上就做了强制，使代码更简洁安全。</p><h3 id="2-7-语言交互性"><a href="#2-7-语言交互性" class="headerlink" title="2.7 语言交互性"></a>2.7 语言交互性</h3><p>语言交互性指的是本语言是否能和其他语言交互，比如可以调用其他语言编译的库。</p><p>在Go语言中直接重用了大部份的C模块，这里称为Cgo.Cgo允许开发者混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。</p><p> golang可以和C程序交互，但不能和C++交互。可以有两种替代方案：1）先将c++编译成动态库，再由go调用一段c代码，c代码通过dlfcn库动态调用动态库（记得export LD_LIBRARY_PATH）；2）使用swig(没玩过)</p><h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p>golang不支持try…catch这样的结构化的异常解决方式，因为觉得会增加代码量，且会被滥用，不管多小的异常都抛出。golang提倡的异常处理方式是：</p><ul><li>普通异常：被调用方返回error对象，调用方判断error对象。</li><li>严重异常：指的是中断性panic（比如除0），使用defer…recover…panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try…catch写得到处都是的情况。当然，用户也可以使用panic(‘xxxx’)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。</li></ul><h3 id="2-9-其他一些有趣的特性"><a href="#2-9-其他一些有趣的特性" class="headerlink" title="2.9 其他一些有趣的特性"></a>2.9 其他一些有趣的特性</h3><ul><li><p>类型推导：类型定义：支持<code>var abc = 10</code>这样的语法，让golang看上去有点像动态类型语言，但golang实际上时强类型的，前面的定义会被自动推导出是int类型。</p><blockquote><p>作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。</p><p>简单来说，Go是一门写起来像动态语言，有着动态语言开发效率的静态语言。</p></blockquote></li><li><p>一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显式去继承。</p><blockquote><p>Go编程规范推荐每个Interface只提供一到两个的方法。这样使得每个接口的目的非常清晰。另外Go的隐式推导也使得我们组织程序架构的时候更加灵活。在写JAVA／C++程序的时候，我们一开始就需要把父类／子类／接口设计好，因为一旦后面有变更，修改起来会非常痛苦。而Go不一样，当你在实现的过程中发现某些方法可以抽象成接口的时候，你直接定义好这个接口就OK了，其他代码不需要做任何修改，编译器的自动推导会帮你做好一切。</p></blockquote></li><li><p>不能循环引用：即如果a.go中import了b，则b.go要是import a会报import cycle not allowed。好处是可以避免一些潜在的编程危险，比如a中的func1()调用了b中的func2()，如果func2()也能调用func1()，将会导致无限循环调用下去。</p></li><li><p>defer机制：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。</p><p>可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。</p></li><li><p>“包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。</p></li><li><p>编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。</p></li><li><p>交叉编译：比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！</p></li></ul><h2 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h2><p>此处我们说个小段子：</p><p>很久以前，有一个IT公司，这公司有个传统，允许员工拥有20%自由时间来开发实验性项目。在2007的某一天，公司的几个大牛，正在用c++开发一些比较繁琐但是核心的工作，主要包括庞大的分布式集群，大牛觉得很闹心，后来c++委员会来他们公司演讲，说c++将要添加大概35种新特性。这几个大牛的其中一个人，名为：Rob Pike，听后心中一万个xxx飘过，“c++特性还不够多吗？简化c++应该更有成就感吧”。于是乎，Rob Pike和其他几个大牛讨论了一下，怎么解决这个问题，过了一会，Rob Pike说要不我们自己搞个语言吧，名字叫“go”，非常简短，容易拼写。其他几位大牛就说好啊，然后他们找了块白板，在上面写下希望能有哪些功能。接下来的时间里，大牛们开心的讨论设计这门语言的特性，经过漫长的岁月，他们决定，以c语言为原型，以及借鉴其他语言的一些特性，来解放程序员，解放自己，然后在2009年，go语言诞生。</p><p>以下就是这些大牛所罗列出的Go要有的功能：</p><ul><li>规范的语法（不需要符号表来解析）</li><li>垃圾回收（独有）</li><li>无头文件</li><li>明确的依赖</li><li>无循环依赖</li><li>常量只能是数字</li><li>int和int32是两种类型</li><li>字母大小写设置可见性（letter case sets visibility）</li><li>任何类型（type）都有方法（不是类型）</li><li>没有子类型继承（不是子类）</li><li>包级别初始化以及明确的初始化顺序</li><li>文件被编译到一个包里</li><li>包package-level globals presented in any order</li><li>没有数值类型转换（常量起辅助作用）</li><li>接口隐式实现（没有“implement”声明）</li><li>嵌入（不会提升到超类）</li><li>方法按照函数声明（没有特别的位置要求）</li><li>方法即函数</li><li>接口只有方法（没有数据）</li><li>方法通过名字匹配（而非类型）</li><li>没有构造函数和析构函数</li><li>postincrement（如++i）是状态，不是表达式</li><li>没有preincrement(i++)和predecrement</li><li>赋值不是表达式</li><li>明确赋值和函数调用中的计算顺序（没有“sequence point”）</li><li>没有指针运算</li><li>内存一直以零值初始化</li><li>局部变量取值合法</li><li>方法中没有“this”</li><li>分段的堆栈</li><li>没有静态和其它类型的注释</li><li>没有模板</li><li>内建string、slice和map</li><li>数组边界检查</li></ul><blockquote><h2 id="大牛真身"><a href="#大牛真身" class="headerlink" title="大牛真身"></a>大牛真身</h2><p>最大牌的当属B和C语言设计者、Unix和Plan 9创始人、1983年图灵奖获得者Ken Thompson，这份名单中还包括了Unix核心成员Rob Pike（go语言之父）、java HotSpot虚拟机和js v8引擎的开发者Robert Griesemer、Memcached作者Brad Fitzpatrick，等等。</p></blockquote><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-冒泡排序</title>
      <link href="posts/6299afab/"/>
      <url>posts/6299afab/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>冒泡排序（Bubble Sort）是一种很原始的排序方法，就是通过不断交换“大数”的位置达到排序的目的。因为不断出现“大数”类似于水泡不断出现，因此被形象地称为冒泡算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从一组数列（列表）中挑选一个最大的数，如果这个数列比较小，有可能我们一眼就看出谁最大，但是如果数列比较大，那么就不好确定了，冒泡排序不需要直接找出数列中最大的那个数，只需要在两个数中找出最大的就可以了。</p><p>冒泡算法的原理是比较两个相邻数字的大小，将两个数中比较大的那个数交换到靠后的位置。这样不断交换下去就可以将最大的那个数放到最后的位置，然后从头开始将第二大的数放到倒数第二的位置上，如此反复，知道将数列变成有序数列。</p><p>举例：</p><pre><code>7 3 5 1 9 4</code></pre><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>第1次排序，按照冒泡排序的原理，比较相邻两个数的大小，从数列头开始第一次比较7和3的大小，7比3大，交换7和3的位置，把7放在靠后的位置。交换的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> iList[i]&gt;=iList[i+<span class="number">1</span>]</span><br><span class="line">     iList[i],iList[i+<span class="number">1</span>]=iList[i+<span class="number">1</span>],iList[i]</span><br><span class="line"> <span class="comment">#这里你可能会疑惑为什么iList[1]被覆盖了，还能给iList[i+1]赋值，这里为python的序列解包，相关语法可查python官方文档。</span></span><br></pre></td></tr></table></figure><p>交换后如图所示</p><pre><code>3 7 5 1 9 4</code></pre><p>第2次比较7和5的大小，发现7比5大，交换7和5的位置，结果如图：</p><pre><code>3 5 7 1 9 4</code></pre><p>第3次比较7和1的大小，7比1大，交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第4次比较7和9的大小，7比9小，不交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第5次比较9和4的位置，9比4大，交换位置，结果如下：</p><pre><code>3 5 1 7 4 9</code></pre><p>到此，第一轮排序已经结束，成功序列中最大的值9放入最后的位置。然后再进行下一轮排序。</p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><pre><code>第一次  3 5 1 7 4 9第二次  3 1 5 7 4 9第三次  3 1 5 7 4 9第四次  3 1 5 4 7 9</code></pre><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><pre><code>第一次  1 3 5 4 7 9第二次  1 3 5 4 7 9第三次  1 3 4 5 7 9</code></pre><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><pre><code>第一次  1 3 4 5 7 9第二次  1 3 4 5 7 9</code></pre><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><pre><code>第一次  1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>建立无序序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#实现创建一个无序的数组,名字为randomList</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomList</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回一个长度为n的整数列表，数据范围[0,1000]&#x27;&#x27;&#x27;</span></span><br><span class="line">    iList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        iList.append(random.randrange(<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    iList=randomList(<span class="number">10</span>)</span><br><span class="line">    print(iList)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对无序序列进行冒泡排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> iList[j] &gt;= iList[j + <span class="number">1</span>]:  <span class="comment"># 比较相邻两数的大小</span></span><br><span class="line">                iList[j], iList[j + <span class="number">1</span>] = iList[j + <span class="number">1</span>], iList[j]  <span class="comment"># 将较大的数交换到靠后的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(bubbleSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;bubbleSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import bubbleSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用bubbleSort函数排序100遍用的时长</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月13日早</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-归并排序</title>
      <link href="posts/63e6e1be/"/>
      <url>posts/63e6e1be/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>给大家讲个故事：“从前有座山，山里有座庙，庙里有个老和尚在给小和尚讲故事，讲的是从前有座山，山里有座庙，庙里有个老和尚在给小和尚……”，这个故事大家可能都听过，这个故事实际上就体现了递归的思想，每个故事都在调用故事本身。本算法也用了递归思想，首先我们把数列分为left和right两个子数列，然后将left和right两个子数列都变成有序数列，再把他们合并到一起就变成了一个有序数列，那么left和right两子数列如何变成有序的呢，我们将left和right两个子数列分别再分成两部分得到子子数列，然后再将子子数列排序后合并得到有序的子书数列，那么子子数列如何变成有序数列呢，我们……这样的做法是不是很想前面将的那个故事呢。当然，他们还是有区别的，故事可以无限制讲下去，数列不会无限制分下去，当分到最小的子数列只有一个元素的时候，就不能再分了，这时候就要开始合并数列了。</p><p>将数列分为子数列的核心代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">middle = len(iList)//<span class="number">2</span> <span class="comment">#求分割点下标</span></span><br><span class="line">left , right = iList[<span class="number">0</span>:middle] , iList[middle:]   <span class="comment">#得到数列的切片 </span></span><br></pre></td></tr></table></figure><p>我们还是举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101801.png"></p><h3 id="1-第一次分组"><a href="#1-第一次分组" class="headerlink" title="1.第一次分组"></a>1.第一次分组</h3><p>长度为7，得到middle=6/2=3，两部分为[0:3]和[3:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101802.png"></p><h3 id="2-第二次分组"><a href="#2-第二次分组" class="headerlink" title="2.第二次分组"></a>2.第二次分组</h3><p>第一次分组得到的left和right长度为3，我们仍然无法知道这个长度为3的数列是否有序。那么继续分组<br>长度都为3，得到middle=3/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101803.png"></p><h3 id="3-第三次分组"><a href="#3-第三次分组" class="headerlink" title="3.第三次分组"></a>3.第三次分组</h3><p>第二次分组得到的left和right长度为1和2，我们仍然无法知道这个长度为2的数列是否有序。那么继续分组<br>长度都为2，得到middle=2/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101804.png"></p><p>至此，一个数列长度为6的数列，经过三次分组，被我们分成了六个长度为1的子数列，现在每个子数列已经为有序了，我们可以开始合并了。</p><p>将两个子数列合并的核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  left  <span class="keyword">and</span> right :  <span class="comment">#遍历两个子数列</span></span><br><span class="line">    <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]: <span class="comment">#将两子数列中较小的元素添加到mList中</span></span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="1-第一次合并"><a href="#1-第一次合并" class="headerlink" title="1.第一次合并"></a>1.第一次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101805.png"></p><h3 id="2-第二次合并"><a href="#2-第二次合并" class="headerlink" title="2.第二次合并"></a>2.第二次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101806.png"></p><h3 id="3-第三次合并"><a href="#3-第三次合并" class="headerlink" title="3.第三次合并"></a>3.第三次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101807.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:  <span class="comment"># 若只有一个元素，那就返回iList</span></span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    middle = len(iList) // <span class="number">2</span>  <span class="comment"># 求分割点下标</span></span><br><span class="line">    left, right = iList[<span class="number">0</span>:middle], iList[middle:]  <span class="comment"># 得到数列的切片</span></span><br><span class="line">    <span class="keyword">return</span> mergeList(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    mList = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:  <span class="comment"># 遍历两个子数列</span></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]:  <span class="comment"># 将两子数列中较小的元素添加到mList中</span></span><br><span class="line">            mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> mList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        print(iList)</span><br><span class="line">        print(mergeSort(iList))</span><br><span class="line">        print(timeit.timeit(<span class="string">&quot;mergeSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import mergeSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用归并排序算法排序100次花费的时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单解释下，代码中mergeSort实际上是在分组，mergeList实际上是在合并，注意mergeSort中的return语句给mergeList传的是两个函数参数，而mergeList接受的应该是两个列表，所以mergeSort分组语句将会不断进栈，一直到列表分成很多个长度为1的子列表后，开始出栈，执行mergeList函数进行合并，最后将最后一个有序的mList列表返回给mergeSort函数。</p><p>整理于2020年10月18日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-插入排序</title>
      <link href="posts/e02a01f2/"/>
      <url>posts/e02a01f2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>插入排序实际上跟我们打牌一样，斗地主应该大部分人都会玩的，我们在抓牌的时候，每当从下面抓起一张牌，我们就会将这张牌放到合适的位置，使手上的牌始终是一个有序的状态（有些人打牌也习惯乱放，前提是自己看得懂）。那么插入排序的过程，和以上的过程就很相似。</p><p>插入排序，首先将数列分成两部分，将数列的第一个数划分为left部分，剩下的数为right部分，我们依次将right部分的数一个一个取出，然后将该数放入left部分合适的位置，这样，left部分数越来越多，right部分的数越来越少，最后right部分为空，这时候left部分就为有序数列了。</p><p>核心实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>:len(iList))<span class="comment">#从第二个元素开始遍历right部分</span></span><br><span class="line">   target=iList[right]<span class="comment">#将每一个遍历的元素赋值为target</span></span><br><span class="line">   <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>:right)<span class="comment">#遍历left部分（left部分有序）</span></span><br><span class="line">       <span class="keyword">if</span> target&lt;=iList[left]:<span class="comment">#找到target该插入的位置</span></span><br><span class="line">           iList[left+<span class="number">1</span>:right+<span class="number">1</span>]=iList[left:right]<span class="comment">#插入位置后元素整体后移一位</span></span><br><span class="line">           iList[left]=target<span class="comment">#将target放在合适位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们还是那个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101601.png"></p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>我们将数列分为left和right两部分。开始的时候left部分为第一个数7（有序部分），剩下的为right部分（待排序部分）。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101602.png"></p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><p>从right中取出第一个数字3，然后将它放入left中合适的位置。从前往后遍历left部分的数，发现7比3大，然后将7以及后面的数（当前情况7后面没有数字）往后移一位，将3放在原本7所在的位置。（这里因为left只有一个7，比较简单，但是不了left部分多长都是一样的思想）</p><p><img src="https://voyager-m.gitee.io/picgo/test/101603.png"></p><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><p>我们从right部分继续选出元素5，然后从头遍历left部分的数，发现数字7比5大，这时候将7以及7后面的元素（当前情况7后面没有数字）往后移一位，将3放在原本7在的位置。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101604.png"></p><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101605.png"></p><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101606.png"></p><h3 id="6-第六轮排序"><a href="#6-第六轮排序" class="headerlink" title="6.第六轮排序"></a>6.第六轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101607.png"></p><p>自此，left部分为原数列排序后的有序数列。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        target = iList[right]</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>, right):</span><br><span class="line">            <span class="keyword">if</span> target &lt;= iList[left]:</span><br><span class="line">                iList[left + <span class="number">1</span>:right + <span class="number">1</span>] = iList[left:right]</span><br><span class="line">                iList[left] = target</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(insertionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;insertionSort(iList)&quot;</span>, <span class="string">&quot;from __main__ import  insertionSort,iList&quot;</span>, number=<span class="number">100</span>) ) <span class="comment"># 用这个算法排序100次所花时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整理于2020年10月16日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台-数据中台初识</title>
      <link href="posts/18280cf2/"/>
      <url>posts/18280cf2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、数据中台现象"><a href="#一、数据中台现象" class="headerlink" title="一、数据中台现象"></a>一、数据中台现象</h2><p>数据中台近两年非常火热，数据中台的热度已经拆超越了数字化转型的热度并且一直在上升。数据中台发起于2018年，崛起于2019年3月，目前已经远远超越了数据仓库，商业智能。 </p><p><strong>企业对数据中台的期望：</strong>与业务更精密，提供数据服务，提供业务价值，快速开发数据服务，围绕业务场景，提供统一数据，为业务赋能，构建统一的数据资产，打通数据的孤岛。</p><p>以上是企业的现实需求，那么为什么现有的数据仓库，数据平台（数据湖），商业智不能很好的满足这些需求呢。要弄清楚这个问题，我们就要弄清楚数据中台和前面这些东西的区别在哪里。</p><p><strong>商业智能和数据仓库：</strong>已分析报表为核心，把数据加工成分析报表提供给决策层去看，从而实现辅助决策的功能。商业智能的底层，是数据仓库。主要使用者是决策者。<br>数据湖：结构化数据和非结构化数据快速为业务产生数据服务，以数据存储和大数据为核心。主要的使用对象是开发者。</p><p><strong>数据中台：</strong>希望是直接服务于业务的平台，距离业务更近，用多种方式直接为业务提供数据产品。</p><p><strong>从出发点来说。</strong>数据中台优先考虑的是业务需要什么导向，是以业务需求为出发点。数据平台是存储加工数据的平台，所实现的功能取决于拥有的数据情况。是以技术和数据为导向的。</p><p><strong>从度量来看。</strong>数据中台做的好不好是以数据服务客户的满意度。数据平台的度量是看数据质量。</p><p>数据中台要核心解决的问题是过去企业应用开发团队和数据开发团队的协同问题，其中包括效率问题（应用开发一个报表都需要十几天时间），协作问题（获取数据错误，同样的数据逻辑却要开发两遍），能力问题（应用开发的人员很多，懂数据开发的人员很少）。数据中台能让应用开发专注于应用开发，让数据开发团队专注于数据开发。</p><p>数据中台是加速源数据产生业务价值的服务工厂，按照Gartner的分层架构理念，上面的是前端的创新型系统，下面是后端的记录型系统，中间的是链接前端创新想系统和后端的记录型系统的系统。上面的前台叫做敏态，下面的后台叫稳态。比如现在企业的erp等系统，这些系统偏企业后端的系统一般变化比较小，所以我们叫做稳态系统。比如h5广告，用户画像，这些系统是随着外界的变化而不断在变化，所以我们把它们叫叫做敏态系统。所以需要一个链接这两种系统的平台，于是中台产生了，中台的作用是使两种系统的速度一致，让后台提供服务给前台更快更敏捷。即数据中台是为了协调敏态前台业务和稳态的后台的速度，让他们之间的协作更加流畅，从而加速从元数据到业务价值的产生过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/1.png"></p><h2 id="二、现在业界常见的数据中台架构"><a href="#二、现在业界常见的数据中台架构" class="headerlink" title="二、现在业界常见的数据中台架构"></a>二、现在业界常见的数据中台架构</h2><h3 id="阿里数据中台"><a href="#阿里数据中台" class="headerlink" title="阿里数据中台"></a>阿里数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/2.png"><br><img src="https://voyager-m.gitee.io/picgo/test/3.png"></p><p>阿里数据中台是由Service，Entity，Data为核心组成。主要是三个方面的内容：OneData(业务数据化)，OneEntity(数据业务化)，OneService(业务服务化)。</p><h3 id="菜鸟数据中台"><a href="#菜鸟数据中台" class="headerlink" title="菜鸟数据中台"></a>菜鸟数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/4.png"></p><h3 id="苏宁数据中台"><a href="#苏宁数据中台" class="headerlink" title="苏宁数据中台"></a>苏宁数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/5.png"></p><p>数据中台对企业的意义就是，让传统企业向科技企业升级，让IT系统集成向大数据集成升级，让工具/流程/管理向驱动业务运营升级。</p><p><strong>数据平台：</strong></p><p>1.有完整的数据模型设计，但偏重设计和技术，在执行过程中，很难保证数据的全，数据应用一般不考虑跨过数据中心。</p><p>2.初期数据发展快，效率高，快速体现业务价值，但是随着数据仓库的建设，数据量急速叠加，整体成本居高不下。导致数据混乱，灾难。</p><p><strong>数据中台:</strong></p><p>1.数据中台的基本理念是：将所有数据汇聚到数据中台，每个数据应用都以数据中台为唯一数据来源。</p><p>2.苏宁数据中台的目标是为苏宁的数据战略提供有力的支撑，从企业全进行统一规划，统一建设，强调数据“全”。从设计、组织、建设、流程角度保障了模式的落地。</p><p>3.数据中台的建设减低了数据使用门槛。</p><h3 id="滴滴数据中台"><a href="#滴滴数据中台" class="headerlink" title="滴滴数据中台"></a>滴滴数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/6.png"><br><img src="https://voyager-m.gitee.io/picgo/test/7.png"></p><p>数据中台不是简单的把数据相应的模块系统放在公司里面搭建起来就ok。</p><p>数据可能今后发挥价值最大的地方是赋能AI。通过建立好数据中台服务层，再把它演变成对应的特征层，来驱动出这样强化学习的营销体系，目前滴滴的数据中台更多的产生价值在生产侧。</p><p><strong>目前存在的一些困难问题:</strong></p><p>1.在数据生产价值线（数据-&gt;生产-&gt;价值）中质量，效率，成本的问题.</p><p>2.数据实际上是现实物理世界在数据世界中的投影，那么不同的场景就会产生不同的投影，同样的业务行为在不同的场景下会有不同的分析角度。在业务角度，当然希望这种场景和维度越多越好，但是这会给数据管理带来很大的难度。</p><h3 id="Oppo数据中台"><a href="#Oppo数据中台" class="headerlink" title="Oppo数据中台"></a>Oppo数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/8.png"></p><p>Oppo日活跃用户超过2亿，在运营这些互联网应用的过程中，oppo积累了大量数据，已超过100PB，日增数据量超过20TB，oppo的数据中台以数据仓库为核心，构建了实时的数据服务能力。</p><p><strong>Oppo把数据中台分成了4个层次，:</strong></p><p>1.最下面的是统一工具体系，涵盖了“接入-&gt;治理-&gt;开发-&gt;消费”全数据链路。</p><p>2.基于工具体系之上构建了数据仓库，划分为“原始层-明细层-汇总层-应用层”，这也是经典的数据仓库架构，数据仓库在整个架构中处于非常基础和核心的位置。</p><p>3.再往上就是全域的数据体系，全域就是把公司所有的业务数据都打通，形成统一的数据资产，如ID-mapping，用户标签等。</p><p>4.最终，数据要能被业务用起来，需要场景驱动的数据产品与服务。</p><h3 id="浙江移动数据中台"><a href="#浙江移动数据中台" class="headerlink" title="浙江移动数据中台"></a>浙江移动数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/9.png"></p><p>打造数据中台，实现跨域数据整合并沉淀公共的数据能力，同时提供丰富的数据模型，标准化的数据服务，个性化的开发平台与工具，满足一线数据开放和智慧运营要求。</p><h3 id="从业务数据化到数据业务化"><a href="#从业务数据化到数据业务化" class="headerlink" title="从业务数据化到数据业务化"></a>从业务数据化到数据业务化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/10.png"></p><h2 id="三、数据中台的愿景和使命"><a href="#三、数据中台的愿景和使命" class="headerlink" title="三、数据中台的愿景和使命"></a>三、数据中台的愿景和使命</h2><p><strong>数据中台的愿景：</strong>打造数据驱动的智能企业</p><p><strong>数据中台的使命：</strong>赋能业务以数据智能能力，让业务更智慧</p><h2 id="四、数据中台的本质和六大能力模型"><a href="#四、数据中台的本质和六大能力模型" class="headerlink" title="四、数据中台的本质和六大能力模型"></a>四、数据中台的本质和六大能力模型</h2><p>**数据中台的本质:**数据中台是数据服务工厂为企业提供可复用的数据智能服务</p><p>数据中台的六大能力模型：</p><p><strong>数据资产的规划和治理：</strong></p><p>数据资产的规划和治理，是数据中台的基础功能，它的目的是为了在构建数据服务，数据产品，数据应用之前，先画出企业的数据资产蓝图，尽可能的涵盖企业所有的可能产生和使用的数据，不论是企业内部数据还是外部数据。</p><p>数据资产的规划和治理体系，是企业数据战略的体现，承载系统是企业级数据资产目录(Data Asset Catalog)。</p><p>数据资产的规划和治理，是从根本上最大限度解决数据孤岛(Data Silo)问题的方案，也就是在应用构建，数据产生之前就规划好数据的产生和消费的数据流体系，从而所有的应用都按照这个规范来执行。</p><p><strong>数据自元的获取和存储：</strong></p><p>在企业梳理了构建了自己的数据资产蓝图后，就需要将这些数据资产对应的数据资源进行存储和存储，也就是很多企业常说的，“数据入湖”。</p><p>数据资源的获取和存储，在广义数据中台体系里是数据平台的一部分，不同的企业在不同的阶段，可以采用的技术手段是不一样的，关系型数据库，大数据平台，数据湖，乃至最简单的文件存储都可以作为数据资源存储获取的方式，并不一定要拘泥于一种形式。</p><p>这个模块的核心是数据资源是能够被按需获取到的，这也就意味着，哪怕我们不构建独立的数据存储，让数据留在源系统中，只要能够在需要的时候获取到，也是可以的。</p><p><strong>数据资产的共享和协作：</strong></p><p>如何能够让企业的业务更智慧，这里最重要的事情就是跨域数据的组合和分析，不同领域的数据的挖掘，整合才能产生人的经验所不能够具备的洞察。</p><p>数据中台区别于传统数据仓库的一个重要的特点，就是数据中台是企业的数据服务的协作生产平台，他是一个能够让业务需求人员，数据分析人员这样的数据使用方和数据工程师，数据管理员这样的数据提供方在一个平台上去共同使用同一套企业的数据资产的协作平台。这里很重要的功能就是企业数据门户，企业数据目录和数据版本管理，数据沙箱（Sandbox)，数据分级权限体系。</p><p><strong>业务价值的探索和分析：</strong></p><p>数据中台是一个数据服务工厂，那么这个工厂应该生产什么服务呢？</p><p>就像传统的工厂都会有一个研发中心一样，数据中台需要一个数据实验室平台，能够让业务人员，数据分析人员，数据科学家们在数据协作平台上，利用同一套数据进行业务价值的探索和分析，从而识别有价值的数据集，然后在批量生产，形成数据产品和服务。</p><p>这部分重要的功能是数据挖掘，数据科学平台，算法平台，机器学习平台等。</p><p><strong>数据服务的构建和治理：</strong></p><p>当有价值的数据服务在实验室（研发中心）中被识别出来，并且通过协作平台被验证，那么这个过程就要被工业化，形成一个数据服务的生产线（Data Pipeline），从而能够被自动，批量的生产出来，为业务提供按需的服务，这就是数据服务的构建部分。</p><p>数据中台会生产非常多的数据服务，所以，数据中台同时要提供这么多数据服务的治理功能，从而保证数据服务的全生命周期体系化管理，优化有价值的数据服务，下线过时的数据服务。</p><p><strong>数据服务的度量和运营：</strong></p><p>传统的数据仓库系统往往只关注系统的稳定性，但是并不关注提供的数据报表的使用情况，被应用的如何，是否为业务产生了价值。而数据中台作为企业的数据服务工厂，是一个运营数据服务的业务单元。</p><p>整理于2020年10月14日</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据中台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力大数据技术框架整理</title>
      <link href="posts/8a1e23b3/"/>
      <url>posts/8a1e23b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> 随着社会现代化不断推进，出先了很多例如大数据和人工智能等新型技术，这些技术正在为越来越多的行业赋能。电力在我们生活中可以说是处处不在，为了提供更加便捷智能的服务，电力行业也出现了许多需要解决的问题。那么互联网技术如何为电网赋能呢？电网这个庞大的体系中的各个分支都可以和哪些技术呢结合呢？作为一项研究课题，我们可以从哪些切入点开始呢？下面是我通过几天的学习给出的自己的答案。</p><p><img src="https://voyager-m.gitee.io/picgo/powerBigDataPic/electricBigData.png" alt="电力技术框架"></p><p> 这份框架图已经总结的很详细，这里就不再赘述。个人认为从研究切入点来说可以分为以下几点。</p><h2 id="一．研究现有方法，从技术层面为研究切入点"><a href="#一．研究现有方法，从技术层面为研究切入点" class="headerlink" title="一．研究现有方法，从技术层面为研究切入点"></a>一．研究现有方法，从技术层面为研究切入点</h2><h3 id="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"><a href="#以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。" class="headerlink" title="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"></a>以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。</h3><h2 id="二、寻找新的方法，从数据问题为研究切入点"><a href="#二、寻找新的方法，从数据问题为研究切入点" class="headerlink" title="二、寻找新的方法，从数据问题为研究切入点"></a>二、寻找新的方法，从数据问题为研究切入点</h2><h3 id="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"><a href="#现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。" class="headerlink" title="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"></a>现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。</h3><h3 id="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"><a href="#伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。" class="headerlink" title="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"></a>伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。</h3><h3 id="面临的一些问题："><a href="#面临的一些问题：" class="headerlink" title="面临的一些问题："></a>面临的一些问题：</h3><h3 id="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"><a href="#（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。" class="headerlink" title="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"></a>（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。</h3><h3 id="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"><a href="#（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。" class="headerlink" title="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"></a>（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。</h3><h3 id="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"><a href="#（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高" class="headerlink" title="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"></a>（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高</h3><h3 id="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"><a href="#（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。" class="headerlink" title="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"></a>（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。</h3><h2 id="三、探索新方案，从具体问题为研究切入点"><a href="#三、探索新方案，从具体问题为研究切入点" class="headerlink" title="三、探索新方案，从具体问题为研究切入点"></a>三、探索新方案，从具体问题为研究切入点</h2><h3 id="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"><a href="#电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。" class="headerlink" title="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"></a>电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。</h3><div class="note success simple"><p>以上为仅为作者个人观点。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧电网 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-neo4j入门</title>
      <link href="posts/3b57b49b/"/>
      <url>posts/3b57b49b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>什么是知识图谱？</strong></p><p><strong>有人的地方就会有江湖</strong></p><p><strong>江湖不是打打杀杀</strong></p><p><strong>而是人情世故</strong></p><p><strong>人情世故就是各种关系嘛</strong></p><p><strong>人情世故通常都是文本数据</strong></p><p><strong>在海量数据中将各种各样的关系抽出来</strong></p><p><strong>那我，我们怎么存储这些关系</strong></p><p><strong>普通的数据库，当然不行了</strong></p><p><strong>因为不够直观嘛</strong></p><p><strong>所以我们就有了神器——neo4j</strong></p><p><strong>neo4j是一种图形化数据库，能让人很直观看出各实体之间的关系。</strong></p><h2 id="1、JDK环境配置"><a href="#1、JDK环境配置" class="headerlink" title="1、JDK环境配置"></a>1、JDK环境配置</h2><p>很多人电脑上本来就有jdk，但是很抱歉，neo4j很矫情，它对JDK版本有要求，所以最好卸载原有的JDk，安装最新版本的JDk。</p><p>JDK安装：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p>直接无脑下载后点下一步就ok了。</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建  </p><p>变量名：JAVA_HOME</p><p>变量值：C:\Program Files\Java\jdk1.8.0_152（以安装路径为主）</p><hr><p>系统变量-&gt;新建</p><p>变量名：CLASSPATH</p><p>变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;  （注意符号，建议直接复制粘贴）</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %JAVA_HOME%\bin 填进去（注意符号，建议直接复制粘贴）<br>变量值：点击新建，将  %JAVA_HOME%\jre\bin 填进去（注意符号，建议直接复制粘贴）</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入java -version</p><p><img src="https://voyager-m.gitee.io/picgo/test/102801.png"></p><p>若出现这个图就表明成功啦！</p><h2 id="2、neo4j环境配置"><a href="#2、neo4j环境配置" class="headerlink" title="2、neo4j环境配置"></a>2、neo4j环境配置</h2><p>Neo4j安装：<a href="https://neo4j.com/download-center/">https://neo4j.com/download-center/</a></p><p>官网下载，然后无脑下一步安装</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建</p><p>变量名：NEO4J_HOME</p><p>变量值： C:\neo4j-community-4.1.3</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %NEO4J_HOME%\bin  填进去</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入neo4j</p><p><img src="https://voyager-m.gitee.io/picgo/test/102802.png"></p><p>若出现这个图就表明成功啦！</p><p>本人已与百度合作，若以上配置过程看不懂或者有问题，可尝试百度搜索“xxx安装配置教程”即可。</p><h2 id="3-启动neo4j看看"><a href="#3-启动neo4j看看" class="headerlink" title="3.启动neo4j看看"></a>3.启动neo4j看看</h2><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现如下界面表示成功启动</p><p><img src="https://voyager-m.gitee.io/picgo/test/102803.png"></p><p>图中红方框就就是访问地址</p><p>打开浏览器输入：<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>第一次登录的<strong>用户名</strong>和<strong>密码</strong>都是neo4j，登录成功后可以修改密码。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102804.png"></p><p>请看上面这张图：点开1位置的小星星，然后点击下面的Movie Graph（这是neo4j自带的演示知识图谱），然后我们会看到3位置自动出现了一行指令，然后点击4位置的小三角板，我们会得到5位置的界面，然后我们可以点击6位置的翻页，下面的每一页都会介绍neo4j的Cypher Query Language语句。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102805.png"></p><p>将页面翻到第2页，点击1位置的任意地方，我们能看到2位置的方框内自动出现了一堆指令，然后点击3位置的小三角，我们可以得到下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102806.png"></p><p>来解释下这个图哈，这个图中有9个person标签，8个movie标签，8个acted_in关系和10个directed关系。比如Tom Hanks演了8个电影。</p><p>至此，演示例子都看完啦，我只演示了第2页的指令，其他页的指令会简单的把Cypher Query Language都做一遍介绍，可自行琢磨，想系统学习Cypher Query Language可以去w3cschool看neo4j教程。</p><h2 id="3、Cypher-Query-Language简单操作"><a href="#3、Cypher-Query-Language简单操作" class="headerlink" title="3、Cypher Query Language简单操作"></a>3、Cypher Query Language简单操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">增加一个节点</span><br><span class="line">create(n:Person&#123;name:&#39;毛同学&#39;,age:5&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102807.png"></p><p>解释一下：n相当于一个别名，Person是我们定义的标签名字，大括号里面是属性，这里我们创建了名字name和年龄age两个属性，值分别为‘毛同学’和5。</p><p>图中点击毛同学这个圆圈，可以看到左下角显示这个实体的id号和属性以及属性值。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带有关系属性</span><br><span class="line">create (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[:是一个&#123;负债:10000&#125;]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102808.png"></p><p>解释一下：这个语句的前面和后面一部分其实就是创建实体的语句，主要是中间的，”：”后面的代表这个关系的名称，大括号里面的表示这个关系的属性。</p><p>图中点击1位置的关系，我们可以看到2位置的关系属性。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个穷人！（负债10000）</font>（这是个悲伤的故事）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删：</span><br><span class="line">create (n:Person &#123;name:&#39;MWY&#39;,age:20&#125;)</span><br><span class="line">match (n:Person&#123;name:&quot;MWY&quot;&#125;) delete n</span><br></pre></td></tr></table></figure><p>解释一下：这两句话是先创建了一个结点又删除了一个结点。其中删除语句中的n代表一个别名，相当于一个返回值，意思是在Person标签中查找name为”MWY”的返回给n，后面”delete n”代表删除n（就是查到的结点）这个结点。（注意：要删除点，必须先删除关系，不然不能删除）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除关系</span><br><span class="line">match (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[f:是一个]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;) delete f</span><br></pre></td></tr></table></figure><p>解释一下：删除关系语句中的前面部分和后面部分应该都能懂了，中间这部分，是把f当成一个返回值，查找到”是一个”这个关系后返回给f，后面的”delete f”代表把这个关系删除了，当然也可以变成”delete p,f,n”，这表示把两个结点和它们的关系都删掉了。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上标签：</span><br><span class="line">match (t:Person) where id(t)&#x3D;0 set t:好人 return t</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102809.png"></p><p>解释一下：首先match是查找的意思，t接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为person的结点增加一个”好人”标签。</p><p>图中点击1位置的关系，我们可以看到2位置的标签变成了两个。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！</font>（挺不好意思的）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;200  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102810.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为”好人”的结点增加一个”颜值”属性，值为200。</p><p>这个图的意思就是说：<font color=#008000>同学是一个人！且是个好人！他的颜值为200</font>（不接受反驳）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">修改属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;500  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102811.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示修改的意思，意思是把id为0的标签为”好人”的结点的”颜值”属性改为500。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！200都已经不能够表示他的颜值，500才能勉强表示</font>（我有点飘）</p><hr><p>如果你想清空数据库那么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速清空数据库：</span><br><span class="line">MATCH (n)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure><p>解释一下：n，表示的是一个别名，后面一句表示清空n，也就是清空数据库。</p><p>这就是我们常说的<font color=#008000>“删库跑路”</font>一句中的删库指令。（温馨提示：慎用）</p><p>若想交流，加qq：1518887260</p><p>整理于2020年10月28日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-用python操纵neo4j数据库-以高速收费站记录为例</title>
      <link href="posts/c6f18f63/"/>
      <url>posts/c6f18f63/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h2><p>首先我们来看看数据是什么样子的</p><p><img src="https://voyager-m.gitee.io/picgo/test/103101.png"></p><p>这个数据实际上能做很多事情，但是本文主要重点主要是弄懂如何用python来建立neo4j数据库中的结点和关系，以后换了场景只需要在本文代码上结合neo4j官方文档进行修改即可。</p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python3.8</span><br><span class="line">neo4j.4.1.3</span><br><span class="line"></span><br><span class="line">所需库：</span><br><span class="line">pip install py2no &#x3D;&#x3D;5.0b1 #注意版本不低于此版本</span><br><span class="line">pip install pandas</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-链接模块编写（模块名称：DataToNeo4jClass）"><a href="#3-链接模块编写（模块名称：DataToNeo4jClass）" class="headerlink" title="3.链接模块编写（模块名称：DataToNeo4jClass）"></a>3.链接模块编写（模块名称：DataToNeo4jClass）</h2><p>本文将必要的注释都写在了代码段中，所以这里直接给出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Node, Graph, Relationship, NodeMatcher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataToNeo4j</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将excel中数据存入neo4j&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立连接&quot;&quot;&quot;</span></span><br><span class="line">        link = Graph(<span class="string">&quot;http://localhost:7474&quot;</span>, username=<span class="string">&quot;neo4j&quot;</span>, password=<span class="string">&quot;admin&quot;</span>)<span class="comment">#改成你自己的用户名和密码</span></span><br><span class="line">        self.graph = link</span><br><span class="line">        <span class="comment"># self.graph = NodeMatcher(link)</span></span><br><span class="line">        <span class="comment"># 定义label</span></span><br><span class="line">        self.buy = <span class="string">&#x27;buy&#x27;</span></span><br><span class="line">        self.sell = <span class="string">&#x27;sell&#x27;</span></span><br><span class="line">        self.graph.delete_all()</span><br><span class="line">        self.matcher = NodeMatcher(link)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        node3 = Node(&#x27;animal&#x27; , name = &#x27;cat&#x27;)</span></span><br><span class="line"><span class="string">        node4 = Node(&#x27;animal&#x27; , name = &#x27;dog&#x27;)  </span></span><br><span class="line"><span class="string">        node2 = Node(&#x27;Person&#x27; , name = &#x27;Alice&#x27;)</span></span><br><span class="line"><span class="string">        node1 = Node(&#x27;Person&#x27; , name = &#x27;Bob&#x27;)  </span></span><br><span class="line"><span class="string">        r1 = Relationship(node2 , &#x27;know&#x27; , node1)    </span></span><br><span class="line"><span class="string">        r2 = Relationship(node1 , &#x27;know&#x27; , node3) </span></span><br><span class="line"><span class="string">        r3 = Relationship(node2 , &#x27;has&#x27; , node3) </span></span><br><span class="line"><span class="string">        r4 = Relationship(node4 , &#x27;has&#x27; , node2)    </span></span><br><span class="line"><span class="string">        self.graph.create(node1)</span></span><br><span class="line"><span class="string">        self.graph.create(node2)</span></span><br><span class="line"><span class="string">        self.graph.create(node3)</span></span><br><span class="line"><span class="string">        self.graph.create(node4)</span></span><br><span class="line"><span class="string">        self.graph.create(r1)</span></span><br><span class="line"><span class="string">        self.graph.create(r2)</span></span><br><span class="line"><span class="string">        self.graph.create(r3)</span></span><br><span class="line"><span class="string">        self.graph.create(r4)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_node</span>(<span class="params">self, node_buy_key, node_sell_key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> node_buy_key:</span><br><span class="line">            buy_node = Node(self.buy, name=name)</span><br><span class="line">            self.graph.create(buy_node)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> node_sell_key:</span><br><span class="line">            sell_node = Node(self.sell, name=name)</span><br><span class="line">            self.graph.create(sell_node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_relation</span>(<span class="params">self, df_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立联系&quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>, len(df_data)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                print(list(self.matcher.match(self.buy).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;buy&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>)))</span><br><span class="line">                print(list(self.matcher.match(self.sell).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;sell&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>)))</span><br><span class="line">                rel = Relationship(self.matcher.match(self.buy).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;buy&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>).first(),</span><br><span class="line">                                   df_data[<span class="string">&#x27;money&#x27;</span>][m], self.matcher.match(self.sell).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;sell&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>).first())</span><br><span class="line"></span><br><span class="line">                self.graph.create(rel)</span><br><span class="line">            <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">                print(e, m)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-数据提取与结点创立（类名称：invoice-neo4j）"><a href="#4-数据提取与结点创立（类名称：invoice-neo4j）" class="headerlink" title="4.数据提取与结点创立（类名称：invoice_neo4j）"></a>4.数据提取与结点创立（类名称：invoice_neo4j）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataToneo4jClass.DataToNeo4jClass <span class="keyword">import</span> DataToNeo4j</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip install py2no ==5.0b1 注意版本不低于此版本</span></span><br><span class="line"></span><br><span class="line">invoice_data=pd.read_excel(<span class="string">&#x27;./Invoice_data_Demo.xls&#x27;</span>, header=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(invoice_data)</span></span><br><span class="line"><span class="comment">#官方文档：https://py2neo.org/v4/index.html</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_extraction</span>():</span></span><br><span class="line">    <span class="comment">#取出购买方和销售方名称带list</span></span><br><span class="line"></span><br><span class="line">    node_buy_key=[]<span class="comment">#建立一个空列表存放购名称</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        node_buy_key.append(invoice_data[<span class="string">&#x27;购买方名称&#x27;</span>][i])</span><br><span class="line"></span><br><span class="line">    node_sell_key=[]<span class="comment">#建立一个空列表存放销售方名称</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        node_sell_key.append(invoice_data[<span class="string">&#x27;销售方名称&#x27;</span>][i])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去除重复的发票名称</span></span><br><span class="line">    node_buy_key=list(set(node_buy_key))</span><br><span class="line">    node_sell_key=list(set(node_sell_key))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将Value抽出做node</span></span><br><span class="line">    node_list_value=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,len(invoice_data.columns)):</span><br><span class="line">            <span class="comment">#将表头名称invoice_data.colums[i]取出</span></span><br><span class="line">            node_list_value.append(invoice_data[invoice_data.columns[n]][i])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去重</span></span><br><span class="line">    node_list_value=list(set(node_list_value))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将list中的浮点数以及整数类型全部转换为string类型</span></span><br><span class="line"></span><br><span class="line">    node_list_value=[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> node_list_value]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_buy_key,node_sell_key,node_list_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relation_extraction</span>():</span></span><br><span class="line">    <span class="comment">#联系数据抽取</span></span><br><span class="line"></span><br><span class="line">    links_dict=&#123;&#125;</span><br><span class="line">    sell_list=[]</span><br><span class="line">    money_list=[]</span><br><span class="line">    buy_list=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        money_list.append(invoice_data[invoice_data.columns[<span class="number">19</span>]][i])  <span class="comment"># 金额</span></span><br><span class="line">        sell_list.append(invoice_data[invoice_data.columns[<span class="number">10</span>]][i])  <span class="comment"># 销售方方名称</span></span><br><span class="line">        buy_list.append(invoice_data[invoice_data.columns[<span class="number">6</span>]][i])  <span class="comment"># 购买方名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#将数据中的int类型的数据全部变成string类型的</span></span><br><span class="line">    sell_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> sell_list]</span><br><span class="line">    buy_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> buy_list]</span><br><span class="line">    money_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> money_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 整合数据，将三个list整合成一个dict</span></span><br><span class="line">    links_dict[<span class="string">&#x27;buy&#x27;</span>] = buy_list</span><br><span class="line">    links_dict[<span class="string">&#x27;money&#x27;</span>] = money_list</span><br><span class="line">    links_dict[<span class="string">&#x27;sell&#x27;</span>] = sell_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据转成DataFrame</span></span><br><span class="line">    df_data = pd.DataFrame(links_dict)</span><br><span class="line">    print(df_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_data</span><br><span class="line"></span><br><span class="line"><span class="comment">#relation_extraction()</span></span><br><span class="line">create_data=DataToNeo4j()</span><br><span class="line">create_data.create_node(data_extraction()[<span class="number">0</span>], data_extraction()[<span class="number">1</span>])</span><br><span class="line">create_data.create_relation(relation_extraction())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>强调一下：</strong>上面两个代码段，需要将两个文件放在一起，一点一点看懂，虽然有些花时间吗，但是收获不会少，遇到不懂的百度，并创建一个test文件，将不懂的点的demo复制到test文件中运行一下，多打印一些东西，分析下结果就全明白了。</p><h2 id="5-结果展示"><a href="#5-结果展示" class="headerlink" title="5.结果展示"></a>5.结果展示</h2><p>首先打开cmd执行以下代码将neo4j的服务开起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>然后运行invoice_neo4j类</p><p>然后浏览器访问<a href="http://localhost:7474/">http://localhost:7474</a> 得到如下结果</p><p><img src="https://voyager-m.gitee.io/picgo/test/103102.png"><br><img src="https://voyager-m.gitee.io/picgo/test/103103.png"><br><img src="https://voyager-m.gitee.io/picgo/test/103104.png"></p><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6.写在后面"></a>6.写在后面</h2><pre><code>感谢教程：    知识图谱实战系列（python版），本文在教程代码上进行修改并添加了更多的注释。本人将项目代码放在了百度网盘：    链接：https://pan.baidu.com/s/1PibmNxtn9JXT4SVOF4sJ_Q     提取码：ghsy 欢迎一起交流学习：本人QQ：1518887260</code></pre><p>整理于2020年10月31日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱初识-知识图谱与语义技术简介</title>
      <link href="posts/ac2a99b3/"/>
      <url>posts/ac2a99b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习知识图谱相关知识和技术，所以会在博客做一个记录，首先对学习过程中所读资料的作者表示衷心的感谢，其次，在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。</p><p>本文主要是对整个知识图谱体系进行一个大体上的认识，明白知识图谱是个什么东西，大致包涵那几块内容，每一块大致用到了哪些技术，而对于其中的技术，后面我会慢慢整理。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102401.png"></p><h2 id="知识图谱技术概览"><a href="#知识图谱技术概览" class="headerlink" title="知识图谱技术概览"></a>知识图谱技术概览</h2><h3 id="知识图谱概念演化"><a href="#知识图谱概念演化" class="headerlink" title="知识图谱概念演化"></a>知识图谱概念演化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/102402.png"></p><p>1960年，语义网络作为知识表示的一种方法被题出。<br>1980s，哲学理念“本体”被引入到人工智能领域被用来刻画知识。<br>1989年，Tim Berners-Lee发明了万维网（Linked Information System）。<br>1998年，从超文本链接到语义链接。<br>2006年，Tim突出强调了语义网络的本质是要建立开放数据之间的链接。<br>2012年，谷歌发布了基于知识图谱的搜索引擎产品。</p><p>从以上历程我们可以看出，知识图谱其实是得益于Web的发展，其中有着KR,NLP,Web,AI等多方面的影子。</p><h3 id="知识图谱的本质"><a href="#知识图谱的本质" class="headerlink" title="知识图谱的本质"></a>知识图谱的本质</h3><p>知识图谱整个体系还是比较大的，目前没有一个标准的定义，其中“Exploiting Linked Data and Knowledge Graphs in Large Organisations”这本书对知识图谱的定义为：</p><p>A knowledge graph consists of a set of interconnected typed entities and their attributes.</p><p>翻译过来就是：知识图谱是由一些相互连接的实体和它们的属性构成的。</p><p>其中最经典的就是三元组：<br><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>其实就一主，一谓，一宾。比如上图的人工智能，之父是，图灵。实际上就是我们所说的“人工智能之父是图灵”</p><p>我们也可以从不同方面来看知识图谱：</p><p><strong>从Web角度</strong> 像建立文本之间的超链接一样，建立数据之间的语义链接，并支持语义搜索。<br><strong>从NLP角度</strong> 怎样从文本中抽取语义和结构化数据。<br><strong>从KR角度</strong>  怎样利用计算机符号来表示和处理知识。<br><strong>从AI角度</strong>  怎样利用知识库来辅助计算机理解人的语言。<br><strong>从DB角度</strong>  用图的方式去存储知识。</p><p>所以啊，其实做好KG要利用好KR，NLP，Web，ML，DB多方面的方法和技术。</p><p>我们再举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102404.png"></p><p>“聪明的Ai”其实是从学习的角度进行感知，识别，判断，依靠深度学习。<br>“有学识的Ai”其实是从推理的角度进行思考，语言，推理，依靠知识图谱。</p><h2 id="知识图谱技术简介"><a href="#知识图谱技术简介" class="headerlink" title="知识图谱技术简介"></a>知识图谱技术简介</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102405.png"></p><p>技术体系其实可以概括为：知识表示，知识抽取，知识问答，知识推理，知识融合，知识众包。<br>途中下面表示的是数据部分的主要来源：KBP,D2R,Linked MEDIA/Visual Genome,OneM2M,WikiData。</p><h3 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h3><p>知识表示是研究怎么样用计算机符号来表示人脑中的知识，以及怎么样通过符号之间的运算来模拟人脑的推理课程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102406.png"></p><p>图上是整个知识图谱的演进过程（知识演进也是一个很有意思的方向，有机会后面整理哦），其实说白了就是一个基于数理逻辑的知识表示到基于向量空间学习分布式知识表的过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102407.png"></p><p>以上这个图是官方给出的语义知识网表示框架，由于本篇文章是知识图谱概览，所以我们大概来看一下这个框架。最底层的URI/IRI是网络连接，上面一层是XML和RDF是资源表示框架，而SPARQL是一种知识查询语言。而蓝色部分（知识推理框架）包含了RDFS和OWL框架。下面我们对其中的几个框架做进一步解释：</p><p><strong>RDF</strong>：资源描述框架（Resource Description Framework）,它是由W3C制定的，是用来描述实体/资源的标准数据模型。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>还是以上面这个图为例，在知识图谱中我们一般用RDF形式化的来表示三元关系（Subject，predicate，object）。</p><p>RDFS在RDF的基础上定义了一些固定的关键词：Class，subClassOf,type,Property,subPropertyOf,Domain,Range以及多了Schema层。如下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102408.png"></p><p><strong>OWL</strong>：网络本体语言（Web Ontology Language）这个本体实际上是从哲学里面来的，OWL在RDF语言上扩充了Schema层，使之支持推理等操作。</p><pre><code>Ontology in Philosophy：Ontology is the philosophical study of the nature of being, becoming, existence or reality, as well asthe basic categories of being and their relations.                                  Tom Gruber，Founder of Siri哲学本体论：本体论是对存在，成为，存在或存在的本质以及存在及其关系的基本类别的哲学研究。                                                韦伯斯特Ontology in Computer Science and Artificial Intelligence：An ontology is a description (like a formal specification of a program) of the concepts andrelationships that can formally exist for an agent or a community of agents.                                Tom Gruber，Founder of Siri计算机科学与人工智能中的本体论：本体是对代理或代理社区可以正式存在的概念和关系的描述（如程序的正式说明）。                                Siri创始人汤姆·格鲁伯Web OntologiesOntologies based on web standards such as RDFS/OWL.OWL is based on Description Logic, avery very long history of research in Artificial Intelligence.基于Web标准的本体(如RDFS/OWL.OWL)是基于描述逻辑(DescriptionLogic)的，人工智能研究历史悠久。</code></pre><p><img src="https://voyager-m.gitee.io/picgo/test/102409.png"></p><p><strong>SPARQL</strong>：SPARQL是RDF的查询语言，它基于RDF数据模型，可以对不同的数据集撰写复杂的连接，由所有主流的图数据库支持。其操作如：<br><img src="https://voyager-m.gitee.io/picgo/test/102410.png"></p><p><strong>JSON-LD</strong>：（JSON for Linking Data） 适用于作为程序之间做数据交换,在网页中嵌入语义数据和Restful Web Service。存储格式如:<br><img src="https://voyager-m.gitee.io/picgo/test/102411.png"></p><p><strong>知识图谱的分布式表示–KG Embedding</strong>：在保留语义的同时，将知识图谱中的实体和关系映射到连续的稠密的低维向量空间。<br><img src="https://voyager-m.gitee.io/picgo/test/102412.png"></p><h3 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h3><p>知识抽取大多是结合NLP和KG进行的。<br><img src="https://voyager-m.gitee.io/picgo/test/102413.png"></p><p>先是从网络获取大量的非结构化的文本数据，经过文本预处理后得到干净的文本数据，然后借助分词，词性标注，语法解析，依存分析等技术对文本进行处理，我们得到词法和句法的分层，接下来我们对文本进行NER命名实体识别和实体链接，最后通过关系抽取和事件抽取最终得到KR用的三元组，多元关系，模态知识等。</p><p><strong>知识抽取的主要方法</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102414.png"></p><h3 id="知识存储"><a href="#知识存储" class="headerlink" title="知识存储"></a>知识存储</h3><p>知识比数据的结构更加复杂，知识存储需要综合考虑图的特点，复炸的知识存储结构，索引和查询（支持推理）的优化等问题。<br>典型的知识存储引擎分为基于关系数据库的存储和基于原生图的存储。<br>在实践过程中，多为混合存储结构，图存储并非必须<br><img src="https://voyager-m.gitee.io/picgo/test/102415.png"></p><h3 id="知识问答"><a href="#知识问答" class="headerlink" title="知识问答"></a>知识问答</h3><p>KBQA（Knowledge-Based Question Answer，基于知识库的问题回答）<br>以直接而准确的方式回答用户自然语言提问的自动问答系统将构成下一代搜索引擎的基本形态。<br><img src="https://voyager-m.gitee.io/picgo/test/102416.png"></p><p>我们来举几个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102417.png"></p><p>传统的搜索引擎，只会将匹配的资源列在页面，我们需要自己去筛选理解其中的信息，以获取自己真正想得到的问题的答案。而嵌入了知识图谱的搜索引擎似乎更“智能”了，它能直接很直观的返回我们想要的真正的问题的答案。是不是很方便呢！</p><p>我们以一个例子来看看KBQA的实现流程:<br><img src="https://voyager-m.gitee.io/picgo/test/102418.png"></p><p>当你问“姚明的老婆多大了？”这个问题的时候，首先会对这个问题进行语义解析得到问题的语义表示，然后再KB中查找答案，最终将答案返回，其中KB知识库的数据数量和质量直接决定了该系统的质量。</p><h3 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h3><p>简单的来说，推理就是指基于已知事实推出来未知的事实的过程。<br>目前大部分搜索引擎都已经有了一定的推理能力。比如：<br><img src="https://voyager-m.gitee.io/picgo/test/102419.png"></p><p><img src="https://voyager-m.gitee.io/picgo/test/102420.png"></p><p><strong>基于描述逻辑的推理：本体推理</strong>：</p><p>描述逻辑：描述逻辑（decription logic）是一种用只是表示的逻辑语言和以其为对象的推理方法，主要用于描述概念分类及其概念之间的关系。描述逻辑是当前语义网发展中本体的理论基础。</p><p>主要方法：</p><p>（1）基于表运算（Tableaux）及改进的方法：FaCT++，Racer，Pellet Hermit等</p><p>（2）基于一阶查询重写的方法（Ontology based data acess，基于本体的数据访问）</p><p>（3）基于产生式规则的算法（如KAON、RDFox等）。</p><p>（4）回答集程序 Answer set programming</p><p><strong>基于统计规则挖掘的推理</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102421.png"></p><p><strong>基于表示学习的推理-Representational Learning</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102422.png"></p><h3 id="知识融合"><a href="#知识融合" class="headerlink" title="知识融合"></a>知识融合</h3><p>知识融合有一些其它叫法: Record Linkage，Entity Resolution，DataLinking，Knowledge Fusion，Entity Alignment.. . . . .<br>都是指在不同数据集中找出同一个实体的描述记录，主要目的是对不同数据源中的实体信息进行整合，形成更加全面的实体信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102423.png"></p><p>我们来用上图这个例子通俗一点来说一说什么叫知识融合，上图中下面一层的头像有7个，但是上面一层的头像只有2个，是因为下面一层的头像都是由上面两个头像戴上眼镜，假发等而来，所以我们只需要抓住上面两个头像进行处理就行了。<br>这就好比说，“洋芋、荷兰薯、地蛋、薯仔、土豆、荷兰薯、番仔薯、马铃薯”都指的是一个东西，知识融合要做的就是将这8个别名融合成一个名称。</p><h3 id="知识众包"><a href="#知识众包" class="headerlink" title="知识众包"></a>知识众包</h3><p>这个概念通俗的讲就是允许网站基于一定的方式，比如RDFa，JASON-LD等方式在网页和邮件等数据中嵌入语义化的数据，让个人和企业定制自己需要的知识图谱信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102424.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102425.png"></p><p>特别感谢：<br>上海交大的王昊奋博士的教程和东南大学漆桂林教授的文章以及其他资源的作者。</p><p>在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。<br>个人qq:1518887260</p><p>整理于2020年10月24日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-汽车品牌知识图谱实战复现记录</title>
      <link href="posts/45c0910/"/>
      <url>posts/45c0910/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>写在前面</strong>：本人也是知识图谱“小白”，正在努力变“怪兽”，写文只为记录成长点滴，若有理解不合理亦或不到位的地方，敬请谅解。</p><h2 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102701.png"></p><p>这里环境配置还是有一些点需要注意的：</p><p>（1）若python版本是3.8以及以上的话是不支持time.clock()这个函数的，需要把这个函数换成time.perf_counter().若不想麻烦，可以考虑将电脑装两个版本的python。</p><p>（2）py2neo的版本不能低于4.0.0，因为4.0.0版本是个分界线，3.x和4.x接口的区别有点大，所以版本必须对应，不然后续会出现一系列问题。</p><p>（3）Neo4j-driver接口为了和前面版本对应应该安装1.6.1版本。</p><h2 id="2、业务需求分析"><a href="#2、业务需求分析" class="headerlink" title="2、业务需求分析"></a>2、业务需求分析</h2><p>基于搜索引擎的商业数据分析：</p><p>（1）行业分析：整体市场趋势、细分市场趋势</p><p>用户会不断搜索关于汽车某方面的信息，可能是通过品牌搜索，可能是通过车型等等，通过用户的这些行为找出整体的市场趋势，以及细分市场的分析。</p><p>（2）品牌分析：品牌市场份额、品牌粘性、品牌游离度</p><p>用户都在搜什么品牌，搜A品牌的用户又去搜了B品牌（为什么？），用户在搜索这个品牌的时候有没有什么持续性。。</p><p>（3）车系分析：车系市场份额、车系粘性、车系游离度</p><p>（4）车型分析：车型市场份额、车型粘性、车型游离度</p><p>（5）话题分析：热点排行、话题排行</p><p>（6）用户画像：自然属性分析、兴趣属性分布</p><p>我们来看几个例子咯：<br><img src="https://voyager-m.gitee.io/picgo/test/102702.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102703.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102704.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102705.png"></p><h2 id="3、项目总体框架设计"><a href="#3、项目总体框架设计" class="headerlink" title="3、项目总体框架设计"></a>3、项目总体框架设计</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102706.png"></p><p>项目分为应用层，业务层，数据层，ETL，数据源。</p><p><strong>数据源：</strong>一般获取渠道可以是汽车资讯网站、汽车电商平台、百科问答汽车频道、汽车投书平台。可以使用爬虫技术进行爬取，但要注意的是只能爬取网页公开的数据，遵守法律法规，做良好市民。（否者：爬虫写的好，牢饭吃的早）。</p><p><strong>ETL：</strong>这部分先通过爬虫框架scrapyEx爬取数据，然后经过页面目录管理、页面元素解析、动态页面渲染、页面内容解析、数据清洗转换、批量任务调度，使结点数据结构化和关系数据结构化。</p><p><strong>数据层：</strong>这一层我们首先要将数据导入到neo4j数据库，有两种方式，一种是Neo4j-import,另一种是Neo4j-Web控制台指令导入。这里我比较推荐第二种，因为指令可以让你非常清晰数据源的属性与生成结点或者关系之间的映射关系。</p><p><strong>业务层：</strong>通过py2neo开发框架将数据库与后台联系。然后pythonWeb实现实体识别，节点查询，关系查询，路径计算，上层用Django框架与前端连接，为用户提供交互窗口。</p><p><strong>应用层：</strong>这里主要是该框架的一些应用，比如只能搜索，智能问答，智能推荐等。</p><h2 id="4、知识图谱设计方法论"><a href="#4、知识图谱设计方法论" class="headerlink" title="4、知识图谱设计方法论"></a>4、知识图谱设计方法论</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102707.png"></p><p>专家法要求参与的人员经验很多，对业务非常熟悉。从上到下，总体规划。</p><p>参照法是以行业标准为参照来进行设计，在设计过程中不断修补裁剪。</p><p>归纳法是由技术过硬的专家来进行的，一般是自下向上，从一个点切入来设计的。</p><p>混合发是从上自下，从下自上同时进行，在中电处进行调整。</p><h2 id="5、数据导入："><a href="#5、数据导入：" class="headerlink" title="5、数据导入："></a>5、数据导入：</h2><div class="note success simple"><p>数据源必须为utf-8编码，不然结果会乱码。</p><p>修改为utf-8编码办法：笔记本打开csv文件，保存为UTF-8格式</p></div><p>&emsp;&emsp;</p><p>打开%NEO4J_HOME%\conf\neo4j.conf</p><p>将#dbms.connectors.default_listen_address=0.0.0.0的#去掉</p><p>&emsp;</p><p>进入 cmd控制台输入指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现下图：<br><img src="https://voyager-m.gitee.io/picgo/test/102708.png"></p><p>打开浏览器访问<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>然后输入数据库用户名和密码（初始密码都是neo4j），登录后也可以自己修改密码，出现如下界面：<br><img src="https://voyager-m.gitee.io/picgo/test/102709.png"></p><p>&emsp;&emsp;</p><p>打开cmd窗扣进入neo4j文件的bin目录下执行以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j-admin import --mode=csv --database=graph.db --nodes ..\import\bank01.csv </span><br></pre></td></tr></table></figure><p>我们就完成了数据的导入，下面我们就可以开始创建结点了。</p><h2 id="6、结点与关系创建"><a href="#6、结点与关系创建" class="headerlink" title="6、结点与关系创建"></a>6、结点与关系创建</h2><p>创建汽车品牌结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;bank01.csv&quot; AS line</span><br><span class="line">CREATE(:Car&#123;name:line.bank,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102710.png"></p><p>&emsp;&emsp;</p><p>创建汽车车系结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">CREATE(p:Serise&#123;name:line.serise,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102711.png"></p><p>&emsp;&emsp;</p><p>创建关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">MATCH (entity1:Car&#123;name:line.bank&#125;),(entity2:Serise&#123;name:line.serise&#125;)</span><br><span class="line">CREATE(entity1)-[:Subtype&#123;type:line.relation&#125;]-&gt;(entity2)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102712.png"></p><p>&emsp;&emsp;</p><p>指定唯一键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE  CONSTRAINT ON (b:Car)</span><br><span class="line">ASSERT b.name IS UNIQUE</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102713.png"></p><p>&emsp;&emsp;</p><p>至此，我们完成了206个品牌结点，1921个车系结点，1937个关系的导入</p><p>来看看界面吧：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102714.png"><br>汽车品牌结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102715.png"><br>汽车车系结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102716.png"><br>2127个车系，206个汽车品牌，1921个关系都展现出来了，是不是很壮观呢，哈哈哈哈<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102717.png"><br>来个清晰的</p><h2 id="7、前端界面展示"><a href="#7、前端界面展示" class="headerlink" title="7、前端界面展示"></a>7、前端界面展示</h2><div class="note success simple"><p>先关闭酷狗，因为酷狗会占用“<a href="http://127.0.0.1:8000/%E2%80%9D%E8%BF%99%E4%B8%AA%E7%AB%AF%E5%8F%A3">http://127.0.0.1:8000/”这个端口</a></p></div><p>&emsp;&emsp;</p><p>修改neo4j_models.py中的密码，name和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def connectDB(self):</span><br><span class="line">self.graph &#x3D; Graph(&quot;bolt: &#x2F;&#x2F; localhost:7687&quot;, username&#x3D;&quot;neo4j&quot;, password&#x3D;&quot;admin&quot;)</span><br><span class="line">self.matcher &#x3D; NodeMatcher(self.graph)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口执行如下指令保证数据库服务是开着的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口进入kgcar项目目录下运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>功能界面如下：<br><img src="https://voyager-m.gitee.io/picgo/test/102718.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102719.png"></p><p>&emsp;&emsp;</p><p>对不起，这个例子我举的有点飘了，哈哈哈哈</p><p>特别感谢：张子良老师的知识图谱教程</p><p>整理于2020年10月27日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地项目上传gitee/github</title>
      <link href="posts/c37fef3/"/>
      <url>posts/c37fef3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="在gitee-github上创建一个空的仓库（假如为demo）"><a href="#在gitee-github上创建一个空的仓库（假如为demo）" class="headerlink" title="在gitee/github上创建一个空的仓库（假如为demo）"></a>在gitee/github上创建一个空的仓库（假如为demo）</h3><h3 id="在本地新建一个空文件夹（假如叫gitee）"><a href="#在本地新建一个空文件夹（假如叫gitee）" class="headerlink" title="在本地新建一个空文件夹（假如叫gitee）"></a>在本地新建一个空文件夹（假如叫gitee）</h3><h3 id="在demo文件夹下执行指令"><a href="#在demo文件夹下执行指令" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 你的https仓库地址</span><br></pre></td></tr></table></figure><h3 id="在gitee文件夹下面执行指令"><a href="#在gitee文件夹下面执行指令" class="headerlink" title="在gitee文件夹下面执行指令"></a>在gitee文件夹下面执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h3 id="将需要上传的项目复制到仓库demo文件夹下"><a href="#将需要上传的项目复制到仓库demo文件夹下" class="headerlink" title="将需要上传的项目复制到仓库demo文件夹下"></a>将需要上传的项目复制到仓库demo文件夹下</h3><h3 id="在demo文件夹下执行指令-1"><a href="#在demo文件夹下执行指令-1" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commt -m &#x27;这里随便写&#x27;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure><h3 id="这里的add-中的-的意思是本文件夹下面的全部文件"><a href="#这里的add-中的-的意思是本文件夹下面的全部文件" class="headerlink" title="这里的add .中的.的意思是本文件夹下面的全部文件"></a>这里的add .中的.的意思是本文件夹下面的全部文件</h3>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo从一台电脑转移至另一台电脑</title>
      <link href="posts/a17e1e97/"/>
      <url>posts/a17e1e97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"><a href="#前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！" class="headerlink" title="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"></a>前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！</h3><h3 id="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："><a href="#既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：" class="headerlink" title="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："></a>既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：</h3><h2 id="第一步：将旧电脑的文件拷贝在新电脑上"><a href="#第一步：将旧电脑的文件拷贝在新电脑上" class="headerlink" title="第一步：将旧电脑的文件拷贝在新电脑上"></a>第一步：将旧电脑的文件拷贝在新电脑上</h2><h3 id="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"><a href="#比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统" class="headerlink" title="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"></a>比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EyqtU.png" alt="创建文件夹"></p><h3 id="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"><a href="#将原来电脑上的blog和globle拷贝到Hexo文件夹下面" class="headerlink" title="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"></a>将原来电脑上的blog和globle拷贝到Hexo文件夹下面</h3><h3 id="建立Git和node两个空文件夹用来安装Gitbash和Node"><a href="#建立Git和node两个空文件夹用来安装Gitbash和Node" class="headerlink" title="建立Git和node两个空文件夹用来安装Gitbash和Node"></a>建立Git和node两个空文件夹用来安装Gitbash和Node</h3><h2 id="第二步：在新电脑上安装Git-Bash和Node"><a href="#第二步：在新电脑上安装Git-Bash和Node" class="headerlink" title="第二步：在新电脑上安装Git Bash和Node"></a>第二步：在新电脑上安装Git Bash和Node</h2><h3 id="Git-Bash-的下载地址"><a href="#Git-Bash-的下载地址" class="headerlink" title="Git Bash 的下载地址"></a><a href="https://www.git-scm.com/download/win">Git Bash 的下载地址</a></h3><h3 id="Node-的下载地址"><a href="#Node-的下载地址" class="headerlink" title="Node 的下载地址"></a><a href="https://nodejs.org/en/">Node 的下载地址</a></h3><h3 id="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"><a href="#这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹" class="headerlink" title="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"></a>这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹</h3><h3 id="然后全程无脑下一步安装就行了"><a href="#然后全程无脑下一步安装就行了" class="headerlink" title="然后全程无脑下一步安装就行了"></a>然后全程无脑下一步安装就行了</h3><div class="note danger simple"><p>这里特别要注意，Node安装的版本要和你原本电脑上安装的Node版本要一样，不然就会出问题的</p></div><h3 id="安装完成后我们打开按win-R-输入cmd打开控制台"><a href="#安装完成后我们打开按win-R-输入cmd打开控制台" class="headerlink" title="安装完成后我们打开按win+R 输入cmd打开控制台"></a>安装完成后我们打开按win+R 输入cmd打开控制台</h3><p><img src="https://s1.ax1x.com/2020/09/28/0E0JjP.png" alt="打开cmd"></p><h3 id="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"><a href="#输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）" class="headerlink" title="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"></a>输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EsOsI.png" alt="查看gitbash和node版本"></p><h2 id="第三步：环境配置"><a href="#第三步：环境配置" class="headerlink" title="第三步：环境配置"></a>第三步：环境配置</h2><h3 id="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）"><a href="#首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）" class="headerlink" title="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）"></a>首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）</h3><h3 id="启动cmd命令输入下下面的指令："><a href="#启动cmd命令输入下下面的指令：" class="headerlink" title="启动cmd命令输入下下面的指令："></a>启动cmd命令输入下下面的指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;C:\Hexo\globle&quot;</span><br><span class="line">npm config set cache &quot;C:\Hexo\globle&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开系统环境变量配置："><a href="#然后打开系统环境变量配置：" class="headerlink" title="然后打开系统环境变量配置："></a>然后打开系统环境变量配置：</h3><h3 id="此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量"><a href="#此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量" class="headerlink" title="此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量"></a>此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量</h3><h3 id="进入如下界面："><a href="#进入如下界面：" class="headerlink" title="进入如下界面："></a>进入如下界面：</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EgB6J.png" alt="环境变量"></p><h3 id="双击path进入如下界面"><a href="#双击path进入如下界面" class="headerlink" title="双击path进入如下界面"></a>双击path进入如下界面</h3><p><img src="https://s1.ax1x.com/2020/09/28/0Eg0l4.png" alt="新建环境变量"></p><h3 id="点击新建然后填写globle的地址，点击确定，完成环境配置"><a href="#点击新建然后填写globle的地址，点击确定，完成环境配置" class="headerlink" title="点击新建然后填写globle的地址，点击确定，完成环境配置"></a>点击新建然后填写globle的地址，点击确定，完成环境配置</h3><h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><h3 id="打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令："><a href="#打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令：" class="headerlink" title="打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令："></a>打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure><h3 id="用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功"><a href="#用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功" class="headerlink" title="用浏览器打开http://localhost:4000 得到如下自己的博客首页就说明本地能测试成功"></a>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a> 得到如下自己的博客首页就说明本地能测试成功</h3><p><img src="https://s1.ax1x.com/2020/09/28/0ERLQg.png" alt="页面"></p><h3 id="执行以下指令（自己的邮箱）"><a href="#执行以下指令（自己的邮箱）" class="headerlink" title="执行以下指令（自己的邮箱）"></a>执行以下指令（自己的邮箱）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"><a href="#然后打开这个文件复制里面内容添加到gitee和github上的ssh上去" class="headerlink" title="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"></a>然后打开这个文件复制里面内容添加到gitee和github上的ssh上去</h3><p><img src="https://voyager-m.gitee.io/picgo/test/hexo1.png"></p><h3 id="其中gitee和github的用户名和密码放在下图中的位置"><a href="#其中gitee和github的用户名和密码放在下图中的位置" class="headerlink" title="其中gitee和github的用户名和密码放在下图中的位置"></a>其中gitee和github的用户名和密码放在下图中的位置</h3><p><img src="https://s1.ax1x.com/2020/09/28/0VpTkq.png"></p><h3 id="在cmd中执行如下指令"><a href="#在cmd中执行如下指令" class="headerlink" title="在cmd中执行如下指令"></a>在cmd中执行如下指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure><h3 id="在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。"><a href="#在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。" class="headerlink" title="在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。"></a>在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。</h3><h4 id="特别感谢："><a href="#特别感谢：" class="headerlink" title="特别感谢："></a>特别感谢：</h4><p><a href="https://space.bilibili.com/393128277/video">博客搭建</a><br><a href="https://dreamer-liuyang.github.io/posts/4c70a442/">搭建文章版</a><br><a href="https://dreamer-liuyang.github.io/posts/d579f5f8/">美化文章版</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛维杨的第一篇文章</title>
      <link href="posts/fbf6b9c0/"/>
      <url>posts/fbf6b9c0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="你好呀！在下毛同学"><a href="#你好呀！在下毛同学" class="headerlink" title="你好呀！在下毛同学"></a>你好呀！在下毛同学</h1><h1 id="家穷人丑，一米四九"><a href="#家穷人丑，一米四九" class="headerlink" title="家穷人丑，一米四九"></a>家穷人丑，一米四九</h1><h1 id="小学文化，农村户口"><a href="#小学文化，农村户口" class="headerlink" title="小学文化，农村户口"></a>小学文化，农村户口</h1><h1 id="破屋三间，薄田一亩"><a href="#破屋三间，薄田一亩" class="headerlink" title="破屋三间，薄田一亩"></a>破屋三间，薄田一亩</h1><h1 id="冷锅热灶，钱财没有"><a href="#冷锅热灶，钱财没有" class="headerlink" title="冷锅热灶，钱财没有"></a>冷锅热灶，钱财没有</h1><h1 id="一年四季，苦学编程"><a href="#一年四季，苦学编程" class="headerlink" title="一年四季，苦学编程"></a>一年四季，苦学编程</h1><h1 id="今创博客，写下此篇"><a href="#今创博客，写下此篇" class="headerlink" title="今创博客，写下此篇"></a>今创博客，写下此篇</h1><h1 id="学习路上，伴你身边"><a href="#学习路上，伴你身边" class="headerlink" title="学习路上，伴你身边"></a>学习路上，伴你身边</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;既来不留良言三句？&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note success simple"><p>文献提示：评论需要填写昵称和邮箱哦！</p></div>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
