<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode-排序-选择排序</title>
      <link href="posts/35af54d9/"/>
      <url>posts/35af54d9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用通俗的语言来讲，选择排序，就是将数列中最大（小）的数找出来，放到合适的位置，然后在剩下的集合里面继续找最大（小）的数放在合适的位置，如此往复，直到整个数列变为有序位置。与冒泡排序不一样的是，它不是比较相邻的两个数，而是比较某个数与数列中剩下所有数的大小。</p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>原始数列为：</p><pre><code>7 3 5 1 9 4</code></pre><p>第一轮排序首先以第一个数为基数，与剩下的所有数进行比较，找到整个数列中最小的数，然后交换最小数与第一个数的位置。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(iList)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[j] &lt;=iLIST[minIndex]:</span><br><span class="line">            minIdex = j</span><br></pre></td></tr></table></figure><p>以上排序过程会将第i+1（i从0开始）大的数放在数列下标为i的位置，那么第一次排序的结果为：</p><pre><code>1 3 5 7 9 4</code></pre><h2 id="2-第二轮排序："><a href="#2-第二轮排序：" class="headerlink" title="2.第二轮排序："></a>2.第二轮排序：</h2><pre><code>1 3 5 7 9 4</code></pre><h2 id="3-第三轮排序："><a href="#3-第三轮排序：" class="headerlink" title="3.第三轮排序："></a>3.第三轮排序：</h2><pre><code>1 3 4 7 9 5</code></pre><h2 id="4-第四轮排序："><a href="#4-第四轮排序：" class="headerlink" title="4.第四轮排序："></a>4.第四轮排序：</h2><pre><code>1 3 4 5 9 7</code></pre><h2 id="5-第五轮排序："><a href="#5-第五轮排序：" class="headerlink" title="5.第五轮排序："></a>5.第五轮排序：</h2><pre><code>1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList  <span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> iList[i] != min(iList[i:]):  <span class="comment"># 判断当前元素是不是从当前元素开始的剩下所有元素中最小的</span></span><br><span class="line">            minIndex = iList.index(min(iList[i:]))  <span class="comment"># 将从当前元素开始的剩下所有元素中最小的元素索引复制给minIndex</span></span><br><span class="line">            iList[i], iList[minIndex] = iList[minIndex], iList[i]<span class="comment">#交换当前元素和最小元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(selectionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;selectionSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import selectionSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用此算法排序100次所花时间</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月14</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-1-知名编程语言或系统的发展简史</title>
      <link href="posts/a7360fd9/"/>
      <url>posts/a7360fd9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="知名编程语言或系统的发展简史"><a href="#知名编程语言或系统的发展简史" class="headerlink" title="知名编程语言或系统的发展简史"></a>知名编程语言或系统的发展简史</h1><h2 id="一、B语言"><a href="#一、B语言" class="headerlink" title="一、B语言"></a>一、B语言</h2><p>B语言之父：Ken Thompson（肯.汤普森）。B语言是贝尔实验室开发的一种通用的程序设计语言，它是于1969年前后Ken Thompson（肯.汤普森）在Dennis Ritchie丹尼斯.里奇（Dennis Ritchie）的支持下设计出来。该语言得名于汤姆森的妻子Bonnie，它是一门开发于60年代中期的语言，现在使用者已经很少了。</p><p><img src="https://voyager-m.gitee.io/picgo/test/01.jpg" alt="Ken Thompson"></p><h2 id="二、C语言"><a href="#二、C语言" class="headerlink" title="二、C语言"></a>二、C语言</h2><p>C语言之父：Dennis Ritchie（丹尼斯·里奇）。美国著名计算机专家、C语言发明人、UNIX之父。在1969-1973年期间发明了C语言和Unix操作系统。</p><p>到了70年代，诞生了一门非常重要的语言，这就是今天的大名鼎鼎的C语言。而C语言之父是美国著名的计算机专家。丹尼斯.利奇。<br>在开发C语言的时候其实是以B语言为基础。之所以发明C语言，实际上是因为这两个人，刚刚的B语言之父肯.汤普森和丹尼斯.里奇，一块写了一个操作系统，就是Unix系统。在写Unix系统的过程中，需要一种便利的语言，而B语言又达不到这个要求，所以丹尼斯.里奇就在B语言上进行改造，发明了C语言。目前 C语言是世界上最常用的程序语言之一。自从被C语言取代之后，B语言几乎已遭弃置。</p><p><img src="https://voyager-m.gitee.io/picgo/test/02.jpg" alt="dannis"></p><h2 id="三、Unix系统"><a href="#三、Unix系统" class="headerlink" title="三、Unix系统"></a>三、Unix系统</h2><p>Unix之父：Dennis Ritchie（丹尼斯·里奇）及Ken Thompson（肯.汤普森）</p><p>提到C语言就不得不说一下Unix系统。而Unix之父，自然就是这两个人，左侧这个是B语言之父肯汤姆森。右侧这个是C语言之父丹尼斯.里奇。有意思的是，肯.汤普森当年开发 Unix的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，Unix 诞生了。英文中的前缀 Uni 是小的意思，小而且巧。这是 Unix 的设计初衷，这个理念也一直影响至今。<br>因为他们俩在1973年左右的时候发明了Unix操作系统，也因此获得了1983年的图灵大奖。这个奖项就相当于IT行业的诺贝尔奖。</p><p><img src="https://voyager-m.gitee.io/picgo/test/03.png" alt="WX20190322-173439"></p><h2 id="四、C-语言"><a href="#四、C-语言" class="headerlink" title="四、C++语言"></a>四、C++语言</h2><p>C++之父：Bjarne Stroustrup（本贾尼·斯特劳斯特卢普）。1982年，美国贝尔实验室的Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了—种新的程序语言。为了表达该语言与c语言的渊源关系，它被命名为C++。</p><p><img src="https://voyager-m.gitee.io/picgo/test/04.jpg" alt="Bjarne Stroustrup"></p><h2 id="五、Python语言"><a href="#五、Python语言" class="headerlink" title="五、Python语言"></a>五、Python语言</h2><p>Python之父：Guido van Rossum（吉多.范.罗苏姆）。1989年，为了打发圣诞节假期，Guido开始写Python语言的编译/解释器。1994年发布1.0版本。1995年9月发布了Python3.5版。</p><p>python语言的理念就是：人生苦短，我用python。吉多推崇的是简洁，大方，美观，精致。吉多一直认为python是一门很优秀的语言，实际上python也确实是可以做各个行业，无论是web开发，还是服务器端维护，还有爬虫等等，但是在每个方向上都没有做到最精，所以在某些地方没有得到很大的体现。但是吉多一直认为酒香不怕巷子深，所以也没有大力的宣传。但是近几年随着人工智能也被大众所熟知。</p><p><img src="https://voyager-m.gitee.io/picgo/test/05.png" alt="Guido van Rossum"></p><h2 id="六、Java语言"><a href="#六、Java语言" class="headerlink" title="六、Java语言"></a>六、Java语言</h2><p>Java之父是James Gosling（詹姆斯.高斯林）。1991年开发Oak，1994年更名为Java。1995年5月正式发布。</p><p>实际上python比java的产生还要更早一点。java的出现，正是互联网大力兴起的时候，而java因为语言的特性，在互联网上有很大的优势，发布最初就异常火爆，掩盖住了python的势头。java最初的模型是在1991年的时候开发出，他的创始人詹姆斯高斯林。那个时候还叫做Oak橡树，后来詹姆斯希望使用java语言可以像喝咖啡一样轻松，愉悦。改名为java。</p><p><img src="https://voyager-m.gitee.io/picgo/test/06.jpg" alt="James Gosling"></p><h2 id="七、JavaScript语言"><a href="#七、JavaScript语言" class="headerlink" title="七、JavaScript语言"></a>七、JavaScript语言</h2><p>Javascript之父是Brendan Eich（布兰登.艾奇)。JavaScript，是一门运行在浏览器端的脚本语言。这门语言是由网景公司在1995年发布的。当时网景公司主要是做浏览器方面，他们想把java语言应用在浏览器端，能够实现一些比如用户登录并验证的工作。招聘了一个新员工，叫做布兰登.艾奇，布兰登对java没有兴趣，为了应付公司的任务，只用了10天时间就设计出了JavaScript这门语言。但是JavaScript发展至今，随着前端开发异常的火爆，它已经是浏览器端的龙头语言了。</p><p><img src="https://voyager-m.gitee.io/picgo/test/07.jpg" alt="Brendan Eich"></p><p>8、Golang：Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默）</p><p><img src="https://voyager-m.gitee.io/picgo/test/08.jpg" alt="aa"></p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-2-go语言的前世今生</title>
      <link href="posts/13ea5c5d/"/>
      <url>posts/13ea5c5d/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言的前世今生"><a href="#Go语言的前世今生" class="headerlink" title="Go语言的前世今生"></a>Go语言的前世今生</h1><p><img src="https://voyager-m.gitee.io/picgo/test/go_logo.jpg" alt="go_logo"></p><h2 id="一、-为什么需要一个新的语言"><a href="#一、-为什么需要一个新的语言" class="headerlink" title="一、 为什么需要一个新的语言"></a>一、 为什么需要一个新的语言</h2><p>最近十年来，C/C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了。</p><blockquote><p>传统的语言比如c++，大家花费太多时间来学习如何使用这门语言，而不是如何更好的表达写作者的思想，同时编译花费的时间实在太长，对于编写-编译-运行这个链条来说周期太长。动态语言如Python，由于没有强类型的约束，很多问题需要在运行时发现，这种低级错误更应该交给编译器来发现。</p></blockquote><ul><li><p>人力成本越来越高</p></li><li><p>机器越来越便宜</p></li><li><p>机器的性能越来越厉害</p></li><li><p>在开发效率和运行速度上达到平衡</p></li></ul><p>go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。</p><blockquote><p>执行效率 execution speed：  C/C++    &gt;  Java   &gt;  PHP<br>开发效率 developing efficiency：  PHP   &gt;  Java  &gt;  C/C++</p></blockquote><h2 id="二、-谷歌工程师的20-时间"><a href="#二、-谷歌工程师的20-时间" class="headerlink" title="二、 谷歌工程师的20%时间"></a>二、 谷歌工程师的20%时间</h2><p>谷歌的“20%时间”工作方式，允许工程师拿出20%的时间来研究自己喜欢的项目。语音服务Google Now、谷歌新闻Google News、谷歌地图Google Map上的交通信息等，全都是20%时间的产物。</p><p>Go语言最开始也是20%时间的产物。</p><h2 id="三、-创始人"><a href="#三、-创始人" class="headerlink" title="三、 创始人"></a>三、 创始人</h2><p>Go的三个作者分别是： Rob Pike（罗伯.派克），Ken Thompson（肯.汤普森）和Robert Griesemer（罗伯特.格利茨默） 。</p><ul><li><p>Rob Pike：曾是贝尔实验室（Bell Labs）的Unix团队，和Plan 9操作系统计划的成员。他与Thompson共事多年，并共创出广泛使用的UTF-8 字元编码。</p></li><li><p>Ken Thompson：主要是B语言、C语言的作者、Unix之父。1983年图灵奖（Turing Award）和1998年美国国家技术奖（National Medal of Technology）得主。他与Dennis Ritchie是Unix的原创者。Thompson也发明了后来衍生出C语言的B程序语言。</p></li><li><p>Robert Griesemer：在开发Go之前是Google V8、Chubby和HotSpot JVM的主要贡献者。</p></li></ul><p><img src="https://voyager-m.gitee.io/picgo/test/aa.jpg" alt="aa"></p><blockquote><p>此外还有Plan 9开发者Russ Cox、和曾改善目前广泛使用之开原码编译器GCC的Ian Taylor。</p></blockquote><h2 id="四、-Go的缔造与发展"><a href="#四、-Go的缔造与发展" class="headerlink" title="四、 Go的缔造与发展"></a>四、 Go的缔造与发展</h2><h3 id="4-1-Go的命名"><a href="#4-1-Go的命名" class="headerlink" title="4.1 Go的命名"></a>4.1 Go的命名</h3><p><img src="https://voyager-m.gitee.io/picgo/test/mail1.jpg" alt="mail1"></p><p>这是一封由 Rob Pike 在 2007 年 9 月 25 号，星期二，下午 3：12 回复给 Robert Griesemer、Ken Thompson 的有关编程语言讨论主题的邮件，邮件正文大意为：在开车回家的路上我得到了些灵感。1.给这门编程语言取名为“go”，它很简短，易书写。工具类可以命名为：goc、 gol、goa。交互式的调试工具也可以直接命名为“go”。语言文件后缀名为 .go 等等</p><p>这就是 Go 语言名字的来源，自此之后 Robert、Rob 和 Ken 三个人开始在 Google 内部进行了研发，一直到了 2009 年，Go 正式开源了，Go 项目团队将 2009 年 11 月 10 日，即该语言正式对外开源的日字作为其官方生日。源代码最初托管在 <a href="http://link.zhihu.com/?target=http://code.google.com">http://code.google.com</a> 上，之后几年才逐步的迁移到 GitHub 上。</p><h3 id="4-2-Go的发展过程中的记事"><a href="#4-2-Go的发展过程中的记事" class="headerlink" title="4.2 Go的发展过程中的记事"></a>4.2 Go的发展过程中的记事</h3><p><strong>第一个事情是在开发设计 Go 语言过程中的第一个重大惊喜是收到了以下这封邮件：</strong></p><p><img src="https://voyager-m.gitee.io/picgo/test/mail2.jpg" alt="mail2"></p><p>这是一封由 Ian Lance Taylor 在 2008 年 6月 7 日（星期六）的晚上 7：06 写给 Robert Griesemer、Rob Pike、 Ken Thompson 的关于 Go gcc 编译器前端的邮件。邮件正文大意如下：我的同事向我推荐了这个网站 http://…/go_lang.html 。这似乎是一门很有趣的编程语言。我为它写了一个 gcc 编译器前端。虽然这个工具仍缺少很多的功能，但它确实可以编译网站上展示的那个素数筛选程序了。</p><p>Ian Lance Taylor 的加入以及第二个编译器 (gcc go) 的实现 在带来震惊的同时，也伴随着喜悦。这对 Go 项目来说不仅仅是鼓励，更是一种对可行性的证明。语言的第二次实现对制定语言规范和确定标准库的过程至关重要，同时也有助于保证其高可移植性，这也是 Go 语言承诺的一部分。自此之后 Ian Lance Taylor 成为了设计和实现 Go 语言及其工具的核心人物。</p><p><strong>第二件事情是 Russ Cox 在2008年带着他的语言设计天赋和编程技巧加入了刚成立不久的 Go 团队。</strong>Russ 发现 Go 方法的通用性意味着函数也能拥有自己的方法，这直接促成了 <strong>http.HandlerFunc</strong> 的实现，这是一个让 Go 一下子变得无限可能的特性。Russ 还提出了更多的泛化性的想法，比如 io.Reader 和 io.Writer 接口，奠定了所有 I/O 库的整体结构。</p><p><strong>第三件事情是聘请了安全专家 Adam Langley 帮助 Go 走向 Google 外面的世界。</strong>Adam 为 Go 团队做了许多不为外人知晓的工作，包括创建最初的 <strong><a href="http://golang.org/">http://golang.org</a></strong> 网站以及 <strong>build dashboard</strong>。不过他最大的贡献当属创建了 cryptographic 库。起先，在我们中的部分人看来，这个库无论在规模还是复杂度上都不成气候。但是就是这个库在后期成为了很多重要的网络和安全软件的基础，并且成为了 Go 语言开发历史的关键组成部分。许多网络基础设施公司，比如 <strong>Cloudflare</strong>，均重度依赖 Adam 在 Go 项目上的工作，互联网也因它变得更好。我记得当初 beego 设计的时候，session 模块设计的时候也得到了 Adam 的很多建议，因此，就 Go 而言，我们由衷地感谢 Adam。</p><p><strong>第四个事情就是一家叫做 Docker 的公司。</strong>就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。</p><p><img src="https://voyager-m.gitee.io/picgo/test/1641730da1fe6861.jpg" alt="1641730da1fe6861"></p><p>除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。除此之外，还有各种有名的项目，如etcd/consul/flannel，七牛云存储等等<br>均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。</p><p>除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p><h2 id="五、Go语言logo和版本"><a href="#五、Go语言logo和版本" class="headerlink" title="五、Go语言logo和版本"></a>五、Go语言logo和版本</h2><h2 id="1、-Go的logo"><a href="#1、-Go的logo" class="headerlink" title="1、 Go的logo"></a>1、 Go的logo</h2><h3 id="1-1-Go语言的logo"><a href="#1-1-Go语言的logo" class="headerlink" title="1.1 Go语言的logo"></a>1.1 Go语言的logo</h3><p><img src="https://voyager-m.gitee.io/picgo/test/go_logo_meitu_1.jpg" alt="go_logo_meitu_1"></p><p>Go语言的logo就是很简洁的GO两个字母。</p><h3 id="1-2-Go的吉祥物"><a href="#1-2-Go的吉祥物" class="headerlink" title="1.2 Go的吉祥物"></a>1.2 Go的吉祥物</h3><p><img src="https://voyager-m.gitee.io/picgo/test/go_logo2.jpeg" alt="go_logo2"></p><p>Go之所以叫Go，是想表达这门语言的运行速度、开发速度、学习速度（develop）都像gopher一样快。</p><p>gopher是一种生活在加拿大的小动物，go的吉祥物就是这个小动物， 它的中文名叫做囊地鼠，他们最大的特点就是挖洞速度特别快，当然可能不止是挖洞啦。</p><p><img src="https://voyager-m.gitee.io/picgo/test/tuboshu.jpeg" alt="tuboshu"></p><h2 id="2、Go的官网"><a href="#2、Go的官网" class="headerlink" title="2、Go的官网"></a>2、<a href="https://golang.google.cn/">Go的官网</a></h2><p><img src="https://voyager-m.gitee.io/picgo/test/goguanwang.png" alt="goguanwang"></p><h2 id="3、-Go语言主要发展过程"><a href="#3、-Go语言主要发展过程" class="headerlink" title="3、 Go语言主要发展过程"></a>3、 Go语言主要发展过程</h2><ul><li><p>2007年9月，雏形设计 ，Rob Pike（罗伯.派克） 正式命名为Go；</p></li><li><p>2008年5月，Google全力支持该项目；</p></li><li><p>2009年11月10日，首次公开发布，Go将代码全部开源，它获得了当年的年度语言；</p></li><li><p>2011年3月16日，Go语言的第一个稳定(stable)版本r56发布。</p></li><li><p>2012年3月28日，Go语言的第一个正式版本Go1发布。</p></li><li><p>2013年4月04日，Go语言的第一个Go 1.1beta1测试版发布。</p></li><li><p>2013年4月08日，Go语言的第二个Go 1.1beta2测试版发布。</p></li><li><p>2013年5月02日，Go语言Go 1.1RC1版发布。</p></li><li><p>2013年5月07日，Go语言Go 1.1RC2版发布。</p></li><li><p>2013年5月09日，Go语言Go 1.1RC3版发布。</p></li><li><p>2013年5月13日，Go语言Go 1.1正式版发布。</p></li><li><p>2013年9月20日，Go语言Go 1.2RC1版发布。</p></li><li><p>2013年12月1日，Go语言Go 1.2正式版发布。</p></li><li><p>2014年6月18日，Go语言Go 1.3版发布。</p></li><li><p>2014年12月10日，Go语言Go 1.4版发布。</p></li><li><p>2015年8月19日，Go语言Go 1.5版发布，本次更新中移除了”最后残余的C代码”。</p></li><li><p>2016年2月17日，Go语言Go 1.6版发布。</p></li><li><p>2016年8月15日，Go语言Go 1.7版发布。</p></li><li><p>2017年2月17日，Go语言Go 1.8版发布。</p></li><li><p>2017年8月24日，Go语言Go 1.9版发布。</p></li><li><p>2018年2月16日，Go语言Go 1.10版发布。</p></li><li><p>2018年8月24日，Go语言Go 1.11版发布。</p></li><li><p>2019年2月25日，GO语言Go1.12版发布。</p></li></ul><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。</p><p>其实可以看到，Go语言的历史不算很短。</p><p>2009年11月 GO语言第一个版本发布。2012年3月 第一个正式版本Go1.0发布。</p><p>2015年8月 go1.5发布，这个版本被认为是历史性的。完全移除C语言部分，使用GO编译GO，少量代码使用汇编实现。另外，他们请来了内存管理方面的权威专家Rick Hudson，对GC进行了重新设计，支持并发GC，解决了一直以来广为诟病的GC时延（STW）问题。并且在此后的版本中，又对GC做了更进一步的优化。到go1.8时，相同业务场景下的GC时延已经可以从go1.1的数秒，控制在1ms以内。GC问题的解决，可以说GO语言在服务端开发方面，几乎抹平了所有的弱点。</p><p>直到今年的2月25日，Go语言发布最新的版本是Go 1.12。</p><p>在GO语言的版本迭代过程中，语言特性基本上没有太大的变化，基本上维持在GO1.1的基准上，并且官方承诺，新版本对老版本下开发的代码完全兼容。事实上，GO开发团队在新增语言特性上显得非常谨慎，而在稳定性、编译速度、执行效率以及GC性能等方面进行了持续不断的优化。</p><blockquote><p>Go稳定版发布时，Go Team承诺后续的版本都会兼容之前的版本。这对于开发者来说非常重要，Go后续的版本也一直在提升内功，从而可以让用户无缝的升级Go版本。</p></blockquote><p><img src="https://voyager-m.gitee.io/picgo/test/image.png" alt="image"></p><h2 id="六、最后"><a href="#六、最后" class="headerlink" title="六、最后"></a>六、最后</h2><p>Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。<br>Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C / C++代码的速度，而且更加安全、支持并行进程。作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。<br>很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。<br>如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。</p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-3-go语言的核心特性</title>
      <link href="posts/fc72cfdc/"/>
      <url>posts/fc72cfdc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言的核心特性"><a href="#Go语言的核心特性" class="headerlink" title="Go语言的核心特性"></a>Go语言的核心特性</h1><p>Go语言，作为编程语言的后生，站在巨人的肩膀上，吸收了其他一些编程语言的特点。</p><p>Go 编程语言是一个开源项目，它使程序员更具生产力。Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。(摘取自官网)</p><h2 id="一、思想"><a href="#一、思想" class="headerlink" title="一、思想"></a>一、思想</h2><p>Less can be more</p><p>大道至简,小而蕴真</p><p>让事情变得复杂很容易，让事情变得简单才难</p><p>深刻的工程文化</p><h2 id="二、核心特性"><a href="#二、核心特性" class="headerlink" title="二、核心特性"></a>二、核心特性</h2><p>Go语言之所以厉害，是因为它在服务端的开发中，总能抓住程序员的痛点，以最直接、简单、高效、稳定的方式来解决问题。这里我们并不会深入讨论GO语言的具体语法，只会将语言中关键的、对简化编程具有重要意义的方面介绍给大家，体验Go的核心特性。</p><h3 id="2-1-并发编程"><a href="#2-1-并发编程" class="headerlink" title="2.1 并发编程"></a>2.1 并发编程</h3><p>Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。</p><p><img src="https://voyager-m.gitee.io/picgo/test/bingfa1.jpg" alt="bingfa1"></p><p>不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。</p><p>由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，golang的并发编程简单比并发性能更具卖点。</p><p>在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，而golang中实现协程间通讯有两种：1）共享内存型，即使用全局变量+mutex锁来实现数据共享；2）消息传递型，即使用一种独有的channel机制进行异步通讯。</p><p>对比JAVA的多线程和GO的协程实现，明显更直接、简单。这就是GO的魅力所在，以简单、高效的方式解决问题，关键字go，或许就是GO语言最重要的标志。</p><p><strong>高并发是Golang语言最大的亮点</strong></p><h3 id="2-2-内存回收-GC"><a href="#2-2-内存回收-GC" class="headerlink" title="2.2 内存回收(GC)"></a>2.2 内存回收(GC)</h3><p>从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。 </p><p>GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。</p><p>GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象，而slice或数组是一个对象，因此slice或数组有利于GC。</p><p>GC性能可能随着版本不断更新会不断优化，这块没仔细调研，团队中有HotSpot开发者，应该会借鉴jvm gc的设计思想，比如分代回收、safepoint等。</p><ul><li>内存自动回收，再也不需要开发人员管理内存</li><li>开发人员专注业务实现，降低了心智负担</li><li>只需要new分配内存，不需要释放</li></ul><h3 id="2-3-内存分配"><a href="#2-3-内存分配" class="headerlink" title="2.3 内存分配"></a>2.3 内存分配</h3><p>初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。空闲内存会按照一定策略合并，以减少碎片。</p><h3 id="2-4-编译"><a href="#2-4-编译" class="headerlink" title="2.4 编译"></a>2.4 编译</h3><p>编译涉及到两个问题：编译速度和依赖管理</p><p>目前Golang具有两种编译器，一种是建立在GCC基础上的Gccgo，另外一种是分别针对64位x64和32位x86计算机的一套编译器(6g和8g)。</p><p>依赖管理方面，由于golang绝大多数第三方开源库都在github上，在代码的import中加上对应的github路径就可以使用了，库会默认下载到工程的pkg目录下。</p><p>另外，编译时会默认检查代码中所有实体的使用情况，凡是没使用到的package或变量，都会编译不通过。这是golang挺严谨的一面。</p><h3 id="2-5-网络编程"><a href="#2-5-网络编程" class="headerlink" title="2.5 网络编程"></a>2.5 网络编程</h3><p>由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、rpc用client.Call(‘class_name.method_name’, args, &amp;reply)，等等。</p><blockquote><p>高性能HTTP Server</p></blockquote><h3 id="2-6-函数多返回值"><a href="#2-6-函数多返回值" class="headerlink" title="2.6 函数多返回值"></a>2.6 函数多返回值</h3><p>在C，C++中，包括其他的一些高级语言是不支持多个函数返回值的。但是这项功能又确实是需要的，所以在C语言中一般通过将返回值定义成一个结构体，或者通过函数的参数引用的形式进行返回。而在Go语言中，作为一种新型的语言，目标定位为强大的语言当然不能放弃对这一需求的满足，所以支持函数多返回值是必须的。</p><p>函数定义时可以在入参后面再加(a,b,c)，表示将有3个返回值a、b、c。这个特性在很多语言都有，比如python。</p><p>这个语法糖特性是有现实意义的，比如我们经常会要求接口返回一个三元组（errno,errmsg,data），在大多数只允许一个返回值的语言中，我们只能将三元组放入一个map或数组中返回，接收方还要写代码来检查返回值中包含了三元组，如果允许多返回值，则直接在函数定义层面上就做了强制，使代码更简洁安全。</p><h3 id="2-7-语言交互性"><a href="#2-7-语言交互性" class="headerlink" title="2.7 语言交互性"></a>2.7 语言交互性</h3><p>语言交互性指的是本语言是否能和其他语言交互，比如可以调用其他语言编译的库。</p><p>在Go语言中直接重用了大部份的C模块，这里称为Cgo.Cgo允许开发者混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上可以完全忽略这个Go语言和C语言的边界是如何跨越的。</p><p> golang可以和C程序交互，但不能和C++交互。可以有两种替代方案：1）先将c++编译成动态库，再由go调用一段c代码，c代码通过dlfcn库动态调用动态库（记得export LD_LIBRARY_PATH）；2）使用swig(没玩过)</p><h3 id="2-8-异常处理"><a href="#2-8-异常处理" class="headerlink" title="2.8 异常处理"></a>2.8 异常处理</h3><p>golang不支持try…catch这样的结构化的异常解决方式，因为觉得会增加代码量，且会被滥用，不管多小的异常都抛出。golang提倡的异常处理方式是：</p><ul><li>普通异常：被调用方返回error对象，调用方判断error对象。</li><li>严重异常：指的是中断性panic（比如除0），使用defer…recover…panic机制来捕获处理。严重异常一般由golang内部自动抛出，不需要用户主动抛出，避免传统try…catch写得到处都是的情况。当然，用户也可以使用panic(‘xxxx’)主动抛出，只是这样就使这一套机制退化成结构化异常机制了。</li></ul><h3 id="2-9-其他一些有趣的特性"><a href="#2-9-其他一些有趣的特性" class="headerlink" title="2.9 其他一些有趣的特性"></a>2.9 其他一些有趣的特性</h3><ul><li><p>类型推导：类型定义：支持<code>var abc = 10</code>这样的语法，让golang看上去有点像动态类型语言，但golang实际上时强类型的，前面的定义会被自动推导出是int类型。</p><blockquote><p>作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。</p><p>简单来说，Go是一门写起来像动态语言，有着动态语言开发效率的静态语言。</p></blockquote></li><li><p>一个类型只要实现了某个interface的所有方法，即可实现该interface，无需显式去继承。</p><blockquote><p>Go编程规范推荐每个Interface只提供一到两个的方法。这样使得每个接口的目的非常清晰。另外Go的隐式推导也使得我们组织程序架构的时候更加灵活。在写JAVA／C++程序的时候，我们一开始就需要把父类／子类／接口设计好，因为一旦后面有变更，修改起来会非常痛苦。而Go不一样，当你在实现的过程中发现某些方法可以抽象成接口的时候，你直接定义好这个接口就OK了，其他代码不需要做任何修改，编译器的自动推导会帮你做好一切。</p></blockquote></li><li><p>不能循环引用：即如果a.go中import了b，则b.go要是import a会报import cycle not allowed。好处是可以避免一些潜在的编程危险，比如a中的func1()调用了b中的func2()，如果func2()也能调用func1()，将会导致无限循环调用下去。</p></li><li><p>defer机制：在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。</p><p>可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。</p></li><li><p>“包”的概念：和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。</p></li><li><p>编程规范：GO语言的编程规范强制集成在语言中，比如明确规定花括号摆放位置，强制要求一行一句，不允许导入没有使用的包，不允许定义没有使用的变量，提供gofmt工具强制格式化代码等等。奇怪的是，这些也引起了很多程序员的不满，有人发表GO语言的XX条罪状，里面就不乏对编程规范的指责。要知道，从工程管理的角度，任何一个开发团队都会对特定语言制定特定的编程规范，特别像Google这样的公司，更是如此。GO的设计者们认为，与其将规范写在文档里，还不如强制集成在语言里，这样更直接，更有利用团队协作和工程管理。</p></li><li><p>交叉编译：比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！</p></li></ul><h2 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h2><p>此处我们说个小段子：</p><p>很久以前，有一个IT公司，这公司有个传统，允许员工拥有20%自由时间来开发实验性项目。在2007的某一天，公司的几个大牛，正在用c++开发一些比较繁琐但是核心的工作，主要包括庞大的分布式集群，大牛觉得很闹心，后来c++委员会来他们公司演讲，说c++将要添加大概35种新特性。这几个大牛的其中一个人，名为：Rob Pike，听后心中一万个xxx飘过，“c++特性还不够多吗？简化c++应该更有成就感吧”。于是乎，Rob Pike和其他几个大牛讨论了一下，怎么解决这个问题，过了一会，Rob Pike说要不我们自己搞个语言吧，名字叫“go”，非常简短，容易拼写。其他几位大牛就说好啊，然后他们找了块白板，在上面写下希望能有哪些功能。接下来的时间里，大牛们开心的讨论设计这门语言的特性，经过漫长的岁月，他们决定，以c语言为原型，以及借鉴其他语言的一些特性，来解放程序员，解放自己，然后在2009年，go语言诞生。</p><p>以下就是这些大牛所罗列出的Go要有的功能：</p><ul><li>规范的语法（不需要符号表来解析）</li><li>垃圾回收（独有）</li><li>无头文件</li><li>明确的依赖</li><li>无循环依赖</li><li>常量只能是数字</li><li>int和int32是两种类型</li><li>字母大小写设置可见性（letter case sets visibility）</li><li>任何类型（type）都有方法（不是类型）</li><li>没有子类型继承（不是子类）</li><li>包级别初始化以及明确的初始化顺序</li><li>文件被编译到一个包里</li><li>包package-level globals presented in any order</li><li>没有数值类型转换（常量起辅助作用）</li><li>接口隐式实现（没有“implement”声明）</li><li>嵌入（不会提升到超类）</li><li>方法按照函数声明（没有特别的位置要求）</li><li>方法即函数</li><li>接口只有方法（没有数据）</li><li>方法通过名字匹配（而非类型）</li><li>没有构造函数和析构函数</li><li>postincrement（如++i）是状态，不是表达式</li><li>没有preincrement(i++)和predecrement</li><li>赋值不是表达式</li><li>明确赋值和函数调用中的计算顺序（没有“sequence point”）</li><li>没有指针运算</li><li>内存一直以零值初始化</li><li>局部变量取值合法</li><li>方法中没有“this”</li><li>分段的堆栈</li><li>没有静态和其它类型的注释</li><li>没有模板</li><li>内建string、slice和map</li><li>数组边界检查</li></ul><blockquote><h2 id="大牛真身"><a href="#大牛真身" class="headerlink" title="大牛真身"></a>大牛真身</h2><p>最大牌的当属B和C语言设计者、Unix和Plan 9创始人、1983年图灵奖获得者Ken Thompson，这份名单中还包括了Unix核心成员Rob Pike（go语言之父）、java HotSpot虚拟机和js v8引擎的开发者Robert Griesemer、Memcached作者Brad Fitzpatrick，等等。</p></blockquote><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-4-go语言的优势</title>
      <link href="posts/60128ef3/"/>
      <url>posts/60128ef3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言和其他语言的对比"><a href="#Go语言和其他语言的对比" class="headerlink" title="Go语言和其他语言的对比"></a>Go语言和其他语言的对比</h1><h2 id="一、Go语言设计初衷"><a href="#一、Go语言设计初衷" class="headerlink" title="一、Go语言设计初衷"></a>一、Go语言设计初衷</h2><p>1、设计Go语言是为了解决当时Google开发遇到的问题：</p><ul><li>大量的C++代码，同时又引入了Java和Python</li><li>成千上万的工程师</li><li>数以万计行的代码</li><li>分布式的编译系统</li><li>数百万的服务器</li></ul><p>2、Google开发中的痛点：</p><ul><li>编译慢</li><li>失控的依赖</li><li>每个工程师只是用了一个语言里面的一部分</li><li>程序难以维护（可读性差、文档不清晰等）</li><li>更新的花费越来越长</li><li>交叉编译困难</li></ul><p>3、如何解决当前的问题和痛点？</p><ul><li><p>Go希望成为互联网时代的C语言。多数系统级语言（包括Java和C#）的根本编程哲学来源于C++，将C++的面向对象进一步发扬光大。但是Go语言的设计者却有不同的看法，他们认为值得学习的是C语言。C语言经久不衰的根源是它足够简单。因此，Go语言也是足够简单。</p></li><li><p>所以，他们当时设计Go的目标是为了消除各种缓慢和笨重、改进各种低效和扩展性。Go是由那些开发大型系统的人设计的，同时也是为了这些人服务的；它是为了解决工程上的问题，不是为了研究语言设计；它还是为了让我们的编程变得更舒适和方便。</p></li><li><p>但是结合Google当时内部的一些现实情况，如很多工程师都是C系的，所以新设计的语言一定要易学习，最好是类似C的语言；20年没有出新的语言了，所以新设计的语言必须是现代化的（例如内置GC）等情况。最后根据实战经验，他们向着目标设计了Go这个语言。</p></li></ul><p>4、Go语言的特色：</p><ul><li>没有继承多态的面向对象</li><li>强一致类型</li><li>interface不需要显式声明(Duck Typing)</li><li>没有异常处理(Error is value)</li><li>基于首字母的可访问特性</li><li>不用的import或者变量引起编译错误</li><li>完整而卓越的标准库包</li><li>Go内置runtime（作用是性能监控、垃圾回收等）</li></ul><h2 id="二、Go语言的优势"><a href="#二、Go语言的优势" class="headerlink" title="二、Go语言的优势"></a>二、Go语言的优势</h2><p>1、学习曲线容易</p><p>​    Go语言语法简单，包含了类C语法。因为Go语言容易学习，所以一个普通的大学生花几个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内Go流行的原因之一。</p><p>​    <img src="https://voyager-m.gitee.io/picgo/test/go2.png" alt="go2"></p><blockquote><p>Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。</p></blockquote><p>2、效率：快速的编译时间，开发效率和运行效率高</p><p>​    开发过程中相较于 Java 和 C++呆滞的编译速度，Go 的快速编译时间是一个主要的效率优势。Go拥有接近C的运行效率和接近PHP的开发效率。</p><p><img src="https://voyager-m.gitee.io/picgo/test/golang2.png"></p><p>C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。</p><p><img src="https://voyager-m.gitee.io/picgo/test/go3.png" alt="go3"></p><p>3、出身名门、血统纯正</p><p>​    之所以说Go出身名门，从Go语言的创造者就可见端倪，Go语言绝对血统纯正。其次Go语言出自Google公司，Google在业界的知名度和实力自然不用多说。Google公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从Go语言的发展态势来看，Google对它这个新的宠儿还是很看重的，Go自然有一个良好的发展前途。</p><p><img src="https://voyager-m.gitee.io/picgo/test/qinerzi_meitu_1.jpg"></p><p>4、自由高效：组合的思想、无侵入式的接口</p><p>​    Go语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go语言支持当前所有的编程范式，包括过程式编程、面向对象编程、面向接口编程、函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。</p><p>​    </p><p>5、强大的标准库</p><p>​    这包括互联网应用、系统编程和网络编程。Go里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。<strong>Go 语言的 lib 库麻雀虽小五脏俱全。</strong>Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。</p><p>6、部署方便：二进制文件，Copy部署</p><p>​    这一点是很多人选择Go的最大理由，因为部署太方便了，所以现在也有很多人用Go开发运维程序。</p><p>4、简单的并发</p><p><strong>并行和异步编程几乎无痛点。</strong>Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的编程者来说，完全就是让人眼前一亮的感觉。Go 是一种非常高效的语言，高度支持并发性。Go是为大数据、微服务、并发而生的一种编程语言。</p><ul><li><p>Go 作为一门语言致力于使事情简单化。它并未引入很多新概念，而是聚焦于打造一门简单的语言，它使用起来异常快速并且简单。其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。</p></li><li><p>创建 Goroutines 的成本很低，只需几千个字节的额外内存，正由于此，才使得同时运行数百个甚至数千个 goroutines 成为可能。可以借助通道实现 goroutines 之间的通信。Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。</p></li></ul><p><img src="https://voyager-m.gitee.io/picgo/test/golang1.png"></p><p>8、稳定性</p><p>​    Go拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么Go相比于其他程序会更稳定呢？这是因为Go提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如go tool、gofmt、go test。</p><h2 id="三、对比其他语言"><a href="#三、对比其他语言" class="headerlink" title="三、对比其他语言"></a>三、对比其他语言</h2><p>Go的很多语言特性借鉴与它的三个祖先：C，Pascal和CSP。Go的语法、数据类型、控制流等继承于C，Go的包、面对对象等思想来源于Pascal分支，而Go最大的语言特色，基于管道通信的协程并发模型，则借鉴于CSP分支。</p><p><img src="https://voyager-m.gitee.io/picgo/test/go1.jpeg" alt="go1"></p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>编译语言，速度适中（2.67s），目前的大型网站都是拿java写的，比如淘宝、京东等。主要特点是稳定，开源性好，具有自己的一套编写规范，开发效率适中，目前最主流的语言。</p><blockquote><p>作为编程语言中的大腕。具有最大的知名度和用户群。无论风起云涌，我自巍然不动。他强任他强，清风拂山岗；他横由他横，明月照大江。</p></blockquote><h3 id="c"><a href="#c" class="headerlink" title="c#"></a>c#</h3><p>执行速度快（4.28），学习难度适中，开发速度适中。但是由于c#存在很多缺点，京东、携程等大型网站前身都是用c#开发的，但是现在都迁移到了java上。</p><h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><p>现存编程语言中的老祖，其他语言皆由此而生。执行速度最快无人能及。但是写起来最为复杂，开发难度大。</p><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><p>编程语言中特立独行的傲娇美女。前端处理能力是其它语言无法比拟。发展中的js后端处理能力也是卓越不凡。前后端通吃，舍我其谁？</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>脚本语言，速度最慢（258s），代码简洁、学习进度短，开发速度快。豆瓣就是拿python写的。Python著名的服务器框架有django，flask。但是python在大型项目上不太稳定，因此有些用python的企业后来迁移到了java上。</p><h3 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h3><p>编译语言，比python快十倍，和java差不多，但是学习进度慢，而且在实际编程中，如果对语言不够精通，很容易造成性能严重下降。，后来比如Yammer就从scala迁移到了java上。微服务框架有lagom等。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>编程界的小鲜肉。高并发能力无人能及。即具有像Python一样的简洁代码、开发速度，又具有C语言一样的执行效率，优势突出。</p><h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>因为Go的语法和Erlang、Python类似，所以我们将这三门语言做个详细的对比。</p><p>相比于Python的40个特性，Go只有31个，可以说Go在语言设计上是相当克制的。比如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。</p><p>但是Go的特点也很鲜明，比如，它拥有协程、自动垃圾回收、包管理系统、一等公民的函数、栈空间管理等。</p><p>Go作为静态类型语言，保证了Go在运行效率、内存用量、类型安全都要强于Python和Erlang。</p><p>Go的数据类型也更加丰富，除了支持表、字典等复杂的数据结构，还支持指针和接口类型，这是Python和Erlang所没有的。特别是接口类型特别强大，它提供了管理类型系统的手段。而指针类型提供了管理内存的手段，这让Go进入底层软件开发提供了强有力的支持。</p><p>Go在面对对象的特性支持上做了很多反思和取舍，它没有类、虚函数、继承、泛型等特性。Go语言中面向对象编程的核心是组合和方法(function)。组合很类似于C语言的struct结构体的组合方式，方法类似于Java的接口(Interface)，但是使用方法上与对象更加解耦，减少了对对象内部的侵入。Erlang则不支持面对对象编程范式，相比而言，Python对面对对象范式的支持最为全面。</p><p>在函数式编程的特性支持上，Erlang作为函数式语言，支持最为全面。但是基本的函数式语言特性，如lambda、高阶函数、curry等，三种语言都支持。</p><p>控制流的特性支持上，三种语言都差不多。Erlang支持尾递归优化，这给它在函数式编程上带来便利。而Go在通过动态扩展协程栈的方式来支持深度递归调用。Python则在深度递归调用上经常被爆栈。</p><p>Go和Erlang的并发模型都来源于CSP，但是Erlang是基于actor和消息传递（mailbox）的并发实现，Go是基于goroutine和管道（channel）的并发实现。不管Erlang的actor还是Go的goroutine，都满足协程的特点：由编程语言实现和调度，切换在用户态完成，创建销毁开销很小。至于Python，其多线程的切换和调度是基于操作系统实现，而且因为GIL的大坑级存在，无法真正做到并行。</p><p>而且从笔者的并发编程体验上看，Erlang的函数式编程语法风格和其OTP behavior框架提供的晦涩的回调（callback）使用方法，对大部分的程序员，如C/C++和Java出身的程序员来说，有一定的入门门槛和挑战。而被称为“互联网时代的C”的Go，其类C的语法和控制流，以及面对对象的编程范式，编程体验则好很多。</p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-冒泡排序</title>
      <link href="posts/6299afab/"/>
      <url>posts/6299afab/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>冒泡排序（Bubble Sort）是一种很原始的排序方法，就是通过不断交换“大数”的位置达到排序的目的。因为不断出现“大数”类似于水泡不断出现，因此被形象地称为冒泡算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从一组数列（列表）中挑选一个最大的数，如果这个数列比较小，有可能我们一眼就看出谁最大，但是如果数列比较大，那么就不好确定了，冒泡排序不需要直接找出数列中最大的那个数，只需要在两个数中找出最大的就可以了。</p><p>冒泡算法的原理是比较两个相邻数字的大小，将两个数中比较大的那个数交换到靠后的位置。这样不断交换下去就可以将最大的那个数放到最后的位置，然后从头开始将第二大的数放到倒数第二的位置上，如此反复，知道将数列变成有序数列。</p><p>举例：</p><pre><code>7 3 5 1 9 4</code></pre><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>第1次排序，按照冒泡排序的原理，比较相邻两个数的大小，从数列头开始第一次比较7和3的大小，7比3大，交换7和3的位置，把7放在靠后的位置。交换的代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> iList[i]&gt;=iList[i+<span class="number">1</span>]</span><br><span class="line">     iList[i],iList[i+<span class="number">1</span>]=iList[i+<span class="number">1</span>],iList[i]</span><br><span class="line"> <span class="comment">#这里你可能会疑惑为什么iList[1]被覆盖了，还能给iList[i+1]赋值，这里为python的序列解包，相关语法可查python官方文档。</span></span><br></pre></td></tr></table></figure><p>交换后如图所示</p><pre><code>3 7 5 1 9 4</code></pre><p>第2次比较7和5的大小，发现7比5大，交换7和5的位置，结果如图：</p><pre><code>3 5 7 1 9 4</code></pre><p>第3次比较7和1的大小，7比1大，交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第4次比较7和9的大小，7比9小，不交换位置，结果如图：</p><pre><code>3 5 1 7 9 4</code></pre><p>第5次比较9和4的位置，9比4大，交换位置，结果如下：</p><pre><code>3 5 1 7 4 9</code></pre><p>到此，第一轮排序已经结束，成功序列中最大的值9放入最后的位置。然后再进行下一轮排序。</p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><pre><code>第一次  3 5 1 7 4 9第二次  3 1 5 7 4 9第三次  3 1 5 7 4 9第四次  3 1 5 4 7 9</code></pre><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><pre><code>第一次  1 3 5 4 7 9第二次  1 3 5 4 7 9第三次  1 3 4 5 7 9</code></pre><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><pre><code>第一次  1 3 4 5 7 9第二次  1 3 4 5 7 9</code></pre><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><pre><code>第一次  1 3 4 5 7 9</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>建立无序序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#实现创建一个无序的数组,名字为randomList</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomList</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;返回一个长度为n的整数列表，数据范围[0,1000]&#x27;&#x27;&#x27;</span></span><br><span class="line">    iList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        iList.append(random.randrange(<span class="number">1000</span>))</span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    iList=randomList(<span class="number">10</span>)</span><br><span class="line">    print(iList)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对无序序列进行冒泡排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList</span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;冒泡排序&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(iList) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> iList[j] &gt;= iList[j + <span class="number">1</span>]:  <span class="comment"># 比较相邻两数的大小</span></span><br><span class="line">                iList[j], iList[j + <span class="number">1</span>] = iList[j + <span class="number">1</span>], iList[j]  <span class="comment"># 将较大的数交换到靠后的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(bubbleSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;bubbleSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import bubbleSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用bubbleSort函数排序100遍用的时长</span></span><br></pre></td></tr></table></figure><p>整理于2020年10月13日早</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-归并排序</title>
      <link href="posts/63e6e1be/"/>
      <url>posts/63e6e1be/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>给大家讲个故事：“从前有座山，山里有座庙，庙里有个老和尚在给小和尚讲故事，讲的是从前有座山，山里有座庙，庙里有个老和尚在给小和尚……”，这个故事大家可能都听过，这个故事实际上就体现了递归的思想，每个故事都在调用故事本身。本算法也用了递归思想，首先我们把数列分为left和right两个子数列，然后将left和right两个子数列都变成有序数列，再把他们合并到一起就变成了一个有序数列，那么left和right两子数列如何变成有序的呢，我们将left和right两个子数列分别再分成两部分得到子子数列，然后再将子子数列排序后合并得到有序的子书数列，那么子子数列如何变成有序数列呢，我们……这样的做法是不是很想前面将的那个故事呢。当然，他们还是有区别的，故事可以无限制讲下去，数列不会无限制分下去，当分到最小的子数列只有一个元素的时候，就不能再分了，这时候就要开始合并数列了。</p><p>将数列分为子数列的核心代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">middle = len(iList)//<span class="number">2</span> <span class="comment">#求分割点下标</span></span><br><span class="line">left , right = iList[<span class="number">0</span>:middle] , iList[middle:]   <span class="comment">#得到数列的切片 </span></span><br></pre></td></tr></table></figure><p>我们还是举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101801.png"></p><h3 id="1-第一次分组"><a href="#1-第一次分组" class="headerlink" title="1.第一次分组"></a>1.第一次分组</h3><p>长度为7，得到middle=6/2=3，两部分为[0:3]和[3:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101802.png"></p><h3 id="2-第二次分组"><a href="#2-第二次分组" class="headerlink" title="2.第二次分组"></a>2.第二次分组</h3><p>第一次分组得到的left和right长度为3，我们仍然无法知道这个长度为3的数列是否有序。那么继续分组<br>长度都为3，得到middle=3/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101803.png"></p><h3 id="3-第三次分组"><a href="#3-第三次分组" class="headerlink" title="3.第三次分组"></a>3.第三次分组</h3><p>第二次分组得到的left和right长度为1和2，我们仍然无法知道这个长度为2的数列是否有序。那么继续分组<br>长度都为2，得到middle=2/2=1，两部分为[0:1]和[1:]</p><p><img src="https://voyager-m.gitee.io/picgo/test/101804.png"></p><p>至此，一个数列长度为6的数列，经过三次分组，被我们分成了六个长度为1的子数列，现在每个子数列已经为有序了，我们可以开始合并了。</p><p>将两个子数列合并的核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>  left  <span class="keyword">and</span> right :  <span class="comment">#遍历两个子数列</span></span><br><span class="line">    <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]: <span class="comment">#将两子数列中较小的元素添加到mList中</span></span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h3 id="1-第一次合并"><a href="#1-第一次合并" class="headerlink" title="1.第一次合并"></a>1.第一次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101805.png"></p><h3 id="2-第二次合并"><a href="#2-第二次合并" class="headerlink" title="2.第二次合并"></a>2.第二次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101806.png"></p><h3 id="3-第三次合并"><a href="#3-第三次合并" class="headerlink" title="3.第三次合并"></a>3.第三次合并</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101807.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:  <span class="comment"># 若只有一个元素，那就返回iList</span></span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    middle = len(iList) // <span class="number">2</span>  <span class="comment"># 求分割点下标</span></span><br><span class="line">    left, right = iList[<span class="number">0</span>:middle], iList[middle:]  <span class="comment"># 得到数列的切片</span></span><br><span class="line">    <span class="keyword">return</span> mergeList(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeList</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    mList = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:  <span class="comment"># 遍历两个子数列</span></span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &gt;= right[<span class="number">0</span>]:  <span class="comment"># 将两子数列中较小的元素添加到mList中</span></span><br><span class="line">            mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        mList.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        mList.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> mList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">        print(iList)</span><br><span class="line">        print(mergeSort(iList))</span><br><span class="line">        print(timeit.timeit(<span class="string">&quot;mergeSort(iList)&quot;</span>,<span class="string">&quot;from __main__ import mergeSort,iList&quot;</span>,number=<span class="number">100</span>))<span class="comment">#用归并排序算法排序100次花费的时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单解释下，代码中mergeSort实际上是在分组，mergeList实际上是在合并，注意mergeSort中的return语句给mergeList传的是两个函数参数，而mergeList接受的应该是两个列表，所以mergeSort分组语句将会不断进栈，一直到列表分成很多个长度为1的子列表后，开始出栈，执行mergeList函数进行合并，最后将最后一个有序的mList列表返回给mergeSort函数。</p><p>整理于2020年10月18日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode-排序-插入排序</title>
      <link href="posts/e02a01f2/"/>
      <url>posts/e02a01f2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>插入排序实际上跟我们打牌一样，斗地主应该大部分人都会玩的，我们在抓牌的时候，每当从下面抓起一张牌，我们就会将这张牌放到合适的位置，使手上的牌始终是一个有序的状态（有些人打牌也习惯乱放，前提是自己看得懂）。那么插入排序的过程，和以上的过程就很相似。</p><p>插入排序，首先将数列分成两部分，将数列的第一个数划分为left部分，剩下的数为right部分，我们依次将right部分的数一个一个取出，然后将该数放入left部分合适的位置，这样，left部分数越来越多，right部分的数越来越少，最后right部分为空，这时候left部分就为有序数列了。</p><p>核心实现代码为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>:len(iList))<span class="comment">#从第二个元素开始遍历right部分</span></span><br><span class="line">   target=iList[right]<span class="comment">#将每一个遍历的元素赋值为target</span></span><br><span class="line">   <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>:right)<span class="comment">#遍历left部分（left部分有序）</span></span><br><span class="line">       <span class="keyword">if</span> target&lt;=iList[left]:<span class="comment">#找到target该插入的位置</span></span><br><span class="line">           iList[left+<span class="number">1</span>:right+<span class="number">1</span>]=iList[left:right]<span class="comment">#插入位置后元素整体后移一位</span></span><br><span class="line">           iList[left]=target<span class="comment">#将target放在合适位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们还是那个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/101601.png"></p><h3 id="1-第一轮排序"><a href="#1-第一轮排序" class="headerlink" title="1.第一轮排序"></a>1.第一轮排序</h3><p>我们将数列分为left和right两部分。开始的时候left部分为第一个数7（有序部分），剩下的为right部分（待排序部分）。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101602.png"></p><h3 id="2-第二轮排序"><a href="#2-第二轮排序" class="headerlink" title="2.第二轮排序"></a>2.第二轮排序</h3><p>从right中取出第一个数字3，然后将它放入left中合适的位置。从前往后遍历left部分的数，发现7比3大，然后将7以及后面的数（当前情况7后面没有数字）往后移一位，将3放在原本7所在的位置。（这里因为left只有一个7，比较简单，但是不了left部分多长都是一样的思想）</p><p><img src="https://voyager-m.gitee.io/picgo/test/101603.png"></p><h3 id="3-第三轮排序"><a href="#3-第三轮排序" class="headerlink" title="3.第三轮排序"></a>3.第三轮排序</h3><p>我们从right部分继续选出元素5，然后从头遍历left部分的数，发现数字7比5大，这时候将7以及7后面的元素（当前情况7后面没有数字）往后移一位，将3放在原本7在的位置。</p><p><img src="https://voyager-m.gitee.io/picgo/test/101604.png"></p><h3 id="4-第四轮排序"><a href="#4-第四轮排序" class="headerlink" title="4.第四轮排序"></a>4.第四轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101605.png"></p><h3 id="5-第五轮排序"><a href="#5-第五轮排序" class="headerlink" title="5.第五轮排序"></a>5.第五轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101606.png"></p><h3 id="6-第六轮排序"><a href="#6-第六轮排序" class="headerlink" title="6.第六轮排序"></a>6.第六轮排序</h3><p><img src="https://voyager-m.gitee.io/picgo/test/101607.png"></p><p>自此，left部分为原数列排序后的有序数列。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> randomList <span class="keyword">import</span> randomList<span class="comment">#这个模块是自定义的，在“Leetcode-排序-冒泡排序”那篇文章</span></span><br><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">iList = randomList(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span>(<span class="params">iList</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(iList) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> iList</span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> range(<span class="number">1</span>, len(iList)):</span><br><span class="line">        target = iList[right]</span><br><span class="line">        <span class="keyword">for</span> left <span class="keyword">in</span> range(<span class="number">0</span>, right):</span><br><span class="line">            <span class="keyword">if</span> target &lt;= iList[left]:</span><br><span class="line">                iList[left + <span class="number">1</span>:right + <span class="number">1</span>] = iList[left:right]</span><br><span class="line">                iList[left] = target</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(iList)</span><br><span class="line">    print(insertionSort(iList))</span><br><span class="line">    print(timeit.timeit(<span class="string">&quot;insertionSort(iList)&quot;</span>, <span class="string">&quot;from __main__ import  insertionSort,iList&quot;</span>, number=<span class="number">100</span>) ) <span class="comment"># 用这个算法排序100次所花时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整理于2020年10月16日</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台-数据中台初识</title>
      <link href="posts/18280cf2/"/>
      <url>posts/18280cf2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、数据中台现象"><a href="#一、数据中台现象" class="headerlink" title="一、数据中台现象"></a>一、数据中台现象</h2><p>数据中台近两年非常火热，数据中台的热度已经拆超越了数字化转型的热度并且一直在上升。数据中台发起于2018年，崛起于2019年3月，目前已经远远超越了数据仓库，商业智能。 </p><p><strong>企业对数据中台的期望：</strong>与业务更精密，提供数据服务，提供业务价值，快速开发数据服务，围绕业务场景，提供统一数据，为业务赋能，构建统一的数据资产，打通数据的孤岛。</p><p>以上是企业的现实需求，那么为什么现有的数据仓库，数据平台（数据湖），商业智不能很好的满足这些需求呢。要弄清楚这个问题，我们就要弄清楚数据中台和前面这些东西的区别在哪里。</p><p><strong>商业智能和数据仓库：</strong>已分析报表为核心，把数据加工成分析报表提供给决策层去看，从而实现辅助决策的功能。商业智能的底层，是数据仓库。主要使用者是决策者。<br>数据湖：结构化数据和非结构化数据快速为业务产生数据服务，以数据存储和大数据为核心。主要的使用对象是开发者。</p><p><strong>数据中台：</strong>希望是直接服务于业务的平台，距离业务更近，用多种方式直接为业务提供数据产品。</p><p><strong>从出发点来说。</strong>数据中台优先考虑的是业务需要什么导向，是以业务需求为出发点。数据平台是存储加工数据的平台，所实现的功能取决于拥有的数据情况。是以技术和数据为导向的。</p><p><strong>从度量来看。</strong>数据中台做的好不好是以数据服务客户的满意度。数据平台的度量是看数据质量。</p><p>数据中台要核心解决的问题是过去企业应用开发团队和数据开发团队的协同问题，其中包括效率问题（应用开发一个报表都需要十几天时间），协作问题（获取数据错误，同样的数据逻辑却要开发两遍），能力问题（应用开发的人员很多，懂数据开发的人员很少）。数据中台能让应用开发专注于应用开发，让数据开发团队专注于数据开发。</p><p>数据中台是加速源数据产生业务价值的服务工厂，按照Gartner的分层架构理念，上面的是前端的创新型系统，下面是后端的记录型系统，中间的是链接前端创新想系统和后端的记录型系统的系统。上面的前台叫做敏态，下面的后台叫稳态。比如现在企业的erp等系统，这些系统偏企业后端的系统一般变化比较小，所以我们叫做稳态系统。比如h5广告，用户画像，这些系统是随着外界的变化而不断在变化，所以我们把它们叫叫做敏态系统。所以需要一个链接这两种系统的平台，于是中台产生了，中台的作用是使两种系统的速度一致，让后台提供服务给前台更快更敏捷。即数据中台是为了协调敏态前台业务和稳态的后台的速度，让他们之间的协作更加流畅，从而加速从元数据到业务价值的产生过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/1.png"></p><h2 id="二、现在业界常见的数据中台架构"><a href="#二、现在业界常见的数据中台架构" class="headerlink" title="二、现在业界常见的数据中台架构"></a>二、现在业界常见的数据中台架构</h2><h3 id="阿里数据中台"><a href="#阿里数据中台" class="headerlink" title="阿里数据中台"></a>阿里数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/2.png"><br><img src="https://voyager-m.gitee.io/picgo/test/3.png"></p><p>阿里数据中台是由Service，Entity，Data为核心组成。主要是三个方面的内容：OneData(业务数据化)，OneEntity(数据业务化)，OneService(业务服务化)。</p><h3 id="菜鸟数据中台"><a href="#菜鸟数据中台" class="headerlink" title="菜鸟数据中台"></a>菜鸟数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/4.png"></p><h3 id="苏宁数据中台"><a href="#苏宁数据中台" class="headerlink" title="苏宁数据中台"></a>苏宁数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/5.png"></p><p>数据中台对企业的意义就是，让传统企业向科技企业升级，让IT系统集成向大数据集成升级，让工具/流程/管理向驱动业务运营升级。</p><p><strong>数据平台：</strong></p><p>1.有完整的数据模型设计，但偏重设计和技术，在执行过程中，很难保证数据的全，数据应用一般不考虑跨过数据中心。</p><p>2.初期数据发展快，效率高，快速体现业务价值，但是随着数据仓库的建设，数据量急速叠加，整体成本居高不下。导致数据混乱，灾难。</p><p><strong>数据中台:</strong></p><p>1.数据中台的基本理念是：将所有数据汇聚到数据中台，每个数据应用都以数据中台为唯一数据来源。</p><p>2.苏宁数据中台的目标是为苏宁的数据战略提供有力的支撑，从企业全进行统一规划，统一建设，强调数据“全”。从设计、组织、建设、流程角度保障了模式的落地。</p><p>3.数据中台的建设减低了数据使用门槛。</p><h3 id="滴滴数据中台"><a href="#滴滴数据中台" class="headerlink" title="滴滴数据中台"></a>滴滴数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/6.png"><br><img src="https://voyager-m.gitee.io/picgo/test/7.png"></p><p>数据中台不是简单的把数据相应的模块系统放在公司里面搭建起来就ok。</p><p>数据可能今后发挥价值最大的地方是赋能AI。通过建立好数据中台服务层，再把它演变成对应的特征层，来驱动出这样强化学习的营销体系，目前滴滴的数据中台更多的产生价值在生产侧。</p><p><strong>目前存在的一些困难问题:</strong></p><p>1.在数据生产价值线（数据-&gt;生产-&gt;价值）中质量，效率，成本的问题.</p><p>2.数据实际上是现实物理世界在数据世界中的投影，那么不同的场景就会产生不同的投影，同样的业务行为在不同的场景下会有不同的分析角度。在业务角度，当然希望这种场景和维度越多越好，但是这会给数据管理带来很大的难度。</p><h3 id="Oppo数据中台"><a href="#Oppo数据中台" class="headerlink" title="Oppo数据中台"></a>Oppo数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/8.png"></p><p>Oppo日活跃用户超过2亿，在运营这些互联网应用的过程中，oppo积累了大量数据，已超过100PB，日增数据量超过20TB，oppo的数据中台以数据仓库为核心，构建了实时的数据服务能力。</p><p><strong>Oppo把数据中台分成了4个层次，:</strong></p><p>1.最下面的是统一工具体系，涵盖了“接入-&gt;治理-&gt;开发-&gt;消费”全数据链路。</p><p>2.基于工具体系之上构建了数据仓库，划分为“原始层-明细层-汇总层-应用层”，这也是经典的数据仓库架构，数据仓库在整个架构中处于非常基础和核心的位置。</p><p>3.再往上就是全域的数据体系，全域就是把公司所有的业务数据都打通，形成统一的数据资产，如ID-mapping，用户标签等。</p><p>4.最终，数据要能被业务用起来，需要场景驱动的数据产品与服务。</p><h3 id="浙江移动数据中台"><a href="#浙江移动数据中台" class="headerlink" title="浙江移动数据中台"></a>浙江移动数据中台</h3><p><img src="https://voyager-m.gitee.io/picgo/test/9.png"></p><p>打造数据中台，实现跨域数据整合并沉淀公共的数据能力，同时提供丰富的数据模型，标准化的数据服务，个性化的开发平台与工具，满足一线数据开放和智慧运营要求。</p><h3 id="从业务数据化到数据业务化"><a href="#从业务数据化到数据业务化" class="headerlink" title="从业务数据化到数据业务化"></a>从业务数据化到数据业务化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/10.png"></p><h2 id="三、数据中台的愿景和使命"><a href="#三、数据中台的愿景和使命" class="headerlink" title="三、数据中台的愿景和使命"></a>三、数据中台的愿景和使命</h2><p><strong>数据中台的愿景：</strong>打造数据驱动的智能企业</p><p><strong>数据中台的使命：</strong>赋能业务以数据智能能力，让业务更智慧</p><h2 id="四、数据中台的本质和六大能力模型"><a href="#四、数据中台的本质和六大能力模型" class="headerlink" title="四、数据中台的本质和六大能力模型"></a>四、数据中台的本质和六大能力模型</h2><p>**数据中台的本质:**数据中台是数据服务工厂为企业提供可复用的数据智能服务</p><p>数据中台的六大能力模型：</p><p><strong>数据资产的规划和治理：</strong></p><p>数据资产的规划和治理，是数据中台的基础功能，它的目的是为了在构建数据服务，数据产品，数据应用之前，先画出企业的数据资产蓝图，尽可能的涵盖企业所有的可能产生和使用的数据，不论是企业内部数据还是外部数据。</p><p>数据资产的规划和治理体系，是企业数据战略的体现，承载系统是企业级数据资产目录(Data Asset Catalog)。</p><p>数据资产的规划和治理，是从根本上最大限度解决数据孤岛(Data Silo)问题的方案，也就是在应用构建，数据产生之前就规划好数据的产生和消费的数据流体系，从而所有的应用都按照这个规范来执行。</p><p><strong>数据自元的获取和存储：</strong></p><p>在企业梳理了构建了自己的数据资产蓝图后，就需要将这些数据资产对应的数据资源进行存储和存储，也就是很多企业常说的，“数据入湖”。</p><p>数据资源的获取和存储，在广义数据中台体系里是数据平台的一部分，不同的企业在不同的阶段，可以采用的技术手段是不一样的，关系型数据库，大数据平台，数据湖，乃至最简单的文件存储都可以作为数据资源存储获取的方式，并不一定要拘泥于一种形式。</p><p>这个模块的核心是数据资源是能够被按需获取到的，这也就意味着，哪怕我们不构建独立的数据存储，让数据留在源系统中，只要能够在需要的时候获取到，也是可以的。</p><p><strong>数据资产的共享和协作：</strong></p><p>如何能够让企业的业务更智慧，这里最重要的事情就是跨域数据的组合和分析，不同领域的数据的挖掘，整合才能产生人的经验所不能够具备的洞察。</p><p>数据中台区别于传统数据仓库的一个重要的特点，就是数据中台是企业的数据服务的协作生产平台，他是一个能够让业务需求人员，数据分析人员这样的数据使用方和数据工程师，数据管理员这样的数据提供方在一个平台上去共同使用同一套企业的数据资产的协作平台。这里很重要的功能就是企业数据门户，企业数据目录和数据版本管理，数据沙箱（Sandbox)，数据分级权限体系。</p><p><strong>业务价值的探索和分析：</strong></p><p>数据中台是一个数据服务工厂，那么这个工厂应该生产什么服务呢？</p><p>就像传统的工厂都会有一个研发中心一样，数据中台需要一个数据实验室平台，能够让业务人员，数据分析人员，数据科学家们在数据协作平台上，利用同一套数据进行业务价值的探索和分析，从而识别有价值的数据集，然后在批量生产，形成数据产品和服务。</p><p>这部分重要的功能是数据挖掘，数据科学平台，算法平台，机器学习平台等。</p><p><strong>数据服务的构建和治理：</strong></p><p>当有价值的数据服务在实验室（研发中心）中被识别出来，并且通过协作平台被验证，那么这个过程就要被工业化，形成一个数据服务的生产线（Data Pipeline），从而能够被自动，批量的生产出来，为业务提供按需的服务，这就是数据服务的构建部分。</p><p>数据中台会生产非常多的数据服务，所以，数据中台同时要提供这么多数据服务的治理功能，从而保证数据服务的全生命周期体系化管理，优化有价值的数据服务，下线过时的数据服务。</p><p><strong>数据服务的度量和运营：</strong></p><p>传统的数据仓库系统往往只关注系统的稳定性，但是并不关注提供的数据报表的使用情况，被应用的如何，是否为业务产生了价值。而数据中台作为企业的数据服务工厂，是一个运营数据服务的业务单元。</p><p>整理于2020年10月14日</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据中台 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力大数据技术框架整理</title>
      <link href="posts/8a1e23b3/"/>
      <url>posts/8a1e23b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p> 随着社会现代化不断推进，出先了很多例如大数据和人工智能等新型技术，这些技术正在为越来越多的行业赋能。电力在我们生活中可以说是处处不在，为了提供更加便捷智能的服务，电力行业也出现了许多需要解决的问题。那么互联网技术如何为电网赋能呢？电网这个庞大的体系中的各个分支都可以和哪些技术呢结合呢？作为一项研究课题，我们可以从哪些切入点开始呢？下面是我通过几天的学习给出的自己的答案。</p><p><img src="https://voyager-m.gitee.io/picgo/powerBigDataPic/electricBigData.png" alt="电力技术框架"></p><p> 这份框架图已经总结的很详细，这里就不再赘述。个人认为从研究切入点来说可以分为以下几点。</p><h2 id="一．研究现有方法，从技术层面为研究切入点"><a href="#一．研究现有方法，从技术层面为研究切入点" class="headerlink" title="一．研究现有方法，从技术层面为研究切入点"></a>一．研究现有方法，从技术层面为研究切入点</h2><h3 id="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"><a href="#以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。" class="headerlink" title="以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。"></a>以上电力大数据的简单框架，其中有些分类还可以再次细分，其中大部概念都属于“现有方法”，但是每一个现有方法放在智慧电网领域具体分析的时候，往往需要对现有方法进行某些改动，以达到得到更好效果的目的，我认为这是一个创新方向。综上所述，我认为以上每个分支，甚至还未列出的更加细的分支，都可以作为一个研究点。</h3><h2 id="二、寻找新的方法，从数据问题为研究切入点"><a href="#二、寻找新的方法，从数据问题为研究切入点" class="headerlink" title="二、寻找新的方法，从数据问题为研究切入点"></a>二、寻找新的方法，从数据问题为研究切入点</h2><h3 id="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"><a href="#现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。" class="headerlink" title="现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。"></a>现状：电力工业化加深，电力业务与电力信息融合不断加深，使得电力业务场景越来越具备大数据场景的特征，为了衍生出更多的增值服务，电力与大数据的融合将会不断加深。</h3><h3 id="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"><a href="#伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。" class="headerlink" title="伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。"></a>伴随云计算，人工智能等先进互联网技术的发展，数据的“含金量”不断提高，电力行业对数据的管理，存储，共享，操作等有了更高的要求，我国电力大数据环境正在形成，那么电力大数据业务处理、适应电力大数据的技术理论方法等一系列问题，需要通过研究拿出较好的解决方案。</h3><h3 id="面临的一些问题："><a href="#面临的一些问题：" class="headerlink" title="面临的一些问题："></a>面临的一些问题：</h3><h3 id="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"><a href="#（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。" class="headerlink" title="（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。"></a>（1）数据质量不是很高。电力数据在数据可获取颗粒程度、及时性、完整性、一致性、数据源的唯一性、准确性上有待提高。</h3><h3 id="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"><a href="#（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。" class="headerlink" title="（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。"></a>（2）数据共享以及数据集成不够。目前整个电力行业缺乏整个行业层面的数据模型定义与主数据管理，各个单位的数据管理平台不一，数据共享程度严重不足。</h3><h3 id="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"><a href="#（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高" class="headerlink" title="（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高"></a>（3）安全问题。电力数据实际上涉及到用户的隐私，若安全问题处理不好的话，会带来很多问题。另外由于我国面积广阔，电力覆盖面非常广，所以电力单位较多，每个电力单位的信息防御能力差距较大，甚至有些偏远地区的单位防御系统尚未建立。所以整个行业的防御能力需要提高</h3><h3 id="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"><a href="#（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。" class="headerlink" title="（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。"></a>（4）数据存储和实时分析。电是每家每户都会用到的资源，每时每刻都有大量的电力被消耗，这就意味这每时每刻都有巨量的电力数据产生，如何对如此大规模的数据进行存储以及实时对其中高质量的数据进行分析是一个需要解决的问题。</h3><h2 id="三、探索新方案，从具体问题为研究切入点"><a href="#三、探索新方案，从具体问题为研究切入点" class="headerlink" title="三、探索新方案，从具体问题为研究切入点"></a>三、探索新方案，从具体问题为研究切入点</h2><h3 id="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"><a href="#电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。" class="headerlink" title="电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。"></a>电力系统的各大板块（发电、售电、配电、输电）中都存在一些可以用偏软件的方法进行解决的问题。可以以这些具体问题作为点，去探索解决方案。不过个人认为，这种研究要以个人本身有一定知识技术积累为前提，否则应该较困难。</h3><div class="note success simple"><p>以上为仅为作者个人观点。</p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智慧电网 </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-neo4j入门</title>
      <link href="posts/3b57b49b/"/>
      <url>posts/3b57b49b/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>什么是知识图谱？</strong></p><p><strong>有人的地方就会有江湖</strong></p><p><strong>江湖不是打打杀杀</strong></p><p><strong>而是人情世故</strong></p><p><strong>人情世故就是各种关系嘛</strong></p><p><strong>人情世故通常都是文本数据</strong></p><p><strong>在海量数据中将各种各样的关系抽出来</strong></p><p><strong>那我，我们怎么存储这些关系</strong></p><p><strong>普通的数据库，当然不行了</strong></p><p><strong>因为不够直观嘛</strong></p><p><strong>所以我们就有了神器——neo4j</strong></p><p><strong>neo4j是一种图形化数据库，能让人很直观看出各实体之间的关系。</strong></p><h2 id="1、JDK环境配置"><a href="#1、JDK环境配置" class="headerlink" title="1、JDK环境配置"></a>1、JDK环境配置</h2><p>很多人电脑上本来就有jdk，但是很抱歉，neo4j很矫情，它对JDK版本有要求，所以最好卸载原有的JDk，安装最新版本的JDk。</p><p>JDK安装：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p>直接无脑下载后点下一步就ok了。</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建  </p><p>变量名：JAVA_HOME</p><p>变量值：C:\Program Files\Java\jdk1.8.0_152（以安装路径为主）</p><hr><p>系统变量-&gt;新建</p><p>变量名：CLASSPATH</p><p>变量值： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;  （注意符号，建议直接复制粘贴）</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %JAVA_HOME%\bin 填进去（注意符号，建议直接复制粘贴）<br>变量值：点击新建，将  %JAVA_HOME%\jre\bin 填进去（注意符号，建议直接复制粘贴）</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入java -version</p><p><img src="https://voyager-m.gitee.io/picgo/test/102801.png"></p><p>若出现这个图就表明成功啦！</p><h2 id="2、neo4j环境配置"><a href="#2、neo4j环境配置" class="headerlink" title="2、neo4j环境配置"></a>2、neo4j环境配置</h2><p>Neo4j安装：<a href="https://neo4j.com/download-center/">https://neo4j.com/download-center/</a></p><p>官网下载，然后无脑下一步安装</p><hr><p>我的电脑，右键-&gt;属性-&gt;高级系统设置-&gt;环境变量</p><hr><p>系统变量-&gt;新建</p><p>变量名：NEO4J_HOME</p><p>变量值： C:\neo4j-community-4.1.3</p><hr><p>系统变量-&gt;编辑</p><p>找到Path选项：</p><p>变量名：Path </p><p>变量值：点击新建，将  %NEO4J_HOME%\bin  填进去</p><p>至此完成配置。</p><hr><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入neo4j</p><p><img src="https://voyager-m.gitee.io/picgo/test/102802.png"></p><p>若出现这个图就表明成功啦！</p><p>本人已与百度合作，若以上配置过程看不懂或者有问题，可尝试百度搜索“xxx安装配置教程”即可。</p><h2 id="3-启动neo4j看看"><a href="#3-启动neo4j看看" class="headerlink" title="3.启动neo4j看看"></a>3.启动neo4j看看</h2><p>按Win+R组合键打开“运行”，输入cmd进入dos界面，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现如下界面表示成功启动</p><p><img src="https://voyager-m.gitee.io/picgo/test/102803.png"></p><p>图中红方框就就是访问地址</p><p>打开浏览器输入：<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>第一次登录的<strong>用户名</strong>和<strong>密码</strong>都是neo4j，登录成功后可以修改密码。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102804.png"></p><p>请看上面这张图：点开1位置的小星星，然后点击下面的Movie Graph（这是neo4j自带的演示知识图谱），然后我们会看到3位置自动出现了一行指令，然后点击4位置的小三角板，我们会得到5位置的界面，然后我们可以点击6位置的翻页，下面的每一页都会介绍neo4j的Cypher Query Language语句。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102805.png"></p><p>将页面翻到第2页，点击1位置的任意地方，我们能看到2位置的方框内自动出现了一堆指令，然后点击3位置的小三角，我们可以得到下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102806.png"></p><p>来解释下这个图哈，这个图中有9个person标签，8个movie标签，8个acted_in关系和10个directed关系。比如Tom Hanks演了8个电影。</p><p>至此，演示例子都看完啦，我只演示了第2页的指令，其他页的指令会简单的把Cypher Query Language都做一遍介绍，可自行琢磨，想系统学习Cypher Query Language可以去w3cschool看neo4j教程。</p><h2 id="3、Cypher-Query-Language简单操作"><a href="#3、Cypher-Query-Language简单操作" class="headerlink" title="3、Cypher Query Language简单操作"></a>3、Cypher Query Language简单操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">增加一个节点</span><br><span class="line">create(n:Person&#123;name:&#39;毛同学&#39;,age:5&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102807.png"></p><p>解释一下：n相当于一个别名，Person是我们定义的标签名字，大括号里面是属性，这里我们创建了名字name和年龄age两个属性，值分别为‘毛同学’和5。</p><p>图中点击毛同学这个圆圈，可以看到左下角显示这个实体的id号和属性以及属性值。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带有关系属性</span><br><span class="line">create (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[:是一个&#123;负债:10000&#125;]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102808.png"></p><p>解释一下：这个语句的前面和后面一部分其实就是创建实体的语句，主要是中间的，”：”后面的代表这个关系的名称，大括号里面的表示这个关系的属性。</p><p>图中点击1位置的关系，我们可以看到2位置的关系属性。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个穷人！（负债10000）</font>（这是个悲伤的故事）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删：</span><br><span class="line">create (n:Person &#123;name:&#39;MWY&#39;,age:20&#125;)</span><br><span class="line">match (n:Person&#123;name:&quot;MWY&quot;&#125;) delete n</span><br></pre></td></tr></table></figure><p>解释一下：这两句话是先创建了一个结点又删除了一个结点。其中删除语句中的n代表一个别名，相当于一个返回值，意思是在Person标签中查找name为”MWY”的返回给n，后面”delete n”代表删除n（就是查到的结点）这个结点。（注意：要删除点，必须先删除关系，不然不能删除）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">删除关系</span><br><span class="line">match (p:Person&#123;name:&quot;毛同学&quot;,age:&quot;5&quot;&#125;)-[f:是一个]-&gt;(n:Person&#123;name:&quot;穷人&quot;,age:&quot;5&quot;&#125;) delete f</span><br></pre></td></tr></table></figure><p>解释一下：删除关系语句中的前面部分和后面部分应该都能懂了，中间这部分，是把f当成一个返回值，查找到”是一个”这个关系后返回给f，后面的”delete f”代表把这个关系删除了，当然也可以变成”delete p,f,n”，这表示把两个结点和它们的关系都删掉了。</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上标签：</span><br><span class="line">match (t:Person) where id(t)&#x3D;0 set t:好人 return t</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102809.png"></p><p>解释一下：首先match是查找的意思，t接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为person的结点增加一个”好人”标签。</p><p>图中点击1位置的关系，我们可以看到2位置的标签变成了两个。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！</font>（挺不好意思的）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">加上属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;200  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102810.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示增加的意思，意思是把id为0的标签为”好人”的结点增加一个”颜值”属性，值为200。</p><p>这个图的意思就是说：<font color=#008000>同学是一个人！且是个好人！他的颜值为200</font>（不接受反驳）</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">改：</span><br><span class="line">修改属性</span><br><span class="line">match (a:好人) where id(a)&#x3D;0  set a.颜值&#x3D;500  return a</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102811.png"></p><p>解释一下：首先match是查找的意思，a接收找到的id为0的结点，set表示修改的意思，意思是把id为0的标签为”好人”的结点的”颜值”属性改为500。</p><p>这个图的意思就是说：<font color=#008000>毛同学是一个人！且是个好人！200都已经不能够表示他的颜值，500才能勉强表示</font>（我有点飘）</p><hr><p>如果你想清空数据库那么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">快速清空数据库：</span><br><span class="line">MATCH (n)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure><p>解释一下：n，表示的是一个别名，后面一句表示清空n，也就是清空数据库。</p><p>这就是我们常说的<font color=#008000>“删库跑路”</font>一句中的删库指令。（温馨提示：慎用）</p><p>若想交流，加qq：1518887260</p><p>整理于2020年10月28日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-汽车品牌知识图谱实战复现记录</title>
      <link href="posts/45c0910/"/>
      <url>posts/45c0910/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>写在前面</strong>：本人也是知识图谱“小白”，正在努力变“怪兽”，写文只为记录成长点滴，若有理解不合理亦或不到位的地方，敬请谅解。</p><h2 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102701.png"></p><p>这里环境配置还是有一些点需要注意的：</p><p>（1）若python版本是3.8以及以上的话是不支持time.clock()这个函数的，需要把这个函数换成time.perf_counter().若不想麻烦，可以考虑将电脑装两个版本的python。</p><p>（2）py2neo的版本不能低于4.0.0，因为4.0.0版本是个分界线，3.x和4.x接口的区别有点大，所以版本必须对应，不然后续会出现一系列问题。</p><p>（3）Neo4j-driver接口为了和前面版本对应应该安装1.6.1版本。</p><h2 id="2、业务需求分析"><a href="#2、业务需求分析" class="headerlink" title="2、业务需求分析"></a>2、业务需求分析</h2><p>基于搜索引擎的商业数据分析：</p><p>（1）行业分析：整体市场趋势、细分市场趋势</p><p>用户会不断搜索关于汽车某方面的信息，可能是通过品牌搜索，可能是通过车型等等，通过用户的这些行为找出整体的市场趋势，以及细分市场的分析。</p><p>（2）品牌分析：品牌市场份额、品牌粘性、品牌游离度</p><p>用户都在搜什么品牌，搜A品牌的用户又去搜了B品牌（为什么？），用户在搜索这个品牌的时候有没有什么持续性。。</p><p>（3）车系分析：车系市场份额、车系粘性、车系游离度</p><p>（4）车型分析：车型市场份额、车型粘性、车型游离度</p><p>（5）话题分析：热点排行、话题排行</p><p>（6）用户画像：自然属性分析、兴趣属性分布</p><p>我们来看几个例子咯：<br><img src="https://voyager-m.gitee.io/picgo/test/102702.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102703.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102704.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102705.png"></p><h2 id="3、项目总体框架设计"><a href="#3、项目总体框架设计" class="headerlink" title="3、项目总体框架设计"></a>3、项目总体框架设计</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102706.png"></p><p>项目分为应用层，业务层，数据层，ETL，数据源。</p><p><strong>数据源：</strong>一般获取渠道可以是汽车资讯网站、汽车电商平台、百科问答汽车频道、汽车投书平台。可以使用爬虫技术进行爬取，但要注意的是只能爬取网页公开的数据，遵守法律法规，做良好市民。（否者：爬虫写的好，牢饭吃的早）。</p><p><strong>ETL：</strong>这部分先通过爬虫框架scrapyEx爬取数据，然后经过页面目录管理、页面元素解析、动态页面渲染、页面内容解析、数据清洗转换、批量任务调度，使结点数据结构化和关系数据结构化。</p><p><strong>数据层：</strong>这一层我们首先要将数据导入到neo4j数据库，有两种方式，一种是Neo4j-import,另一种是Neo4j-Web控制台指令导入。这里我比较推荐第二种，因为指令可以让你非常清晰数据源的属性与生成结点或者关系之间的映射关系。</p><p><strong>业务层：</strong>通过py2neo开发框架将数据库与后台联系。然后pythonWeb实现实体识别，节点查询，关系查询，路径计算，上层用Django框架与前端连接，为用户提供交互窗口。</p><p><strong>应用层：</strong>这里主要是该框架的一些应用，比如只能搜索，智能问答，智能推荐等。</p><h2 id="4、知识图谱设计方法论"><a href="#4、知识图谱设计方法论" class="headerlink" title="4、知识图谱设计方法论"></a>4、知识图谱设计方法论</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102707.png"></p><p>专家法要求参与的人员经验很多，对业务非常熟悉。从上到下，总体规划。</p><p>参照法是以行业标准为参照来进行设计，在设计过程中不断修补裁剪。</p><p>归纳法是由技术过硬的专家来进行的，一般是自下向上，从一个点切入来设计的。</p><p>混合发是从上自下，从下自上同时进行，在中电处进行调整。</p><h2 id="5、数据导入："><a href="#5、数据导入：" class="headerlink" title="5、数据导入："></a>5、数据导入：</h2><div class="note success simple"><p>数据源必须为utf-8编码，不然结果会乱码。</p><p>修改为utf-8编码办法：笔记本打开csv文件，保存为UTF-8格式</p></div><p>&emsp;&emsp;</p><p>打开%NEO4J_HOME%\conf\neo4j.conf</p><p>将#dbms.connectors.default_listen_address=0.0.0.0的#去掉</p><p>&emsp;</p><p>进入 cmd控制台输入指令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>出现下图：<br><img src="https://voyager-m.gitee.io/picgo/test/102708.png"></p><p>打开浏览器访问<a href="http://localhost:7474/">http://localhost:7474/</a></p><p>然后输入数据库用户名和密码（初始密码都是neo4j），登录后也可以自己修改密码，出现如下界面：<br><img src="https://voyager-m.gitee.io/picgo/test/102709.png"></p><p>&emsp;&emsp;</p><p>打开cmd窗扣进入neo4j文件的bin目录下执行以下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j-admin import --mode=csv --database=graph.db --nodes ..\import\bank01.csv </span><br></pre></td></tr></table></figure><p>我们就完成了数据的导入，下面我们就可以开始创建结点了。</p><h2 id="6、结点与关系创建"><a href="#6、结点与关系创建" class="headerlink" title="6、结点与关系创建"></a>6、结点与关系创建</h2><p>创建汽车品牌结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;bank01.csv&quot; AS line</span><br><span class="line">CREATE(:Car&#123;name:line.bank,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102710.png"></p><p>&emsp;&emsp;</p><p>创建汽车车系结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">CREATE(p:Serise&#123;name:line.serise,count:line.count&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102711.png"></p><p>&emsp;&emsp;</p><p>创建关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOAD CSV WITH HEADERS FROM &quot;file:&#x2F;&#x2F;&#x2F;serise.csv&quot; AS line</span><br><span class="line">MATCH (entity1:Car&#123;name:line.bank&#125;),(entity2:Serise&#123;name:line.serise&#125;)</span><br><span class="line">CREATE(entity1)-[:Subtype&#123;type:line.relation&#125;]-&gt;(entity2)</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102712.png"></p><p>&emsp;&emsp;</p><p>指定唯一键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE  CONSTRAINT ON (b:Car)</span><br><span class="line">ASSERT b.name IS UNIQUE</span><br></pre></td></tr></table></figure><p><img src="https://voyager-m.gitee.io/picgo/test/102713.png"></p><p>&emsp;&emsp;</p><p>至此，我们完成了206个品牌结点，1921个车系结点，1937个关系的导入</p><p>来看看界面吧：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102714.png"><br>汽车品牌结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102715.png"><br>汽车车系结点<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102716.png"><br>2127个车系，206个汽车品牌，1921个关系都展现出来了，是不是很壮观呢，哈哈哈哈<br>&emsp;<br><img src="https://voyager-m.gitee.io/picgo/test/102717.png"><br>来个清晰的</p><h2 id="7、前端界面展示"><a href="#7、前端界面展示" class="headerlink" title="7、前端界面展示"></a>7、前端界面展示</h2><div class="note success simple"><p>先关闭酷狗，因为酷狗会占用“<a href="http://127.0.0.1:8000/%E2%80%9D%E8%BF%99%E4%B8%AA%E7%AB%AF%E5%8F%A3">http://127.0.0.1:8000/”这个端口</a></p></div><p>&emsp;&emsp;</p><p>修改neo4j_models.py中的密码，name和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def connectDB(self):</span><br><span class="line">self.graph &#x3D; Graph(&quot;bolt: &#x2F;&#x2F; localhost:7687&quot;, username&#x3D;&quot;neo4j&quot;, password&#x3D;&quot;admin&quot;)</span><br><span class="line">self.matcher &#x3D; NodeMatcher(self.graph)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口执行如下指令保证数据库服务是开着的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>打开cmd窗口进入kgcar项目目录下运行如下指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><p>功能界面如下：<br><img src="https://voyager-m.gitee.io/picgo/test/102718.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102719.png"></p><p>&emsp;&emsp;</p><p>对不起，这个例子我举的有点飘了，哈哈哈哈</p><p>特别感谢：张子良老师的知识图谱教程</p><p>整理于2020年10月27日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱-用python操纵neo4j数据库-以高速收费站记录为例</title>
      <link href="posts/c6f18f63/"/>
      <url>posts/c6f18f63/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h2><p>首先我们来看看数据是什么样子的</p><p><img src="https://voyager-m.gitee.io/picgo/test/103101.png"></p><p>这个数据实际上能做很多事情，但是本文主要重点主要是弄懂如何用python来建立neo4j数据库中的结点和关系，以后换了场景只需要在本文代码上结合neo4j官方文档进行修改即可。</p><h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">python3.8</span><br><span class="line">neo4j.4.1.3</span><br><span class="line"></span><br><span class="line">所需库：</span><br><span class="line">pip install py2no &#x3D;&#x3D;5.0b1 #注意版本不低于此版本</span><br><span class="line">pip install pandas</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-链接模块编写（模块名称：DataToNeo4jClass）"><a href="#3-链接模块编写（模块名称：DataToNeo4jClass）" class="headerlink" title="3.链接模块编写（模块名称：DataToNeo4jClass）"></a>3.链接模块编写（模块名称：DataToNeo4jClass）</h2><p>本文将必要的注释都写在了代码段中，所以这里直接给出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> py2neo <span class="keyword">import</span> Node, Graph, Relationship, NodeMatcher</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataToNeo4j</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;将excel中数据存入neo4j&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立连接&quot;&quot;&quot;</span></span><br><span class="line">        link = Graph(<span class="string">&quot;http://localhost:7474&quot;</span>, username=<span class="string">&quot;neo4j&quot;</span>, password=<span class="string">&quot;admin&quot;</span>)<span class="comment">#改成你自己的用户名和密码</span></span><br><span class="line">        self.graph = link</span><br><span class="line">        <span class="comment"># self.graph = NodeMatcher(link)</span></span><br><span class="line">        <span class="comment"># 定义label</span></span><br><span class="line">        self.buy = <span class="string">&#x27;buy&#x27;</span></span><br><span class="line">        self.sell = <span class="string">&#x27;sell&#x27;</span></span><br><span class="line">        self.graph.delete_all()</span><br><span class="line">        self.matcher = NodeMatcher(link)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        node3 = Node(&#x27;animal&#x27; , name = &#x27;cat&#x27;)</span></span><br><span class="line"><span class="string">        node4 = Node(&#x27;animal&#x27; , name = &#x27;dog&#x27;)  </span></span><br><span class="line"><span class="string">        node2 = Node(&#x27;Person&#x27; , name = &#x27;Alice&#x27;)</span></span><br><span class="line"><span class="string">        node1 = Node(&#x27;Person&#x27; , name = &#x27;Bob&#x27;)  </span></span><br><span class="line"><span class="string">        r1 = Relationship(node2 , &#x27;know&#x27; , node1)    </span></span><br><span class="line"><span class="string">        r2 = Relationship(node1 , &#x27;know&#x27; , node3) </span></span><br><span class="line"><span class="string">        r3 = Relationship(node2 , &#x27;has&#x27; , node3) </span></span><br><span class="line"><span class="string">        r4 = Relationship(node4 , &#x27;has&#x27; , node2)    </span></span><br><span class="line"><span class="string">        self.graph.create(node1)</span></span><br><span class="line"><span class="string">        self.graph.create(node2)</span></span><br><span class="line"><span class="string">        self.graph.create(node3)</span></span><br><span class="line"><span class="string">        self.graph.create(node4)</span></span><br><span class="line"><span class="string">        self.graph.create(r1)</span></span><br><span class="line"><span class="string">        self.graph.create(r2)</span></span><br><span class="line"><span class="string">        self.graph.create(r3)</span></span><br><span class="line"><span class="string">        self.graph.create(r4)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_node</span>(<span class="params">self, node_buy_key, node_sell_key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立节点&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> node_buy_key:</span><br><span class="line">            buy_node = Node(self.buy, name=name)</span><br><span class="line">            self.graph.create(buy_node)</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> node_sell_key:</span><br><span class="line">            sell_node = Node(self.sell, name=name)</span><br><span class="line">            self.graph.create(sell_node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_relation</span>(<span class="params">self, df_data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立联系&quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>, len(df_data)):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                print(list(self.matcher.match(self.buy).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;buy&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>)))</span><br><span class="line">                print(list(self.matcher.match(self.sell).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;sell&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>)))</span><br><span class="line">                rel = Relationship(self.matcher.match(self.buy).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;buy&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>).first(),</span><br><span class="line">                                   df_data[<span class="string">&#x27;money&#x27;</span>][m], self.matcher.match(self.sell).where(<span class="string">&quot;_.name=&quot;</span> + <span class="string">&quot;&#x27;&quot;</span> + df_data[<span class="string">&#x27;sell&#x27;</span>][m] + <span class="string">&quot;&#x27;&quot;</span>).first())</span><br><span class="line"></span><br><span class="line">                self.graph.create(rel)</span><br><span class="line">            <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">                print(e, m)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-数据提取与结点创立（类名称：invoice-neo4j）"><a href="#4-数据提取与结点创立（类名称：invoice-neo4j）" class="headerlink" title="4.数据提取与结点创立（类名称：invoice_neo4j）"></a>4.数据提取与结点创立（类名称：invoice_neo4j）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataToneo4jClass.DataToNeo4jClass <span class="keyword">import</span> DataToNeo4j</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#pip install py2no ==5.0b1 注意版本不低于此版本</span></span><br><span class="line"></span><br><span class="line">invoice_data=pd.read_excel(<span class="string">&#x27;./Invoice_data_Demo.xls&#x27;</span>, header=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(invoice_data)</span></span><br><span class="line"><span class="comment">#官方文档：https://py2neo.org/v4/index.html</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_extraction</span>():</span></span><br><span class="line">    <span class="comment">#取出购买方和销售方名称带list</span></span><br><span class="line"></span><br><span class="line">    node_buy_key=[]<span class="comment">#建立一个空列表存放购名称</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        node_buy_key.append(invoice_data[<span class="string">&#x27;购买方名称&#x27;</span>][i])</span><br><span class="line"></span><br><span class="line">    node_sell_key=[]<span class="comment">#建立一个空列表存放销售方名称</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        node_sell_key.append(invoice_data[<span class="string">&#x27;销售方名称&#x27;</span>][i])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去除重复的发票名称</span></span><br><span class="line">    node_buy_key=list(set(node_buy_key))</span><br><span class="line">    node_sell_key=list(set(node_sell_key))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将Value抽出做node</span></span><br><span class="line">    node_list_value=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,len(invoice_data.columns)):</span><br><span class="line">            <span class="comment">#将表头名称invoice_data.colums[i]取出</span></span><br><span class="line">            node_list_value.append(invoice_data[invoice_data.columns[n]][i])</span><br><span class="line"></span><br><span class="line">    <span class="comment">#去重</span></span><br><span class="line">    node_list_value=list(set(node_list_value))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将list中的浮点数以及整数类型全部转换为string类型</span></span><br><span class="line"></span><br><span class="line">    node_list_value=[str(i) <span class="keyword">for</span> i <span class="keyword">in</span> node_list_value]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node_buy_key,node_sell_key,node_list_value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relation_extraction</span>():</span></span><br><span class="line">    <span class="comment">#联系数据抽取</span></span><br><span class="line"></span><br><span class="line">    links_dict=&#123;&#125;</span><br><span class="line">    sell_list=[]</span><br><span class="line">    money_list=[]</span><br><span class="line">    buy_list=[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(invoice_data)):</span><br><span class="line">        money_list.append(invoice_data[invoice_data.columns[<span class="number">19</span>]][i])  <span class="comment"># 金额</span></span><br><span class="line">        sell_list.append(invoice_data[invoice_data.columns[<span class="number">10</span>]][i])  <span class="comment"># 销售方方名称</span></span><br><span class="line">        buy_list.append(invoice_data[invoice_data.columns[<span class="number">6</span>]][i])  <span class="comment"># 购买方名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#将数据中的int类型的数据全部变成string类型的</span></span><br><span class="line">    sell_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> sell_list]</span><br><span class="line">    buy_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> buy_list]</span><br><span class="line">    money_list = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> money_list]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 整合数据，将三个list整合成一个dict</span></span><br><span class="line">    links_dict[<span class="string">&#x27;buy&#x27;</span>] = buy_list</span><br><span class="line">    links_dict[<span class="string">&#x27;money&#x27;</span>] = money_list</span><br><span class="line">    links_dict[<span class="string">&#x27;sell&#x27;</span>] = sell_list</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将数据转成DataFrame</span></span><br><span class="line">    df_data = pd.DataFrame(links_dict)</span><br><span class="line">    print(df_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_data</span><br><span class="line"></span><br><span class="line"><span class="comment">#relation_extraction()</span></span><br><span class="line">create_data=DataToNeo4j()</span><br><span class="line">create_data.create_node(data_extraction()[<span class="number">0</span>], data_extraction()[<span class="number">1</span>])</span><br><span class="line">create_data.create_relation(relation_extraction())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>*<strong>强调一下：</strong>上面两个代码段，需要将两个文件放在一起，一点一点看懂，虽然有些花时间吗，但是收获不会少，遇到不懂的百度，并创建一个test文件，将不懂的点的demo复制到test文件中运行一下，多打印一些东西，分析下结果就全明白了。</p><h2 id="5-结果展示"><a href="#5-结果展示" class="headerlink" title="5.结果展示"></a>5.结果展示</h2><p>首先打开cmd执行以下代码将neo4j的服务开起来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neo4j.bat console</span><br></pre></td></tr></table></figure><p>然后运行invoice_neo4j类</p><p>然后浏览器访问<a href="http://localhost:7474/">http://localhost:7474</a> 得到如下结果</p><p><img src="https://voyager-m.gitee.io/picgo/test/103102.png"><br><img src="https://voyager-m.gitee.io/picgo/test/103103.png"><br><img src="https://voyager-m.gitee.io/picgo/test/103104.png"></p><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6.写在后面"></a>6.写在后面</h2><pre><code>感谢教程：    知识图谱实战系列（python版），本文在教程代码上进行修改并添加了更多的注释。本人将项目代码放在了百度网盘：    链接：https://pan.baidu.com/s/1PibmNxtn9JXT4SVOF4sJ_Q     提取码：ghsy 欢迎一起交流学习：本人QQ：1518887260</code></pre><p>整理于2020年10月31日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
            <tag> neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱初识-知识图谱与语义技术简介</title>
      <link href="posts/ac2a99b3/"/>
      <url>posts/ac2a99b3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近在学习知识图谱相关知识和技术，所以会在博客做一个记录，首先对学习过程中所读资料的作者表示衷心的感谢，其次，在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。</p><p>本文主要是对整个知识图谱体系进行一个大体上的认识，明白知识图谱是个什么东西，大致包涵那几块内容，每一块大致用到了哪些技术，而对于其中的技术，后面我会慢慢整理。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102401.png"></p><h2 id="知识图谱技术概览"><a href="#知识图谱技术概览" class="headerlink" title="知识图谱技术概览"></a>知识图谱技术概览</h2><h3 id="知识图谱概念演化"><a href="#知识图谱概念演化" class="headerlink" title="知识图谱概念演化"></a>知识图谱概念演化</h3><p><img src="https://voyager-m.gitee.io/picgo/test/102402.png"></p><p>1960年，语义网络作为知识表示的一种方法被题出。<br>1980s，哲学理念“本体”被引入到人工智能领域被用来刻画知识。<br>1989年，Tim Berners-Lee发明了万维网（Linked Information System）。<br>1998年，从超文本链接到语义链接。<br>2006年，Tim突出强调了语义网络的本质是要建立开放数据之间的链接。<br>2012年，谷歌发布了基于知识图谱的搜索引擎产品。</p><p>从以上历程我们可以看出，知识图谱其实是得益于Web的发展，其中有着KR,NLP,Web,AI等多方面的影子。</p><h3 id="知识图谱的本质"><a href="#知识图谱的本质" class="headerlink" title="知识图谱的本质"></a>知识图谱的本质</h3><p>知识图谱整个体系还是比较大的，目前没有一个标准的定义，其中“Exploiting Linked Data and Knowledge Graphs in Large Organisations”这本书对知识图谱的定义为：</p><p>A knowledge graph consists of a set of interconnected typed entities and their attributes.</p><p>翻译过来就是：知识图谱是由一些相互连接的实体和它们的属性构成的。</p><p>其中最经典的就是三元组：<br><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>其实就一主，一谓，一宾。比如上图的人工智能，之父是，图灵。实际上就是我们所说的“人工智能之父是图灵”</p><p>我们也可以从不同方面来看知识图谱：</p><p><strong>从Web角度</strong> 像建立文本之间的超链接一样，建立数据之间的语义链接，并支持语义搜索。<br><strong>从NLP角度</strong> 怎样从文本中抽取语义和结构化数据。<br><strong>从KR角度</strong>  怎样利用计算机符号来表示和处理知识。<br><strong>从AI角度</strong>  怎样利用知识库来辅助计算机理解人的语言。<br><strong>从DB角度</strong>  用图的方式去存储知识。</p><p>所以啊，其实做好KG要利用好KR，NLP，Web，ML，DB多方面的方法和技术。</p><p>我们再举个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102404.png"></p><p>“聪明的Ai”其实是从学习的角度进行感知，识别，判断，依靠深度学习。<br>“有学识的Ai”其实是从推理的角度进行思考，语言，推理，依靠知识图谱。</p><h2 id="知识图谱技术简介"><a href="#知识图谱技术简介" class="headerlink" title="知识图谱技术简介"></a>知识图谱技术简介</h2><p><img src="https://voyager-m.gitee.io/picgo/test/102405.png"></p><p>技术体系其实可以概括为：知识表示，知识抽取，知识问答，知识推理，知识融合，知识众包。<br>途中下面表示的是数据部分的主要来源：KBP,D2R,Linked MEDIA/Visual Genome,OneM2M,WikiData。</p><h3 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h3><p>知识表示是研究怎么样用计算机符号来表示人脑中的知识，以及怎么样通过符号之间的运算来模拟人脑的推理课程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102406.png"></p><p>图上是整个知识图谱的演进过程（知识演进也是一个很有意思的方向，有机会后面整理哦），其实说白了就是一个基于数理逻辑的知识表示到基于向量空间学习分布式知识表的过程。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102407.png"></p><p>以上这个图是官方给出的语义知识网表示框架，由于本篇文章是知识图谱概览，所以我们大概来看一下这个框架。最底层的URI/IRI是网络连接，上面一层是XML和RDF是资源表示框架，而SPARQL是一种知识查询语言。而蓝色部分（知识推理框架）包含了RDFS和OWL框架。下面我们对其中的几个框架做进一步解释：</p><p><strong>RDF</strong>：资源描述框架（Resource Description Framework）,它是由W3C制定的，是用来描述实体/资源的标准数据模型。</p><p><img src="https://voyager-m.gitee.io/picgo/test/102403.png"></p><p>还是以上面这个图为例，在知识图谱中我们一般用RDF形式化的来表示三元关系（Subject，predicate，object）。</p><p>RDFS在RDF的基础上定义了一些固定的关键词：Class，subClassOf,type,Property,subPropertyOf,Domain,Range以及多了Schema层。如下图：</p><p><img src="https://voyager-m.gitee.io/picgo/test/102408.png"></p><p><strong>OWL</strong>：网络本体语言（Web Ontology Language）这个本体实际上是从哲学里面来的，OWL在RDF语言上扩充了Schema层，使之支持推理等操作。</p><pre><code>Ontology in Philosophy：Ontology is the philosophical study of the nature of being, becoming, existence or reality, as well asthe basic categories of being and their relations.                                  Tom Gruber，Founder of Siri哲学本体论：本体论是对存在，成为，存在或存在的本质以及存在及其关系的基本类别的哲学研究。                                                韦伯斯特Ontology in Computer Science and Artificial Intelligence：An ontology is a description (like a formal specification of a program) of the concepts andrelationships that can formally exist for an agent or a community of agents.                                Tom Gruber，Founder of Siri计算机科学与人工智能中的本体论：本体是对代理或代理社区可以正式存在的概念和关系的描述（如程序的正式说明）。                                Siri创始人汤姆·格鲁伯Web OntologiesOntologies based on web standards such as RDFS/OWL.OWL is based on Description Logic, avery very long history of research in Artificial Intelligence.基于Web标准的本体(如RDFS/OWL.OWL)是基于描述逻辑(DescriptionLogic)的，人工智能研究历史悠久。</code></pre><p><img src="https://voyager-m.gitee.io/picgo/test/102409.png"></p><p><strong>SPARQL</strong>：SPARQL是RDF的查询语言，它基于RDF数据模型，可以对不同的数据集撰写复杂的连接，由所有主流的图数据库支持。其操作如：<br><img src="https://voyager-m.gitee.io/picgo/test/102410.png"></p><p><strong>JSON-LD</strong>：（JSON for Linking Data） 适用于作为程序之间做数据交换,在网页中嵌入语义数据和Restful Web Service。存储格式如:<br><img src="https://voyager-m.gitee.io/picgo/test/102411.png"></p><p><strong>知识图谱的分布式表示–KG Embedding</strong>：在保留语义的同时，将知识图谱中的实体和关系映射到连续的稠密的低维向量空间。<br><img src="https://voyager-m.gitee.io/picgo/test/102412.png"></p><h3 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h3><p>知识抽取大多是结合NLP和KG进行的。<br><img src="https://voyager-m.gitee.io/picgo/test/102413.png"></p><p>先是从网络获取大量的非结构化的文本数据，经过文本预处理后得到干净的文本数据，然后借助分词，词性标注，语法解析，依存分析等技术对文本进行处理，我们得到词法和句法的分层，接下来我们对文本进行NER命名实体识别和实体链接，最后通过关系抽取和事件抽取最终得到KR用的三元组，多元关系，模态知识等。</p><p><strong>知识抽取的主要方法</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102414.png"></p><h3 id="知识存储"><a href="#知识存储" class="headerlink" title="知识存储"></a>知识存储</h3><p>知识比数据的结构更加复杂，知识存储需要综合考虑图的特点，复炸的知识存储结构，索引和查询（支持推理）的优化等问题。<br>典型的知识存储引擎分为基于关系数据库的存储和基于原生图的存储。<br>在实践过程中，多为混合存储结构，图存储并非必须<br><img src="https://voyager-m.gitee.io/picgo/test/102415.png"></p><h3 id="知识问答"><a href="#知识问答" class="headerlink" title="知识问答"></a>知识问答</h3><p>KBQA（Knowledge-Based Question Answer，基于知识库的问题回答）<br>以直接而准确的方式回答用户自然语言提问的自动问答系统将构成下一代搜索引擎的基本形态。<br><img src="https://voyager-m.gitee.io/picgo/test/102416.png"></p><p>我们来举几个例子：<br><img src="https://voyager-m.gitee.io/picgo/test/102417.png"></p><p>传统的搜索引擎，只会将匹配的资源列在页面，我们需要自己去筛选理解其中的信息，以获取自己真正想得到的问题的答案。而嵌入了知识图谱的搜索引擎似乎更“智能”了，它能直接很直观的返回我们想要的真正的问题的答案。是不是很方便呢！</p><p>我们以一个例子来看看KBQA的实现流程:<br><img src="https://voyager-m.gitee.io/picgo/test/102418.png"></p><p>当你问“姚明的老婆多大了？”这个问题的时候，首先会对这个问题进行语义解析得到问题的语义表示，然后再KB中查找答案，最终将答案返回，其中KB知识库的数据数量和质量直接决定了该系统的质量。</p><h3 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h3><p>简单的来说，推理就是指基于已知事实推出来未知的事实的过程。<br>目前大部分搜索引擎都已经有了一定的推理能力。比如：<br><img src="https://voyager-m.gitee.io/picgo/test/102419.png"></p><p><img src="https://voyager-m.gitee.io/picgo/test/102420.png"></p><p><strong>基于描述逻辑的推理：本体推理</strong>：</p><p>描述逻辑：描述逻辑（decription logic）是一种用只是表示的逻辑语言和以其为对象的推理方法，主要用于描述概念分类及其概念之间的关系。描述逻辑是当前语义网发展中本体的理论基础。</p><p>主要方法：</p><p>（1）基于表运算（Tableaux）及改进的方法：FaCT++，Racer，Pellet Hermit等</p><p>（2）基于一阶查询重写的方法（Ontology based data acess，基于本体的数据访问）</p><p>（3）基于产生式规则的算法（如KAON、RDFox等）。</p><p>（4）回答集程序 Answer set programming</p><p><strong>基于统计规则挖掘的推理</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102421.png"></p><p><strong>基于表示学习的推理-Representational Learning</strong><br><img src="https://voyager-m.gitee.io/picgo/test/102422.png"></p><h3 id="知识融合"><a href="#知识融合" class="headerlink" title="知识融合"></a>知识融合</h3><p>知识融合有一些其它叫法: Record Linkage，Entity Resolution，DataLinking，Knowledge Fusion，Entity Alignment.. . . . .<br>都是指在不同数据集中找出同一个实体的描述记录，主要目的是对不同数据源中的实体信息进行整合，形成更加全面的实体信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102423.png"></p><p>我们来用上图这个例子通俗一点来说一说什么叫知识融合，上图中下面一层的头像有7个，但是上面一层的头像只有2个，是因为下面一层的头像都是由上面两个头像戴上眼镜，假发等而来，所以我们只需要抓住上面两个头像进行处理就行了。<br>这就好比说，“洋芋、荷兰薯、地蛋、薯仔、土豆、荷兰薯、番仔薯、马铃薯”都指的是一个东西，知识融合要做的就是将这8个别名融合成一个名称。</p><h3 id="知识众包"><a href="#知识众包" class="headerlink" title="知识众包"></a>知识众包</h3><p>这个概念通俗的讲就是允许网站基于一定的方式，比如RDFa，JASON-LD等方式在网页和邮件等数据中嵌入语义化的数据，让个人和企业定制自己需要的知识图谱信息。<br><img src="https://voyager-m.gitee.io/picgo/test/102424.png"><br><img src="https://voyager-m.gitee.io/picgo/test/102425.png"></p><p>特别感谢：<br>上海交大的王昊奋博士的教程和东南大学漆桂林教授的文章以及其他资源的作者。</p><p>在整理过程中若本人理解有偏差或者有不到位的地方望大家多多包涵指正。<br>个人qq:1518887260</p><p>整理于2020年10月24日</p>]]></content>
      
      
      <categories>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO-5-go语言能做什么事情</title>
      <link href="posts/ac797bd6/"/>
      <url>posts/ac797bd6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go语言能做什么"><a href="#Go语言能做什么" class="headerlink" title="Go语言能做什么"></a>Go语言能做什么</h1><h2 id="一、我们为什么选择Go语言"><a href="#一、我们为什么选择Go语言" class="headerlink" title="一、我们为什么选择Go语言"></a>一、我们为什么选择Go语言</h2><p>选择Go语言的原因可能会有很多，关于Go语言的特性、优势等，我们在之前的文档中也已经介绍了很多了。但是最主要的原因，应该是基于以下两方面的考虑：</p><ol><li><p>执行性能</p><p>缩短API的响应时长，解决批量请求访问超时的问题。在Uwork的业务场景下，一次API批量请求，往往会涉及对另外接口服务的多次调用，而在之前的PHP实现模式下，要做到并行调用是非常困难的，串行处理却不能从根本上提高处理性能。而GO语言不一样，通过协程可以方便的实现API的并行处理，达到处理效率的最大化。 依赖Golang的高性能HTTP Server，提升系统吞吐能力，由PHP的数百级别提升到数千里甚至过万级别。</p></li><li><p>开发效率</p><p>GO语言使用起来简单、代码描述效率高、编码规范统一、上手快。 通过少量的代码，即可实现框架的标准化，并以统一的规范快速构建API业务逻辑。 能快速的构建各种通用组件和公共类库，进一步提升开发效率，实现特定场景下的功能量产。</p></li></ol><h2 id="二、Go语言能做什么"><a href="#二、Go语言能做什么" class="headerlink" title="二、Go语言能做什么"></a>二、Go语言能做什么</h2><p>Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go 语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。</p><p>鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域，目前国外很多云平台都是采用Go开发。</p><ul><li>服务器编程，以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</li><li>分布式系统、数据库代理器、中间件等，例如Etcd。</li><li>网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用，而且Go内置的net/http包基本上把我们平常用到的网络功能都实现了。</li><li>数据库操作</li><li>开发云平台，目前国外很多云平台在采用Go开发</li></ul><h2 id="三、国内外有哪些企业或项目使用Go语言"><a href="#三、国内外有哪些企业或项目使用Go语言" class="headerlink" title="三、国内外有哪些企业或项目使用Go语言"></a>三、国内外有哪些企业或项目使用Go语言</h2><p>Go发布之后，很多公司特别是云计算公司开始用Go重构他们的基础架构，很多都是直接采用Go进行了开发，最近热火朝天的Docker就是采用Go开发的。</p><p>使用 Go 语言开发的开源项目非常多。早期的 Go 语言开源项目只是通过 Go 语言与传统项目进行C语言库绑定实现，例如 Qt、Sqlite 等；后期的很多项目都使用 Go 语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用 Go 语言原生开发项目的出现。</p><ul><li><p>云计算基础设施领域</p><p>代表项目：docker、kubernetes、etcd、<a href="http://tonybai.com/2015/07/06/implement-distributed-services-registery-and-discovery-by-consul/">consul</a>、cloudflare CDN、七牛云存储等。</p></li><li><p>基础软件</p><p>代表项目：<a href="https://github.com/pingcap/tidb">tidb</a>、<a href="https://github.com/influxdata/influxdb">influxdb</a>、<a href="https://github.com/cockroachdb/cockroach">cockroachdb</a>等。</p></li><li><p>微服务</p><p>代表项目：<a href="https://github.com/go-kit/kit">go-kit</a>、<a href="https://github.com/micro/micro">micro</a>、monzo bank的<a href="https://github.com/monzo">typhon</a>、<a href="https://www.bilibili.com/">bilibili</a>等。</p></li><li><p>互联网基础设施</p><p>代表项目：<a href="https://github.com/ethereum/go-ethereum">以太坊</a>、<a href="https://github.com/hyperledger">hyperledger</a>等。</p></li></ul><blockquote><p>采用Go的一些国外公司，如Google、Docker、Apple、Cloud Foundry、CloudFlare、Couchbase、CoreOS、Dropbox、MongoDB、AWS等公司；</p><p>采用Go开发的国内企业：如阿里云CDN、百度、小米、七牛、PingCAP、华为、金山软件、猎豹移动、饿了么等公司。</p></blockquote><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。基于lxc的一个虚拟打包工具，能够实现PAAS平台的组建。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。</p><p>项目链接：</p><p><a href="https://github.com/docker/docker">https://github.com/docker/docker</a></p><h3 id="go语言"><a href="#go语言" class="headerlink" title="go语言"></a>go语言</h3><p>Go 语言自己的早期源码使用C语言和汇编语言写成。从 Go 1.5 版本后，完全使用 Go 语言自身进行编写。Go 语言的源码对了解 Go 语言的底层调度有极大的参考意义，建议希望对 Go 语言有深入了解的读者读一读。</p><p>项目链接：</p><p><a href="https://github.com/golang/go">https://github.com/golang/go</a></p><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。</p><p>项目链接：</p><p><a href="https://github.com/kubernetes/kubernetes">https://github.com/kubernetes/kubernetes</a></p><h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>一款分布式、可靠的 KV 存储系统，可以快速进行云配置。</p><p>项目链接：</p><p><a href="https://github.com/coreos/etcd">https://github.com/coreos/etcd</a></p><h3 id="beego"><a href="#beego" class="headerlink" title="beego"></a>beego</h3><p>beego 是一个类似 Python的 Tornado 框架，采用了 RESTFul 的设计思路，使用 Go 语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。</p><p>项目链接：</p><p><a href="https://github.com/astaxie/beego">https://github.com/astaxie/beego</a></p><h3 id="martini"><a href="#martini" class="headerlink" title="martini"></a>martini</h3><p>一款快速构建模块化的 Web 应用的 Web 框架。</p><p>项目链接：</p><p><a href="https://github.com/go-martini/martini">https://github.com/go-martini/martini</a></p><h3 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h3><p>国产的优秀分布式 Redis 解决方案。</p><p>项目链接：</p><p><a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p><h3 id="delve"><a href="#delve" class="headerlink" title="delve"></a>delve</h3><p>Go语言</p><p>强大的调试器，被很多集成环境和编辑器整合。</p><p>项目链接：</p><p><a href="https://github.com/derekparker/delve">https://github.com/derekparker/delve</a></p><h3 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h3><p>Facebook也在用，为此他们还专门在Github上建立了一个开源组织facebookgo，大家可以通过<a href="https://github.com/facebookgo%E8%AE%BF%E9%97%AE%E6%9F%A5%E7%9C%8Bfacebook%E5%BC%80%E6%BA%90%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%AF%94%E5%A6%82%E8%91%97%E5%90%8D%E7%9A%84%E6%98%AF%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7%E7%9A%84grace%E3%80%82">https://github.com/facebookgo访问查看facebook开源的项目，比如著名的是平滑升级的grace。</a></p><h3 id="Uber"><a href="#Uber" class="headerlink" title="Uber"></a>Uber</h3><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>腾讯作为国内的大公司，还是敢于尝试的，尤其是Docker容器化这一块，他们在15年已经做了docker万台规模的实践，具体可以参考<a href="http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice">http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice</a> 。</p><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><p>目前所知的百度的使用是在运维这边，是百度运维的一个BFE项目，负责前端流量的接入。他们的负责人在2016年有分享，大家可以看下这个 <a href="http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend">http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend</a> 。</p><p>其次就是百度的消息系统。负责公司手百消息通讯系统服务器端开发及维护。</p><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><p>京东云消息推送系统、云存储，以及京东商城等都有使用Go做开发。</p><h3 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h3><p>小米对Golang的支持，莫过于运维监控系统的开源，也就是 <a href="http://open-falcon.com/">http://open-falcon.com/</a> 。</p><p>此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。</p><h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><p>360对Golang的使用也不少，一个是开源的日志搜索系统Poseidon，托管在Github上，<a href="https://github.com/Qihoo360/poseidon">https://github.com/Qihoo360/poseidon</a>.</p><p>还有360的推送团队也在使用，他们还写了篇博文在Golang的官方博客上 <a href="https://blog.golang.org/qihoo%E3%80%82">https://blog.golang.org/qihoo。</a></p><h3 id="七牛云"><a href="#七牛云" class="headerlink" title="七牛云"></a>七牛云</h3><p>七牛云用了近50万行代码，来实现整个产品。七牛云存储产品网址：<a href="http://qiniu.com/%E3%80%82%E4%B8%8A%E7%BA%BF%E6%97%B6%E9%97%B4%EF%BC%9A2011-9-1%E3%80%82%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%9A%E6%95%B4%E4%B8%AA%E4%BA%A7%E5%93%81%EF%BC%88%E5%8C%85%E6%8B%AC%E5%9F%BA%E7%A1%80%E6%9C%8D%E5%8A%A1%E3%80%81Web%E7%AB%AF%E3%80%81%E7%BB%9F%E8%AE%A1%E5%B9%B3%E5%8F%B0%E3%80%81%E5%90%84%E7%B1%BB%E5%B0%8F%E5%B7%A5%E5%85%B7%E7%AD%89%E7%AD%89%EF%BC%89Go%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%E5%8D%A0%E6%AF%94%EF%BC%9A99.9%%E6%97%A5">http://qiniu.com/。上线时间：2011-9-1。应用范围：整个产品（包括基础服务、Web端、统计平台、各类小工具等等）Go代码行数占比：99.9%日</a> PV：保密</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><p>美团后台流量支撑程序。应用范围：支撑主站后台流量（排序，推荐，搜索等），提供负载均衡，cache，容错，按条件分流，统计运行指标（qps，latency）等功能。</p><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><p>基础服务平台。</p><p>###金山微看 </p><p>应用范围：服务接口，后台流程服务，消息系统，图片系统</p><h3 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h3><p>搜狗推送系统。Push系统中用于维持与客户端连接的部分。</p><h3 id="QOR-模块化的电商系统"><a href="#QOR-模块化的电商系统" class="headerlink" title="QOR - 模块化的电商系统"></a>QOR - 模块化的电商系统</h3><ul><li>QOR官网: <a href="https://link.zhihu.com/?target=http://getqor.com">QOR: E-commerce &amp; CMS SDK written in Go</a></li><li>github地址: qor/qor · GitHub</li><li>应用范围: 整个产品</li></ul><h3 id="weico"><a href="#weico" class="headerlink" title="weico"></a>weico</h3><p>产品名：weico 3.0， 服务端所有代码都是用Go实现。</p><h3 id="仙侠道"><a href="#仙侠道" class="headerlink" title="仙侠道"></a>仙侠道</h3><ul><li>产品网址：[仙侠道官网 - 心动游戏](仙侠道官网 - 心动游戏)</li><li>应用范围： 游戏服务端（通讯、逻辑、数据存储）</li></ul><h3 id="快玩游戏"><a href="#快玩游戏" class="headerlink" title="快玩游戏"></a>快玩游戏</h3><ul><li>网址：<a href="%E5%BF%AB%E7%8E%A9%E5%B0%8F%E6%B8%B8%E6%88%8F,%E5%8D%95%E6%9C%BA%E6%B8%B8%E6%88%8F,%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F,%E5%BF%AB%E7%8E%A9%E6%B8%B8%E6%88%8F,%E5%BF%AB%E7%8E%A9%E6%B8%B8%E6%88%8F%E7%9B%92">快玩小游戏,单机游戏,网页游戏,快玩游戏,快玩游戏盒</a> </li><li>应用范围：实时消息系统、用户认证、用户会话、统一统计接口</li></ul><h3 id="盛大云CDN"><a href="#盛大云CDN" class="headerlink" title="盛大云CDN"></a>盛大云CDN</h3><ul><li>网址：盛大云计算</li><li>应用范围：CDN的调度系统、分发系统、监控系统、短域名服务，CDN内部开放平台、运营报表系统以及其他一些小工具等</li></ul><h3 id="Bmob移动后端云服务平台"><a href="#Bmob移动后端云服务平台" class="headerlink" title="Bmob移动后端云服务平台"></a>Bmob移动后端云服务平台</h3><ul><li>产品网址：Bmob移动后端云服务平台</li><li>应用范围：Restful API(使用Beego)、统计分析平台、常用服务如发邮件、队列异步处理、统计用户空间和接口请求</li></ul><h3 id="群策"><a href="#群策" class="headerlink" title="群策"></a>群策</h3><ul><li>网址：[群策 - 统一团队沟通，高效完成工作](群策 - 统一团队沟通，高效完成工作)</li><li>应用范围：全系统</li></ul><h3 id="BiddingX-DSP广告投放系统"><a href="#BiddingX-DSP广告投放系统" class="headerlink" title="BiddingX DSP广告投放系统"></a>BiddingX DSP广告投放系统</h3><ul><li>网址：BiddingX_专业的DSP解决方案供应商</li><li>应用范围：竞价投放、曝光统计、点击跳转</li></ul><h3 id="街坊四邻"><a href="#街坊四邻" class="headerlink" title="街坊四邻"></a>街坊四邻</h3><ul><li>网址：首页 - 街坊四邻</li><li>应用范围：后台服务</li></ul><h3 id="Leanote"><a href="#Leanote" class="headerlink" title="Leanote"></a>Leanote</h3><ul><li>网址：Leanote</li></ul><h3 id="Bearychat"><a href="#Bearychat" class="headerlink" title="Bearychat"></a>Bearychat</h3><ul><li>网址：BearyChat</li></ul><h3 id="宅豆"><a href="#宅豆" class="headerlink" title="宅豆"></a>宅豆</h3><ul><li>网址：宅豆网 - 自筑最美家，宅豆随你搭</li></ul><h3 id="白板-设计图讨论工具"><a href="#白板-设计图讨论工具" class="headerlink" title="白板- 设计图讨论工具"></a>白板- 设计图讨论工具</h3><ul><li>网址：白板</li></ul><h3 id="实验楼"><a href="#实验楼" class="headerlink" title="实验楼"></a>实验楼</h3><ul><li>网址：实验楼 - 第一家以实验为核心的IT在线教育平台</li></ul><h3 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h3><p>中间件和弹性调度用 Java 和 Go 编写，微博视频转码及存储服务用 Go 编写。</p><h3 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h3><p>VR 后台系统中间件，VR 端的 HTTP 接口。</p><h3 id="猎豹移动"><a href="#猎豹移动" class="headerlink" title="猎豹移动"></a>猎豹移动</h3><p>消息推送</p><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><p>网易蜂巢容器公有云。</p><h3 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h3><p>弹幕</p><h3 id="巨人网络"><a href="#巨人网络" class="headerlink" title="巨人网络"></a>巨人网络</h3><p>部分手机游戏的服务端。</p><h3 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h3><p>Nsq：Nsq 是由Go语言开发的高性能、高可用消息队列系统，性能非常高，每天能处理数十亿条的消息；</p><p>Packer:用来生成不同平台的镜像文件，例如VM、vbox、AWS等，作者是vagrant的作者</p><p>Skynet：分布式调度框架</p><p>Doozer：分布式同步工具，类似ZooKeeper</p><p>Heka：mazila开源的日志处理系统</p><p>Cbfs：couchbase开源的分布式文件系统</p><p>Tsuru：开源的PAAS平台，和SAE实现的功能一模一样</p><p>Groupcache：memcahe作者写的用于Google下载系统的缓存系统</p><p>God：类似redis的缓存系统，但是支持分布式和扩展性</p><p>Gor：网络流量抓包和重放工具</p><p>还有很多，比如阿里中间件、聚美优品、高升控股、探探、斗鱼直播、人人车、亚信、Udesk、方付通、招财猫、三一集团、美餐网等。一般的选择，都是选择用于自己公司合适的产品系统来做，比如消息推送的、监控的、容器的等，Golang特别适合做网络并发的服务，这是他的强项，所以也是被优先用于这些项目。Go语言作为一门大型项目开发语言，在很多大公司相继使用，甚至完全转向Go开发。</p><h2 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h2><p>当然，一个技术能不能发展起来，关键还要看三点。</p><ul><li><strong>有没有一个比较好的社区。</strong>像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。</li><li><strong>有没有一个工业化的标准。</strong>像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。</li><li><strong>有没有一个或多个杀手级应用。</strong>C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。</li></ul><p>上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：</p><ul><li><strong>学习曲线是否低，上手是否快。</strong>这点非常重要，C++ 在这点上越做越不好了。</li><li><strong>有没有一个不错的提高开发效率的开发框架。</strong>如：Java 的 Spring 框架，C++ 的 STL 等。</li><li><strong>是否有一个或多个巨型的技术公司作为后盾。</strong>如：Java 和 Linux 后面的 IBM、Sun……</li><li><strong>有没有解决软件开发中的痛点。</strong>如：Java 解决了 C 和 C++ 的内存管理问题。</li></ul><p>用这些标尺来量一下 Go 语言，我们可以清楚地看到：</p><ul><li>Go 语言容易上手；</li><li>Go 语言解决了并发编程和写底层应用开发效率的痛点；</li><li>Go 语言有 Google 这个世界一流的技术公司在后面；</li><li>Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。</li></ul><p>所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。</p><blockquote><p>也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。</p></blockquote><p>好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。</p><ul><li>Docker 上手很容易。</li><li>Docker 解决了运维中的环境问题以及服务调度的痛点。</li><li>Docker 的生态圈中有大公司在后面助力。比如 Google。</li><li>Docker 产出了工业界标准 OCI。</li><li>Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。</li><li>……</li></ul><p>所以，虽然几年前的 Docker ，当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。</p><p>同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。</p><p>最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。</p><p>技术的发展过程非常重要。因为你可以清楚地看到了这种新技术的生态圈发展过程。让我们收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。</p><p>从中，我们看到了非常具体的各种思潮和思路，这些东西比起 技术本身来说更有价值。因为，这不但让我们重新思考已经掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。不但有了技术优势，而且这些知识还让我们的技术生涯多了很多的可能性。</p><p>这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。</p><p>一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。</p><p>Go的应用范围一直在扩大，云计算，微服务，区块链，哪里都有用Go写的重量级项目。docker/kubernetes生态圈，几百/千万行代码，基本统治了云原生应用市场。去年大热的区块链，以太坊的geth，比特币的btcd，闪电网络的lnd，都是Go语言开发。还是那句话，多看看各种语言的生态，或许都并没有你想象的那么不堪。。。Go语言设计上确实不够“先进”，但也是另一种“务实”。其实go不管在国内还是国外已经很受待见了，国外google用的很多，uber也在用，国内有著名的今日头条，每日千亿级的访问妥妥的。多少语言终其一生都没有这么大的应用场景。</p><div class="note success simple"><p>整理此博客只为方便往后翻阅复习，侵删。</p></div>]]></content>
      
      
      <categories>
          
          <category> GO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地项目上传gitee/github</title>
      <link href="posts/c37fef3/"/>
      <url>posts/c37fef3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="在gitee-github上创建一个空的仓库（假如为demo）"><a href="#在gitee-github上创建一个空的仓库（假如为demo）" class="headerlink" title="在gitee/github上创建一个空的仓库（假如为demo）"></a>在gitee/github上创建一个空的仓库（假如为demo）</h3><h3 id="在本地新建一个空文件夹（假如叫gitee）"><a href="#在本地新建一个空文件夹（假如叫gitee）" class="headerlink" title="在本地新建一个空文件夹（假如叫gitee）"></a>在本地新建一个空文件夹（假如叫gitee）</h3><h3 id="在demo文件夹下执行指令"><a href="#在demo文件夹下执行指令" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 你的https仓库地址</span><br></pre></td></tr></table></figure><h3 id="在gitee文件夹下面执行指令"><a href="#在gitee文件夹下面执行指令" class="headerlink" title="在gitee文件夹下面执行指令"></a>在gitee文件夹下面执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init </span><br></pre></td></tr></table></figure><h3 id="将需要上传的项目复制到仓库demo文件夹下"><a href="#将需要上传的项目复制到仓库demo文件夹下" class="headerlink" title="将需要上传的项目复制到仓库demo文件夹下"></a>将需要上传的项目复制到仓库demo文件夹下</h3><h3 id="在demo文件夹下执行指令-1"><a href="#在demo文件夹下执行指令-1" class="headerlink" title="在demo文件夹下执行指令"></a>在demo文件夹下执行指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commt -m &#x27;这里随便写&#x27;</span><br><span class="line">git push </span><br></pre></td></tr></table></figure><h3 id="这里的add-中的-的意思是本文件夹下面的全部文件"><a href="#这里的add-中的-的意思是本文件夹下面的全部文件" class="headerlink" title="这里的add .中的.的意思是本文件夹下面的全部文件"></a>这里的add .中的.的意思是本文件夹下面的全部文件</h3>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo从一台电脑转移至另一台电脑</title>
      <link href="posts/a17e1e97/"/>
      <url>posts/a17e1e97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"><a href="#前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！" class="headerlink" title="前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！"></a>前几天利用Hexo搭建了自己的博客系统，整个搭建的过程并不复杂，但是要将自己的博客的漂亮对于一个新手来说还是比较耗时间的，它要求对配置文件里面的关键字比较熟悉，那么如何熟悉这些关键字呢？答案是：看文档！</h3><h3 id="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："><a href="#既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：" class="headerlink" title="既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下："></a>既然我们将自己的博客“打扮”成我们喜欢的模样花了这么久，那么是不是就是说我们每次重装系统或者更换了电脑后都需要重新配置呢？当然不是。今天我解决了如何将Hexo博客系统完美迁移至另一台电脑上。写此文章，记录一下：</h3><h2 id="第一步：将旧电脑的文件拷贝在新电脑上"><a href="#第一步：将旧电脑的文件拷贝在新电脑上" class="headerlink" title="第一步：将旧电脑的文件拷贝在新电脑上"></a>第一步：将旧电脑的文件拷贝在新电脑上</h2><h3 id="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"><a href="#比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统" class="headerlink" title="比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统"></a>比如我在我的c盘建立了一个文件夹为Hexo用来存放我的博客系统</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EyqtU.png" alt="创建文件夹"></p><h3 id="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"><a href="#将原来电脑上的blog和globle拷贝到Hexo文件夹下面" class="headerlink" title="将原来电脑上的blog和globle拷贝到Hexo文件夹下面"></a>将原来电脑上的blog和globle拷贝到Hexo文件夹下面</h3><h3 id="建立Git和node两个空文件夹用来安装Gitbash和Node"><a href="#建立Git和node两个空文件夹用来安装Gitbash和Node" class="headerlink" title="建立Git和node两个空文件夹用来安装Gitbash和Node"></a>建立Git和node两个空文件夹用来安装Gitbash和Node</h3><h2 id="第二步：在新电脑上安装Git-Bash和Node"><a href="#第二步：在新电脑上安装Git-Bash和Node" class="headerlink" title="第二步：在新电脑上安装Git Bash和Node"></a>第二步：在新电脑上安装Git Bash和Node</h2><h3 id="Git-Bash-的下载地址"><a href="#Git-Bash-的下载地址" class="headerlink" title="Git Bash 的下载地址"></a><a href="https://www.git-scm.com/download/win">Git Bash 的下载地址</a></h3><h3 id="Node-的下载地址"><a href="#Node-的下载地址" class="headerlink" title="Node 的下载地址"></a><a href="https://nodejs.org/en/">Node 的下载地址</a></h3><h3 id="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"><a href="#这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹" class="headerlink" title="这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹"></a>这两个软件在安装的时候将安装位置改为步骤一我们建立的文件夹</h3><h3 id="然后全程无脑下一步安装就行了"><a href="#然后全程无脑下一步安装就行了" class="headerlink" title="然后全程无脑下一步安装就行了"></a>然后全程无脑下一步安装就行了</h3><div class="note danger simple"><p>这里特别要注意，Node安装的版本要和你原本电脑上安装的Node版本要一样，不然就会出问题的</p></div><h3 id="安装完成后我们打开按win-R-输入cmd打开控制台"><a href="#安装完成后我们打开按win-R-输入cmd打开控制台" class="headerlink" title="安装完成后我们打开按win+R 输入cmd打开控制台"></a>安装完成后我们打开按win+R 输入cmd打开控制台</h3><p><img src="https://s1.ax1x.com/2020/09/28/0E0JjP.png" alt="打开cmd"></p><h3 id="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"><a href="#输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）" class="headerlink" title="输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）"></a>输入以下两个查看版本号的指令查看是否安装成功（显示下图为安装成功）</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EsOsI.png" alt="查看gitbash和node版本"></p><h2 id="第三步：环境配置"><a href="#第三步：环境配置" class="headerlink" title="第三步：环境配置"></a>第三步：环境配置</h2><h3 id="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）"><a href="#首先找到新电脑的Hexo文件下的globle的地址（比如我的是C-Hexo-globle）" class="headerlink" title="首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）"></a>首先找到新电脑的Hexo文件下的globle的地址（比如我的是C:\Hexo\globle）</h3><h3 id="启动cmd命令输入下下面的指令："><a href="#启动cmd命令输入下下面的指令：" class="headerlink" title="启动cmd命令输入下下面的指令："></a>启动cmd命令输入下下面的指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;C:\Hexo\globle&quot;</span><br><span class="line">npm config set cache &quot;C:\Hexo\globle&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开系统环境变量配置："><a href="#然后打开系统环境变量配置：" class="headerlink" title="然后打开系统环境变量配置："></a>然后打开系统环境变量配置：</h3><h3 id="此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量"><a href="#此电脑右击-gt-属性-gt-高级系统设置-gt-环境变量" class="headerlink" title="此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量"></a>此电脑右击-&gt;属性-&gt;高级系统设置-&gt;环境变量</h3><h3 id="进入如下界面："><a href="#进入如下界面：" class="headerlink" title="进入如下界面："></a>进入如下界面：</h3><p><img src="https://s1.ax1x.com/2020/09/28/0EgB6J.png" alt="环境变量"></p><h3 id="双击path进入如下界面"><a href="#双击path进入如下界面" class="headerlink" title="双击path进入如下界面"></a>双击path进入如下界面</h3><p><img src="https://s1.ax1x.com/2020/09/28/0Eg0l4.png" alt="新建环境变量"></p><h3 id="点击新建然后填写globle的地址，点击确定，完成环境配置"><a href="#点击新建然后填写globle的地址，点击确定，完成环境配置" class="headerlink" title="点击新建然后填写globle的地址，点击确定，完成环境配置"></a>点击新建然后填写globle的地址，点击确定，完成环境配置</h3><h2 id="第四步：测试"><a href="#第四步：测试" class="headerlink" title="第四步：测试"></a>第四步：测试</h2><h3 id="打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令："><a href="#打开cmd，用cd指令进入C-Hexo-blog位置，然后执行如下指令：" class="headerlink" title="打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令："></a>打开cmd，用cd指令进入C:\Hexo\blog位置，然后执行如下指令：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s </span><br></pre></td></tr></table></figure><h3 id="用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功"><a href="#用浏览器打开http-localhost-4000-得到如下自己的博客首页就说明本地能测试成功" class="headerlink" title="用浏览器打开http://localhost:4000 得到如下自己的博客首页就说明本地能测试成功"></a>用浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a> 得到如下自己的博客首页就说明本地能测试成功</h3><p><img src="https://s1.ax1x.com/2020/09/28/0ERLQg.png" alt="页面"></p><h3 id="执行以下指令（自己的邮箱）"><a href="#执行以下指令（自己的邮箱）" class="headerlink" title="执行以下指令（自己的邮箱）"></a>执行以下指令（自己的邮箱）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"><a href="#然后打开这个文件复制里面内容添加到gitee和github上的ssh上去" class="headerlink" title="然后打开这个文件复制里面内容添加到gitee和github上的ssh上去"></a>然后打开这个文件复制里面内容添加到gitee和github上的ssh上去</h3><p><img src="https://voyager-m.gitee.io/picgo/test/hexo1.png"></p><h3 id="其中gitee和github的用户名和密码放在下图中的位置"><a href="#其中gitee和github的用户名和密码放在下图中的位置" class="headerlink" title="其中gitee和github的用户名和密码放在下图中的位置"></a>其中gitee和github的用户名和密码放在下图中的位置</h3><p><img src="https://s1.ax1x.com/2020/09/28/0VpTkq.png"></p><h3 id="在cmd中执行如下指令"><a href="#在cmd中执行如下指令" class="headerlink" title="在cmd中执行如下指令"></a>在cmd中执行如下指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure><h3 id="在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。"><a href="#在浏览器输入自己的博客地址（比如我的是voyager-m-github-io）-若能打开博客说明博客迁移成功。" class="headerlink" title="在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。"></a>在浏览器输入自己的博客地址（比如我的是voyager-m.github.io）,若能打开博客说明博客迁移成功。</h3><h4 id="特别感谢："><a href="#特别感谢：" class="headerlink" title="特别感谢："></a>特别感谢：</h4><p><a href="https://space.bilibili.com/393128277/video">博客搭建</a><br><a href="https://dreamer-liuyang.github.io/posts/4c70a442/">搭建文章版</a><br><a href="https://dreamer-liuyang.github.io/posts/d579f5f8/">美化文章版</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛维杨的第一篇文章</title>
      <link href="posts/fbf6b9c0/"/>
      <url>posts/fbf6b9c0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="你好呀！在下毛同学"><a href="#你好呀！在下毛同学" class="headerlink" title="你好呀！在下毛同学"></a>你好呀！在下毛同学</h1><h1 id="家穷人丑，一米四九"><a href="#家穷人丑，一米四九" class="headerlink" title="家穷人丑，一米四九"></a>家穷人丑，一米四九</h1><h1 id="小学文化，农村户口"><a href="#小学文化，农村户口" class="headerlink" title="小学文化，农村户口"></a>小学文化，农村户口</h1><h1 id="破屋三间，薄田一亩"><a href="#破屋三间，薄田一亩" class="headerlink" title="破屋三间，薄田一亩"></a>破屋三间，薄田一亩</h1><h1 id="冷锅热灶，钱财没有"><a href="#冷锅热灶，钱财没有" class="headerlink" title="冷锅热灶，钱财没有"></a>冷锅热灶，钱财没有</h1><h1 id="一年四季，苦学编程"><a href="#一年四季，苦学编程" class="headerlink" title="一年四季，苦学编程"></a>一年四季，苦学编程</h1><h1 id="今创博客，写下此篇"><a href="#今创博客，写下此篇" class="headerlink" title="今创博客，写下此篇"></a>今创博客，写下此篇</h1><h1 id="学习路上，伴你身边"><a href="#学习路上，伴你身边" class="headerlink" title="学习路上，伴你身边"></a>学习路上，伴你身边</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;既来不留良言三句？&quot;</span>)</span><br></pre></td></tr></table></figure><div class="note success simple"><p>文献提示：评论需要填写昵称和邮箱哦！</p></div>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序员 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
